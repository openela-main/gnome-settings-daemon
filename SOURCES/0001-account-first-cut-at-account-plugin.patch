From d02ca09af14bdaed74fb3e3251aeed485ab419b8 Mon Sep 17 00:00:00 2001
From: Ray Strode <rstrode@redhat.com>
Date: Mon, 6 Nov 2017 14:43:46 -0500
Subject: [PATCH 1/4] account: first cut at account plugin

It just notifies when the user's account is about to expire.

Future commits will make it redisplay the notification after
screen unlock and provide some configurability for regular
nags.
---
 plugins/account/Makefile.am                   |   68 +
 plugins/account/gsd-account-manager.c         |  422 ++
 plugins/account/gsd-account-manager.h         |   54 +
 plugins/account/main.c                        |    7 +
 plugins/account/meson.build                   |   39 +
 .../account/org.freedesktop.Accounts.User.c   | 6176 +++++++++++++++++
 .../account/org.freedesktop.Accounts.User.h   |  725 ++
 .../account/org.freedesktop.Accounts.User.xml |  825 +++
 plugins/account/org.freedesktop.Accounts.c    | 3016 ++++++++
 plugins/account/org.freedesktop.Accounts.h    |  400 ++
 plugins/account/org.freedesktop.Accounts.xml  |  248 +
 .../org.gnome.SettingsDaemon.Account.desktop  |    9 +
 ...rg.gnome.SettingsDaemon.Account.desktop.in |    9 +
 plugins/meson.build                           |    1 +
 14 files changed, 11999 insertions(+)
 create mode 100644 plugins/account/Makefile.am
 create mode 100644 plugins/account/gsd-account-manager.c
 create mode 100644 plugins/account/gsd-account-manager.h
 create mode 100644 plugins/account/main.c
 create mode 100644 plugins/account/meson.build
 create mode 100644 plugins/account/org.freedesktop.Accounts.User.c
 create mode 100644 plugins/account/org.freedesktop.Accounts.User.h
 create mode 100644 plugins/account/org.freedesktop.Accounts.User.xml
 create mode 100644 plugins/account/org.freedesktop.Accounts.c
 create mode 100644 plugins/account/org.freedesktop.Accounts.h
 create mode 100644 plugins/account/org.freedesktop.Accounts.xml
 create mode 100644 plugins/account/org.gnome.SettingsDaemon.Account.desktop
 create mode 100644 plugins/account/org.gnome.SettingsDaemon.Account.desktop.in

diff --git a/plugins/account/Makefile.am b/plugins/account/Makefile.am
new file mode 100644
index 00000000..e06abcf5
--- /dev/null
+++ b/plugins/account/Makefile.am
@@ -0,0 +1,68 @@
+plugin_name = account
+
+dbus_accounts_built_sources = org.freedesktop.Accounts.c org.freedesktop.Accounts.h
+dbus_accounts_user_built_sources = org.freedesktop.Accounts.User.c org.freedesktop.Accounts.User.h
+
+BUILT_SOURCES = $(dbus_accounts_built_sources) \
+		$(dbus_accounts_user_built_sources)
+
+libexec_PROGRAMS = gsd-account
+
+$(dbus_accounts_built_sources) : Makefile.am org.freedesktop.Accounts.xml
+	$(AM_V_GEN) gdbus-codegen \
+	--interface-prefix org.freedesktop. \
+	--c-namespace Gsd \
+	--generate-c-code org.freedesktop.Accounts \
+	--annotate "org.freedesktop.Accounts"	\
+		   "org.gtk.GDBus.C.Name" Accounts	\
+	$(srcdir)/org.freedesktop.Accounts.xml
+
+$(dbus_accounts_user_built_sources) : Makefile.am org.freedesktop.Accounts.User.xml
+	$(AM_V_GEN) gdbus-codegen \
+	--interface-prefix org.freedesktop. \
+	--c-namespace Gsd \
+	--generate-c-code org.freedesktop.Accounts.User \
+	--annotate "org.freedesktop.Accounts.User"	\
+		   "org.gtk.GDBus.C.Name" AccountsUser	\
+	$(srcdir)/org.freedesktop.Accounts.User.xml
+
+gsd_account_SOURCES =		\
+	main.c			\
+	gsd-account-manager.c	\
+	gsd-account-manager.h	\
+	$(COMMON_FILES)
+
+nodist_gsd_account_SOURCES = \
+	$(dbus_accounts_built_sources) \
+	$(dbus_accounts_user_built_sources)
+
+gsd_account_CPPFLAGS =					\
+	-I$(top_srcdir)/data/					\
+	-I$(top_srcdir)/gnome-settings-daemon			\
+	-I$(top_builddir)/gnome-settings-daemon			\
+	-I$(top_srcdir)/plugins/common				\
+	-DGNOME_SETTINGS_LOCALEDIR=\""$(datadir)/locale"\"	\
+	-DLIBEXECDIR=\""$(libexecdir)"\"			\
+	$(AM_CPPFLAGS)
+
+gsd_account_CFLAGS =		\
+	$(PLUGIN_CFLAGS)		\
+	$(ACCOUNT_CFLAGS)
+
+gsd_account_LDADD =					\
+	$(top_builddir)/gnome-settings-daemon/libgsd.la		\
+	$(top_builddir)/plugins/common/libcommon.la		\
+	$(ACCOUNT_LIBS)
+
+desktopdir = $(sysconfdir)/xdg/autostart
+desktop_in_files = org.gnome.SettingsDaemon.Account.desktop.in
+desktop_DATA = $(desktop_in_files:.desktop.in=.desktop)
+
+org.gnome.SettingsDaemon.Account.desktop: $(desktop_in_files) Makefile
+	$(AM_V_GEN) sed -e "s|\@libexecdir\@|$(libexecdir)|" $< > $@
+
+EXTRA_DIST = $(desktop_in_files)
+
+CLEANFILES = $(desktop_DATA)
+
+DISTCLEANFILES = $(desktop_DATA)
diff --git a/plugins/account/gsd-account-manager.c b/plugins/account/gsd-account-manager.c
new file mode 100644
index 00000000..40b91cb6
--- /dev/null
+++ b/plugins/account/gsd-account-manager.c
@@ -0,0 +1,422 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2017 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "config.h"
+
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+
+#include <locale.h>
+
+#include <glib.h>
+#include <glib/gi18n.h>
+#include <glib/gstdio.h>
+
+#include <cups/cups.h>
+#include <cups/ppd.h>
+#include <libnotify/notify.h>
+
+#include "gnome-settings-profile.h"
+#include "gsd-account-manager.h"
+#include "org.freedesktop.Accounts.h"
+#include "org.freedesktop.Accounts.User.h"
+
+#define GSD_ACCOUNT_MANAGER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GSD_TYPE_ACCOUNT_MANAGER, GsdAccountManagerPrivate))
+
+struct GsdAccountManagerPrivate
+{
+        GsdAccounts          *accounts_proxy;
+        GsdAccountsUser      *accounts_user_proxy;
+        GCancellable         *cancellable;
+
+        gint64                expiration_time;
+        gint64                last_change_time;
+        gint64                min_days_between_changes;
+        gint64                max_days_between_changes;
+        gint64                days_to_warn;
+        gint64                days_after_expiration_until_lock;
+
+        NotifyNotification   *notification;
+};
+
+static void     gsd_account_manager_class_init  (GsdAccountManagerClass *klass);
+static void     gsd_account_manager_init        (GsdAccountManager      *account_manager);
+static void     gsd_account_manager_finalize    (GObject                *object);
+
+G_DEFINE_TYPE (GsdAccountManager, gsd_account_manager, G_TYPE_OBJECT)
+
+static gpointer manager_object = NULL;
+
+static void
+on_notification_closed (NotifyNotification *notification,
+                        gpointer            user_data)
+{
+        GsdAccountManager *manager = user_data;
+
+        g_clear_object (&manager->priv->notification);
+}
+
+static void
+hide_notification (GsdAccountManager *manager)
+{
+        if (manager->priv->notification == NULL)
+                return;
+
+        notify_notification_close (manager->priv->notification, NULL);
+        g_clear_object (&manager->priv->notification);
+}
+
+static void
+show_notification (GsdAccountManager *manager,
+                   const char        *primary_text,
+                   const char        *secondary_text)
+{
+        g_assert (manager->priv->notification == NULL);
+
+        manager->priv->notification = notify_notification_new (primary_text,
+                                                               secondary_text,
+                                                               "avatar-default-symbolic");
+        notify_notification_set_app_name (manager->priv->notification, _("User Account"));
+        notify_notification_set_hint (manager->priv->notification,
+                                      "resident",
+                                      g_variant_new_boolean (TRUE));
+        notify_notification_set_timeout (manager->priv->notification,
+                                         NOTIFY_EXPIRES_NEVER);
+
+        g_signal_connect (manager->priv->notification,
+                          "closed",
+                          G_CALLBACK (on_notification_closed),
+                          manager);
+
+        notify_notification_show (manager->priv->notification, NULL);
+}
+
+static void
+update_password_notification (GsdAccountManager *manager)
+{
+        gint64           days_since_epoch;
+        gint64           days_until_expiration = -1;
+        gint64           days_since_last_change = -1;
+        gint64           days_left = -1;
+        g_autofree char *primary_text = NULL;
+        g_autofree char *secondary_text = NULL;
+        gboolean         password_already_expired = FALSE;
+
+        hide_notification (manager);
+
+        days_since_epoch = g_get_real_time () / G_USEC_PER_SEC / 60 / 60 / 24;
+
+        if (manager->priv->expiration_time > 0) {
+                days_until_expiration = manager->priv->expiration_time - days_since_epoch;
+
+                if (days_until_expiration <= 0) {
+                        password_already_expired = TRUE;
+                        goto out;
+                }
+        }
+
+        if (manager->priv->last_change_time == 0) {
+                password_already_expired = TRUE;
+                goto out;
+        }
+
+        days_since_last_change = days_since_epoch - manager->priv->last_change_time;
+
+        if (days_since_last_change < 0) {
+                /* time skew, password was changed in the future! */
+                goto out;
+        }
+
+        if (manager->priv->max_days_between_changes > -1) {
+                if (manager->priv->days_after_expiration_until_lock > -1) {
+                        if ((days_since_last_change > manager->priv->max_days_between_changes) &&
+                            (days_since_last_change > manager->priv->days_after_expiration_until_lock)) {
+                                password_already_expired = TRUE;
+                                goto out;
+                        }
+                }
+
+                if (days_since_last_change > manager->priv->max_days_between_changes) {
+                        password_already_expired = TRUE;
+                        goto out;
+                }
+
+                if (manager->priv->days_to_warn > -1) {
+                        if (days_since_last_change > manager->priv->max_days_between_changes - manager->priv->days_to_warn) {
+                                days_left = manager->priv->last_change_time + manager->priv->max_days_between_changes - days_since_epoch;
+
+                                if (days_until_expiration >= 0)
+                                        days_left = MIN (days_left, days_until_expiration);
+                                goto out;
+                        }
+                }
+        }
+
+out:
+        if (password_already_expired) {
+                primary_text = g_strdup_printf (_("Password Expired"));
+                secondary_text = g_strdup_printf (_("Your password is expired. Please update it."));
+        } else if (days_left >= 0) {
+                primary_text = g_strdup_printf (_("Password Expiring Soon"));
+                if (days_left == 0)
+                    secondary_text = g_strdup_printf (_("Your password is expiring today."));
+                else if (days_left == 1)
+                    secondary_text = g_strdup_printf (_("Your password is expiring in a day."));
+                else
+                    secondary_text = g_strdup_printf (_("Your password is expiring in %ld days."),
+                                                      days_left);
+        }
+
+        if (primary_text != NULL && secondary_text != NULL)
+                show_notification (manager,
+                                   primary_text,
+                                   secondary_text);
+}
+
+static gboolean
+set_policy_number (gint64 *destination,
+                   gint64  source)
+{
+        if (*destination == source)
+                return FALSE;
+
+        *destination = source;
+        return TRUE;
+}
+
+static void
+on_got_password_expiration_policy (GsdAccountsUser *accounts_user_proxy,
+                                   GAsyncResult    *res,
+                                   gpointer         user_data)
+{
+        GsdAccountManager *manager = user_data;
+        g_autoptr(GError)  error = NULL;
+        gboolean           succeeded;
+        gint64             expiration_time;
+        gint64             last_change_time;
+        gint64             min_days_between_changes;
+        gint64             max_days_between_changes;
+        gint64             days_to_warn;
+        gint64             days_after_expiration_until_lock;
+
+        gnome_settings_profile_start (NULL);
+        succeeded = gsd_accounts_user_call_get_password_expiration_policy_finish (accounts_user_proxy,
+                                                                                  &expiration_time,
+                                                                                  &last_change_time,
+                                                                                  &min_days_between_changes,
+                                                                                  &max_days_between_changes,
+                                                                                  &days_to_warn,
+                                                                                  &days_after_expiration_until_lock,
+                                                                                  res,
+                                                                                  &error);
+
+        if (!succeeded) {
+                g_warning ("Failed to get password expiration policy for user: %s", error->message);
+                goto out;
+        }
+
+        set_policy_number (&manager->priv->expiration_time, expiration_time);
+        set_policy_number (&manager->priv->last_change_time, last_change_time);
+        set_policy_number (&manager->priv->min_days_between_changes, min_days_between_changes);
+        set_policy_number (&manager->priv->max_days_between_changes, max_days_between_changes);
+        set_policy_number (&manager->priv->days_to_warn, days_to_warn);
+        set_policy_number (&manager->priv->days_after_expiration_until_lock, days_after_expiration_until_lock);
+
+        update_password_notification (manager);
+out:
+        gnome_settings_profile_end (NULL);
+}
+
+static void
+on_got_accounts_user_proxy (GObject      *source_object,
+                            GAsyncResult *res,
+                            gpointer      user_data)
+{
+        GsdAccountManager *manager = user_data;
+        g_autoptr(GError)  error = NULL;
+
+        gnome_settings_profile_start (NULL);
+        manager->priv->accounts_user_proxy = gsd_accounts_user_proxy_new_finish (res, &error);
+
+        if (manager->priv->accounts_user_proxy != NULL) {
+                gsd_accounts_user_call_get_password_expiration_policy (manager->priv->accounts_user_proxy,
+                                                                       manager->priv->cancellable,
+                                                                       (GAsyncReadyCallback)
+                                                                       on_got_password_expiration_policy,
+                                                                       manager);
+        } else {
+                g_warning ("Failed to get user proxy to accounts service: %s", error->message);
+                goto out;
+        }
+
+out:
+        gnome_settings_profile_end (NULL);
+}
+
+static void
+on_got_user_object_path (GsdAccounts  *accounts_proxy,
+                         GAsyncResult *res,
+                         gpointer      user_data)
+{
+        GsdAccountManager *manager = user_data;
+        g_autoptr(GError)  error = NULL;
+        gboolean           succeeded;
+        gchar             *object_path;
+        GDBusConnection   *connection;
+
+        gnome_settings_profile_start (NULL);
+
+        succeeded = gsd_accounts_call_find_user_by_id_finish (accounts_proxy,
+                                                              &object_path,
+                                                              res,
+                                                              &error);
+
+        if (!succeeded) {
+                g_warning ("Unable to find current user in accounts service: %s",
+                           error->message);
+                goto out;
+        }
+
+        connection = g_dbus_proxy_get_connection (G_DBUS_PROXY (accounts_proxy));
+        gsd_accounts_user_proxy_new (connection,
+                                     G_DBUS_PROXY_FLAGS_NONE,
+                                     "org.freedesktop.Accounts",
+                                     object_path,
+                                     manager->priv->cancellable,
+                                     (GAsyncReadyCallback)
+                                     on_got_accounts_user_proxy,
+                                     manager);
+
+out:
+        gnome_settings_profile_end (NULL);
+}
+
+static void
+on_got_accounts_proxy (GObject      *source_object,
+                       GAsyncResult *res,
+                       gpointer      user_data)
+{
+        GsdAccountManager *manager = user_data;
+        g_autoptr(GError)  error = NULL;
+
+        gnome_settings_profile_start (NULL);
+        manager->priv->accounts_proxy = gsd_accounts_proxy_new_for_bus_finish (res, &error);
+
+        if (manager->priv->accounts_proxy != NULL) {
+                gsd_accounts_call_find_user_by_id (manager->priv->accounts_proxy,
+                                                   getuid (),
+                                                   manager->priv->cancellable,
+                                                   (GAsyncReadyCallback)
+                                                   on_got_user_object_path,
+                                                   manager);
+        } else {
+                g_warning ("Failed to get proxy to accounts service: %s", error->message);
+        }
+        gnome_settings_profile_end (NULL);
+}
+
+gboolean
+gsd_account_manager_start (GsdAccountManager  *manager,
+                           GError            **error)
+{
+        g_debug ("Starting accounts manager");
+
+        gnome_settings_profile_start (NULL);
+        manager->priv->cancellable = g_cancellable_new ();
+        gsd_accounts_proxy_new_for_bus (G_BUS_TYPE_SYSTEM,
+                                        G_DBUS_PROXY_FLAGS_NONE,
+                                        "org.freedesktop.Accounts",
+                                        "/org/freedesktop/Accounts",
+                                        manager->priv->cancellable,
+                                        (GAsyncReadyCallback)
+                                        on_got_accounts_proxy,
+                                        manager);
+        gnome_settings_profile_end (NULL);
+
+        return TRUE;
+}
+
+void
+gsd_account_manager_stop (GsdAccountManager *manager)
+{
+        g_debug ("Stopping accounts manager");
+
+        if (manager->priv->cancellable != NULL) {
+                g_cancellable_cancel (manager->priv->cancellable);
+                g_clear_object (&manager->priv->cancellable);
+        }
+
+        g_clear_object (&manager->priv->accounts_proxy);
+        g_clear_object (&manager->priv->accounts_user_proxy);
+        g_clear_object (&manager->priv->notification);
+}
+
+static void
+gsd_account_manager_class_init (GsdAccountManagerClass *klass)
+{
+        GObjectClass   *object_class = G_OBJECT_CLASS (klass);
+
+        object_class->finalize = gsd_account_manager_finalize;
+
+        notify_init ("gnome-settings-daemon");
+
+        g_type_class_add_private (klass, sizeof (GsdAccountManagerPrivate));
+}
+
+static void
+gsd_account_manager_init (GsdAccountManager *manager)
+{
+        manager->priv = GSD_ACCOUNT_MANAGER_GET_PRIVATE (manager);
+}
+
+static void
+gsd_account_manager_finalize (GObject *object)
+{
+        GsdAccountManager *manager;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GSD_IS_ACCOUNT_MANAGER (object));
+
+        manager = GSD_ACCOUNT_MANAGER (object);
+
+        g_return_if_fail (manager->priv != NULL);
+
+        gsd_account_manager_stop (manager);
+
+        G_OBJECT_CLASS (gsd_account_manager_parent_class)->finalize (object);
+}
+
+GsdAccountManager *
+gsd_account_manager_new (void)
+{
+        if (manager_object != NULL) {
+                g_object_ref (manager_object);
+        } else {
+                manager_object = g_object_new (GSD_TYPE_ACCOUNT_MANAGER, NULL);
+                g_object_add_weak_pointer (manager_object,
+                                           (gpointer *) &manager_object);
+        }
+
+        return GSD_ACCOUNT_MANAGER (manager_object);
+}
diff --git a/plugins/account/gsd-account-manager.h b/plugins/account/gsd-account-manager.h
new file mode 100644
index 00000000..faefcc18
--- /dev/null
+++ b/plugins/account/gsd-account-manager.h
@@ -0,0 +1,54 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2017 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef __GSD_ACCOUNT_MANAGER_H
+#define __GSD_ACCOUNT_MANAGER_H
+
+#include <glib-object.h>
+
+G_BEGIN_DECLS
+
+#define GSD_TYPE_ACCOUNT_MANAGER         (gsd_account_manager_get_type ())
+#define GSD_ACCOUNT_MANAGER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GSD_TYPE_ACCOUNT_MANAGER, GsdAccountManager))
+#define GSD_ACCOUNT_MANAGER_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GSD_TYPE_ACCOUNT_MANAGER, GsdAccountManagerClass))
+#define GSD_IS_ACCOUNT_MANAGER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GSD_TYPE_ACCOUNT_MANAGER))
+#define GSD_IS_ACCOUNT_MANAGER_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GSD_TYPE_ACCOUNT_MANAGER))
+#define GSD_ACCOUNT_MANAGER_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GSD_TYPE_ACCOUNT_MANAGER, GsdAccountManagerClass))
+
+typedef struct GsdAccountManagerPrivate GsdAccountManagerPrivate;
+
+typedef struct {
+        GObject                   parent;
+        GsdAccountManagerPrivate *priv;
+} GsdAccountManager;
+
+typedef struct {
+        GObjectClass   parent_class;
+} GsdAccountManagerClass;
+
+GType               gsd_account_manager_get_type      (void);
+
+GsdAccountManager * gsd_account_manager_new           (void);
+gboolean            gsd_account_manager_start         (GsdAccountManager  *manager,
+                                                       GError            **error);
+void                gsd_account_manager_stop          (GsdAccountManager  *manager);
+
+G_END_DECLS
+
+#endif /* __GSD_ACCOUNT_MANAGER_H */
diff --git a/plugins/account/main.c b/plugins/account/main.c
new file mode 100644
index 00000000..9b854f65
--- /dev/null
+++ b/plugins/account/main.c
@@ -0,0 +1,7 @@
+#define NEW gsd_account_manager_new
+#define START gsd_account_manager_start
+#define STOP gsd_account_manager_stop
+#define MANAGER GsdAccountManager
+#include "gsd-account-manager.h"
+
+#include "daemon-skeleton.h"
diff --git a/plugins/account/meson.build b/plugins/account/meson.build
new file mode 100644
index 00000000..c70ac36e
--- /dev/null
+++ b/plugins/account/meson.build
@@ -0,0 +1,39 @@
+sources = files(
+  'gsd-account-manager.c',
+  'main.c'
+)
+
+sources += gnome.gdbus_codegen(
+  'org.freedesktop.Accounts',
+  'org.freedesktop.Accounts.xml',
+  interface_prefix: 'org.freedesktop.',
+  namespace: 'Gsd',
+  object_manager: false,
+  annotations: ['org.freedesktop.Accounts', 'org.gtk.GDBus.C.Name', 'Accounts']
+)
+
+sources += gnome.gdbus_codegen(
+  'org.freedesktop.Accounts.User',
+  'org.freedesktop.Accounts.User.xml',
+  interface_prefix: 'org.freedesktop.',
+  namespace: 'Gsd',
+  object_manager: false,
+  annotations: ['org.freedesktop.Accounts.User', 'org.gtk.GDBus.C.Name', 'AccountsUser']
+)
+
+deps = plugins_deps + [
+  gio_unix_dep,
+  libnotify_dep,
+  nss_dep
+]
+
+executable(
+  'gsd-' + plugin_name,
+  sources,
+  include_directories: [top_inc, common_inc],
+  dependencies: deps,
+  c_args: cflags,
+  install: true,
+  install_rpath: gsd_pkglibdir,
+  install_dir: gsd_libexecdir
+)
diff --git a/plugins/account/org.freedesktop.Accounts.User.c b/plugins/account/org.freedesktop.Accounts.User.c
new file mode 100644
index 00000000..3b18d185
--- /dev/null
+++ b/plugins/account/org.freedesktop.Accounts.User.c
@@ -0,0 +1,6176 @@
+/*
+ * Generated by gdbus-codegen 2.54.1. DO NOT EDIT.
+ *
+ * The license of this code is the same as for the source it was derived from.
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include "config.h"
+#endif
+
+#include "org.freedesktop.Accounts.User.h"
+
+#include <string.h>
+#ifdef G_OS_UNIX
+#  include <gio/gunixfdlist.h>
+#endif
+
+typedef struct
+{
+  GDBusArgInfo parent_struct;
+  gboolean use_gvariant;
+} _ExtendedGDBusArgInfo;
+
+typedef struct
+{
+  GDBusMethodInfo parent_struct;
+  const gchar *signal_name;
+  gboolean pass_fdlist;
+} _ExtendedGDBusMethodInfo;
+
+typedef struct
+{
+  GDBusSignalInfo parent_struct;
+  const gchar *signal_name;
+} _ExtendedGDBusSignalInfo;
+
+typedef struct
+{
+  GDBusPropertyInfo parent_struct;
+  const gchar *hyphen_name;
+  gboolean use_gvariant;
+} _ExtendedGDBusPropertyInfo;
+
+typedef struct
+{
+  GDBusInterfaceInfo parent_struct;
+  const gchar *hyphen_name;
+} _ExtendedGDBusInterfaceInfo;
+
+typedef struct
+{
+  const _ExtendedGDBusPropertyInfo *info;
+  guint prop_id;
+  GValue orig_value; /* the value before the change */
+} ChangedProperty;
+
+static void
+_changed_property_free (ChangedProperty *data)
+{
+  g_value_unset (&data->orig_value);
+  g_free (data);
+}
+
+static gboolean
+_g_strv_equal0 (gchar **a, gchar **b)
+{
+  gboolean ret = FALSE;
+  guint n;
+  if (a == NULL && b == NULL)
+    {
+      ret = TRUE;
+      goto out;
+    }
+  if (a == NULL || b == NULL)
+    goto out;
+  if (g_strv_length (a) != g_strv_length (b))
+    goto out;
+  for (n = 0; a[n] != NULL; n++)
+    if (g_strcmp0 (a[n], b[n]) != 0)
+      goto out;
+  ret = TRUE;
+out:
+  return ret;
+}
+
+static gboolean
+_g_variant_equal0 (GVariant *a, GVariant *b)
+{
+  gboolean ret = FALSE;
+  if (a == NULL && b == NULL)
+    {
+      ret = TRUE;
+      goto out;
+    }
+  if (a == NULL || b == NULL)
+    goto out;
+  ret = g_variant_equal (a, b);
+out:
+  return ret;
+}
+
+G_GNUC_UNUSED static gboolean
+_g_value_equal (const GValue *a, const GValue *b)
+{
+  gboolean ret = FALSE;
+  g_assert (G_VALUE_TYPE (a) == G_VALUE_TYPE (b));
+  switch (G_VALUE_TYPE (a))
+    {
+      case G_TYPE_BOOLEAN:
+        ret = (g_value_get_boolean (a) == g_value_get_boolean (b));
+        break;
+      case G_TYPE_UCHAR:
+        ret = (g_value_get_uchar (a) == g_value_get_uchar (b));
+        break;
+      case G_TYPE_INT:
+        ret = (g_value_get_int (a) == g_value_get_int (b));
+        break;
+      case G_TYPE_UINT:
+        ret = (g_value_get_uint (a) == g_value_get_uint (b));
+        break;
+      case G_TYPE_INT64:
+        ret = (g_value_get_int64 (a) == g_value_get_int64 (b));
+        break;
+      case G_TYPE_UINT64:
+        ret = (g_value_get_uint64 (a) == g_value_get_uint64 (b));
+        break;
+      case G_TYPE_DOUBLE:
+        {
+          /* Avoid -Wfloat-equal warnings by doing a direct bit compare */
+          gdouble da = g_value_get_double (a);
+          gdouble db = g_value_get_double (b);
+          ret = memcmp (&da, &db, sizeof (gdouble)) == 0;
+        }
+        break;
+      case G_TYPE_STRING:
+        ret = (g_strcmp0 (g_value_get_string (a), g_value_get_string (b)) == 0);
+        break;
+      case G_TYPE_VARIANT:
+        ret = _g_variant_equal0 (g_value_get_variant (a), g_value_get_variant (b));
+        break;
+      default:
+        if (G_VALUE_TYPE (a) == G_TYPE_STRV)
+          ret = _g_strv_equal0 (g_value_get_boxed (a), g_value_get_boxed (b));
+        else
+          g_critical ("_g_value_equal() does not handle type %s", g_type_name (G_VALUE_TYPE (a)));
+        break;
+    }
+  return ret;
+}
+
+/* ------------------------------------------------------------------------
+ * Code for interface org.freedesktop.Accounts.User
+ * ------------------------------------------------------------------------
+ */
+
+/**
+ * SECTION:GsdAccountsUser
+ * @title: GsdAccountsUser
+ * @short_description: Generated C code for the org.freedesktop.Accounts.User D-Bus interface
+ *
+ * This section contains code for working with the <link linkend="gdbus-interface-org-freedesktop-Accounts-User.top_of_page">org.freedesktop.Accounts.User</link> D-Bus interface in C.
+ */
+
+/* ---- Introspection data for org.freedesktop.Accounts.User ---- */
+
+static const _ExtendedGDBusArgInfo _gsd_accounts_user_method_info_set_user_name_IN_ARG_name =
+{
+  {
+    -1,
+    (gchar *) "name",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo * const _gsd_accounts_user_method_info_set_user_name_IN_ARG_pointers[] =
+{
+  &_gsd_accounts_user_method_info_set_user_name_IN_ARG_name,
+  NULL
+};
+
+static const GDBusAnnotationInfo _gsd_accounts_user_method_set_user_name_annotation_info_0 =
+{
+  -1,
+  (gchar *) "org.freedesktop.DBus.GLib.Async",
+  (gchar *) "",
+  NULL
+};
+
+static const GDBusAnnotationInfo * const _gsd_accounts_user_method_set_user_name_annotation_info_pointers[] =
+{
+  &_gsd_accounts_user_method_set_user_name_annotation_info_0,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _gsd_accounts_user_method_info_set_user_name =
+{
+  {
+    -1,
+    (gchar *) "SetUserName",
+    (GDBusArgInfo **) &_gsd_accounts_user_method_info_set_user_name_IN_ARG_pointers,
+    NULL,
+    (GDBusAnnotationInfo **) &_gsd_accounts_user_method_set_user_name_annotation_info_pointers
+  },
+  "handle-set-user-name",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gsd_accounts_user_method_info_set_real_name_IN_ARG_name =
+{
+  {
+    -1,
+    (gchar *) "name",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo * const _gsd_accounts_user_method_info_set_real_name_IN_ARG_pointers[] =
+{
+  &_gsd_accounts_user_method_info_set_real_name_IN_ARG_name,
+  NULL
+};
+
+static const GDBusAnnotationInfo _gsd_accounts_user_method_set_real_name_annotation_info_0 =
+{
+  -1,
+  (gchar *) "org.freedesktop.DBus.GLib.Async",
+  (gchar *) "",
+  NULL
+};
+
+static const GDBusAnnotationInfo * const _gsd_accounts_user_method_set_real_name_annotation_info_pointers[] =
+{
+  &_gsd_accounts_user_method_set_real_name_annotation_info_0,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _gsd_accounts_user_method_info_set_real_name =
+{
+  {
+    -1,
+    (gchar *) "SetRealName",
+    (GDBusArgInfo **) &_gsd_accounts_user_method_info_set_real_name_IN_ARG_pointers,
+    NULL,
+    (GDBusAnnotationInfo **) &_gsd_accounts_user_method_set_real_name_annotation_info_pointers
+  },
+  "handle-set-real-name",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gsd_accounts_user_method_info_set_email_IN_ARG_email =
+{
+  {
+    -1,
+    (gchar *) "email",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo * const _gsd_accounts_user_method_info_set_email_IN_ARG_pointers[] =
+{
+  &_gsd_accounts_user_method_info_set_email_IN_ARG_email,
+  NULL
+};
+
+static const GDBusAnnotationInfo _gsd_accounts_user_method_set_email_annotation_info_0 =
+{
+  -1,
+  (gchar *) "org.freedesktop.DBus.GLib.Async",
+  (gchar *) "",
+  NULL
+};
+
+static const GDBusAnnotationInfo * const _gsd_accounts_user_method_set_email_annotation_info_pointers[] =
+{
+  &_gsd_accounts_user_method_set_email_annotation_info_0,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _gsd_accounts_user_method_info_set_email =
+{
+  {
+    -1,
+    (gchar *) "SetEmail",
+    (GDBusArgInfo **) &_gsd_accounts_user_method_info_set_email_IN_ARG_pointers,
+    NULL,
+    (GDBusAnnotationInfo **) &_gsd_accounts_user_method_set_email_annotation_info_pointers
+  },
+  "handle-set-email",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gsd_accounts_user_method_info_set_language_IN_ARG_language =
+{
+  {
+    -1,
+    (gchar *) "language",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo * const _gsd_accounts_user_method_info_set_language_IN_ARG_pointers[] =
+{
+  &_gsd_accounts_user_method_info_set_language_IN_ARG_language,
+  NULL
+};
+
+static const GDBusAnnotationInfo _gsd_accounts_user_method_set_language_annotation_info_0 =
+{
+  -1,
+  (gchar *) "org.freedesktop.DBus.GLib.Async",
+  (gchar *) "",
+  NULL
+};
+
+static const GDBusAnnotationInfo * const _gsd_accounts_user_method_set_language_annotation_info_pointers[] =
+{
+  &_gsd_accounts_user_method_set_language_annotation_info_0,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _gsd_accounts_user_method_info_set_language =
+{
+  {
+    -1,
+    (gchar *) "SetLanguage",
+    (GDBusArgInfo **) &_gsd_accounts_user_method_info_set_language_IN_ARG_pointers,
+    NULL,
+    (GDBusAnnotationInfo **) &_gsd_accounts_user_method_set_language_annotation_info_pointers
+  },
+  "handle-set-language",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gsd_accounts_user_method_info_set_xsession_IN_ARG_x_session =
+{
+  {
+    -1,
+    (gchar *) "x_session",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo * const _gsd_accounts_user_method_info_set_xsession_IN_ARG_pointers[] =
+{
+  &_gsd_accounts_user_method_info_set_xsession_IN_ARG_x_session,
+  NULL
+};
+
+static const GDBusAnnotationInfo _gsd_accounts_user_method_set_xsession_annotation_info_0 =
+{
+  -1,
+  (gchar *) "org.freedesktop.DBus.GLib.Async",
+  (gchar *) "",
+  NULL
+};
+
+static const GDBusAnnotationInfo _gsd_accounts_user_method_set_xsession_annotation_info_1 =
+{
+  -1,
+  (gchar *) "org.freedesktop.DBus.GLib.CSymbol",
+  (gchar *) "user_set_x_session",
+  NULL
+};
+
+static const GDBusAnnotationInfo * const _gsd_accounts_user_method_set_xsession_annotation_info_pointers[] =
+{
+  &_gsd_accounts_user_method_set_xsession_annotation_info_0,
+  &_gsd_accounts_user_method_set_xsession_annotation_info_1,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _gsd_accounts_user_method_info_set_xsession =
+{
+  {
+    -1,
+    (gchar *) "SetXSession",
+    (GDBusArgInfo **) &_gsd_accounts_user_method_info_set_xsession_IN_ARG_pointers,
+    NULL,
+    (GDBusAnnotationInfo **) &_gsd_accounts_user_method_set_xsession_annotation_info_pointers
+  },
+  "handle-set-xsession",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gsd_accounts_user_method_info_set_location_IN_ARG_location =
+{
+  {
+    -1,
+    (gchar *) "location",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo * const _gsd_accounts_user_method_info_set_location_IN_ARG_pointers[] =
+{
+  &_gsd_accounts_user_method_info_set_location_IN_ARG_location,
+  NULL
+};
+
+static const GDBusAnnotationInfo _gsd_accounts_user_method_set_location_annotation_info_0 =
+{
+  -1,
+  (gchar *) "org.freedesktop.DBus.GLib.Async",
+  (gchar *) "",
+  NULL
+};
+
+static const GDBusAnnotationInfo * const _gsd_accounts_user_method_set_location_annotation_info_pointers[] =
+{
+  &_gsd_accounts_user_method_set_location_annotation_info_0,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _gsd_accounts_user_method_info_set_location =
+{
+  {
+    -1,
+    (gchar *) "SetLocation",
+    (GDBusArgInfo **) &_gsd_accounts_user_method_info_set_location_IN_ARG_pointers,
+    NULL,
+    (GDBusAnnotationInfo **) &_gsd_accounts_user_method_set_location_annotation_info_pointers
+  },
+  "handle-set-location",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gsd_accounts_user_method_info_set_home_directory_IN_ARG_homedir =
+{
+  {
+    -1,
+    (gchar *) "homedir",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo * const _gsd_accounts_user_method_info_set_home_directory_IN_ARG_pointers[] =
+{
+  &_gsd_accounts_user_method_info_set_home_directory_IN_ARG_homedir,
+  NULL
+};
+
+static const GDBusAnnotationInfo _gsd_accounts_user_method_set_home_directory_annotation_info_0 =
+{
+  -1,
+  (gchar *) "org.freedesktop.DBus.GLib.Async",
+  (gchar *) "",
+  NULL
+};
+
+static const GDBusAnnotationInfo * const _gsd_accounts_user_method_set_home_directory_annotation_info_pointers[] =
+{
+  &_gsd_accounts_user_method_set_home_directory_annotation_info_0,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _gsd_accounts_user_method_info_set_home_directory =
+{
+  {
+    -1,
+    (gchar *) "SetHomeDirectory",
+    (GDBusArgInfo **) &_gsd_accounts_user_method_info_set_home_directory_IN_ARG_pointers,
+    NULL,
+    (GDBusAnnotationInfo **) &_gsd_accounts_user_method_set_home_directory_annotation_info_pointers
+  },
+  "handle-set-home-directory",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gsd_accounts_user_method_info_set_shell_IN_ARG_shell =
+{
+  {
+    -1,
+    (gchar *) "shell",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo * const _gsd_accounts_user_method_info_set_shell_IN_ARG_pointers[] =
+{
+  &_gsd_accounts_user_method_info_set_shell_IN_ARG_shell,
+  NULL
+};
+
+static const GDBusAnnotationInfo _gsd_accounts_user_method_set_shell_annotation_info_0 =
+{
+  -1,
+  (gchar *) "org.freedesktop.DBus.GLib.Async",
+  (gchar *) "",
+  NULL
+};
+
+static const GDBusAnnotationInfo * const _gsd_accounts_user_method_set_shell_annotation_info_pointers[] =
+{
+  &_gsd_accounts_user_method_set_shell_annotation_info_0,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _gsd_accounts_user_method_info_set_shell =
+{
+  {
+    -1,
+    (gchar *) "SetShell",
+    (GDBusArgInfo **) &_gsd_accounts_user_method_info_set_shell_IN_ARG_pointers,
+    NULL,
+    (GDBusAnnotationInfo **) &_gsd_accounts_user_method_set_shell_annotation_info_pointers
+  },
+  "handle-set-shell",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gsd_accounts_user_method_info_set_icon_file_IN_ARG_filename =
+{
+  {
+    -1,
+    (gchar *) "filename",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo * const _gsd_accounts_user_method_info_set_icon_file_IN_ARG_pointers[] =
+{
+  &_gsd_accounts_user_method_info_set_icon_file_IN_ARG_filename,
+  NULL
+};
+
+static const GDBusAnnotationInfo _gsd_accounts_user_method_set_icon_file_annotation_info_0 =
+{
+  -1,
+  (gchar *) "org.freedesktop.DBus.GLib.Async",
+  (gchar *) "",
+  NULL
+};
+
+static const GDBusAnnotationInfo * const _gsd_accounts_user_method_set_icon_file_annotation_info_pointers[] =
+{
+  &_gsd_accounts_user_method_set_icon_file_annotation_info_0,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _gsd_accounts_user_method_info_set_icon_file =
+{
+  {
+    -1,
+    (gchar *) "SetIconFile",
+    (GDBusArgInfo **) &_gsd_accounts_user_method_info_set_icon_file_IN_ARG_pointers,
+    NULL,
+    (GDBusAnnotationInfo **) &_gsd_accounts_user_method_set_icon_file_annotation_info_pointers
+  },
+  "handle-set-icon-file",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gsd_accounts_user_method_info_set_locked_IN_ARG_locked =
+{
+  {
+    -1,
+    (gchar *) "locked",
+    (gchar *) "b",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo * const _gsd_accounts_user_method_info_set_locked_IN_ARG_pointers[] =
+{
+  &_gsd_accounts_user_method_info_set_locked_IN_ARG_locked,
+  NULL
+};
+
+static const GDBusAnnotationInfo _gsd_accounts_user_method_set_locked_annotation_info_0 =
+{
+  -1,
+  (gchar *) "org.freedesktop.DBus.GLib.Async",
+  (gchar *) "",
+  NULL
+};
+
+static const GDBusAnnotationInfo * const _gsd_accounts_user_method_set_locked_annotation_info_pointers[] =
+{
+  &_gsd_accounts_user_method_set_locked_annotation_info_0,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _gsd_accounts_user_method_info_set_locked =
+{
+  {
+    -1,
+    (gchar *) "SetLocked",
+    (GDBusArgInfo **) &_gsd_accounts_user_method_info_set_locked_IN_ARG_pointers,
+    NULL,
+    (GDBusAnnotationInfo **) &_gsd_accounts_user_method_set_locked_annotation_info_pointers
+  },
+  "handle-set-locked",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gsd_accounts_user_method_info_set_account_type_IN_ARG_accountType =
+{
+  {
+    -1,
+    (gchar *) "accountType",
+    (gchar *) "i",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo * const _gsd_accounts_user_method_info_set_account_type_IN_ARG_pointers[] =
+{
+  &_gsd_accounts_user_method_info_set_account_type_IN_ARG_accountType,
+  NULL
+};
+
+static const GDBusAnnotationInfo _gsd_accounts_user_method_set_account_type_annotation_info_0 =
+{
+  -1,
+  (gchar *) "org.freedesktop.DBus.GLib.Async",
+  (gchar *) "",
+  NULL
+};
+
+static const GDBusAnnotationInfo * const _gsd_accounts_user_method_set_account_type_annotation_info_pointers[] =
+{
+  &_gsd_accounts_user_method_set_account_type_annotation_info_0,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _gsd_accounts_user_method_info_set_account_type =
+{
+  {
+    -1,
+    (gchar *) "SetAccountType",
+    (GDBusArgInfo **) &_gsd_accounts_user_method_info_set_account_type_IN_ARG_pointers,
+    NULL,
+    (GDBusAnnotationInfo **) &_gsd_accounts_user_method_set_account_type_annotation_info_pointers
+  },
+  "handle-set-account-type",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gsd_accounts_user_method_info_set_password_mode_IN_ARG_mode =
+{
+  {
+    -1,
+    (gchar *) "mode",
+    (gchar *) "i",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo * const _gsd_accounts_user_method_info_set_password_mode_IN_ARG_pointers[] =
+{
+  &_gsd_accounts_user_method_info_set_password_mode_IN_ARG_mode,
+  NULL
+};
+
+static const GDBusAnnotationInfo _gsd_accounts_user_method_set_password_mode_annotation_info_0 =
+{
+  -1,
+  (gchar *) "org.freedesktop.DBus.GLib.Async",
+  (gchar *) "",
+  NULL
+};
+
+static const GDBusAnnotationInfo * const _gsd_accounts_user_method_set_password_mode_annotation_info_pointers[] =
+{
+  &_gsd_accounts_user_method_set_password_mode_annotation_info_0,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _gsd_accounts_user_method_info_set_password_mode =
+{
+  {
+    -1,
+    (gchar *) "SetPasswordMode",
+    (GDBusArgInfo **) &_gsd_accounts_user_method_info_set_password_mode_IN_ARG_pointers,
+    NULL,
+    (GDBusAnnotationInfo **) &_gsd_accounts_user_method_set_password_mode_annotation_info_pointers
+  },
+  "handle-set-password-mode",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gsd_accounts_user_method_info_set_password_IN_ARG_password =
+{
+  {
+    -1,
+    (gchar *) "password",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gsd_accounts_user_method_info_set_password_IN_ARG_hint =
+{
+  {
+    -1,
+    (gchar *) "hint",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo * const _gsd_accounts_user_method_info_set_password_IN_ARG_pointers[] =
+{
+  &_gsd_accounts_user_method_info_set_password_IN_ARG_password,
+  &_gsd_accounts_user_method_info_set_password_IN_ARG_hint,
+  NULL
+};
+
+static const GDBusAnnotationInfo _gsd_accounts_user_method_set_password_annotation_info_0 =
+{
+  -1,
+  (gchar *) "org.freedesktop.DBus.GLib.Async",
+  (gchar *) "",
+  NULL
+};
+
+static const GDBusAnnotationInfo * const _gsd_accounts_user_method_set_password_annotation_info_pointers[] =
+{
+  &_gsd_accounts_user_method_set_password_annotation_info_0,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _gsd_accounts_user_method_info_set_password =
+{
+  {
+    -1,
+    (gchar *) "SetPassword",
+    (GDBusArgInfo **) &_gsd_accounts_user_method_info_set_password_IN_ARG_pointers,
+    NULL,
+    (GDBusAnnotationInfo **) &_gsd_accounts_user_method_set_password_annotation_info_pointers
+  },
+  "handle-set-password",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gsd_accounts_user_method_info_set_password_hint_IN_ARG_hint =
+{
+  {
+    -1,
+    (gchar *) "hint",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo * const _gsd_accounts_user_method_info_set_password_hint_IN_ARG_pointers[] =
+{
+  &_gsd_accounts_user_method_info_set_password_hint_IN_ARG_hint,
+  NULL
+};
+
+static const GDBusAnnotationInfo _gsd_accounts_user_method_set_password_hint_annotation_info_0 =
+{
+  -1,
+  (gchar *) "org.freedesktop.DBus.GLib.Async",
+  (gchar *) "",
+  NULL
+};
+
+static const GDBusAnnotationInfo * const _gsd_accounts_user_method_set_password_hint_annotation_info_pointers[] =
+{
+  &_gsd_accounts_user_method_set_password_hint_annotation_info_0,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _gsd_accounts_user_method_info_set_password_hint =
+{
+  {
+    -1,
+    (gchar *) "SetPasswordHint",
+    (GDBusArgInfo **) &_gsd_accounts_user_method_info_set_password_hint_IN_ARG_pointers,
+    NULL,
+    (GDBusAnnotationInfo **) &_gsd_accounts_user_method_set_password_hint_annotation_info_pointers
+  },
+  "handle-set-password-hint",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gsd_accounts_user_method_info_set_automatic_login_IN_ARG_enabled =
+{
+  {
+    -1,
+    (gchar *) "enabled",
+    (gchar *) "b",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo * const _gsd_accounts_user_method_info_set_automatic_login_IN_ARG_pointers[] =
+{
+  &_gsd_accounts_user_method_info_set_automatic_login_IN_ARG_enabled,
+  NULL
+};
+
+static const GDBusAnnotationInfo _gsd_accounts_user_method_set_automatic_login_annotation_info_0 =
+{
+  -1,
+  (gchar *) "org.freedesktop.DBus.GLib.Async",
+  (gchar *) "",
+  NULL
+};
+
+static const GDBusAnnotationInfo * const _gsd_accounts_user_method_set_automatic_login_annotation_info_pointers[] =
+{
+  &_gsd_accounts_user_method_set_automatic_login_annotation_info_0,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _gsd_accounts_user_method_info_set_automatic_login =
+{
+  {
+    -1,
+    (gchar *) "SetAutomaticLogin",
+    (GDBusArgInfo **) &_gsd_accounts_user_method_info_set_automatic_login_IN_ARG_pointers,
+    NULL,
+    (GDBusAnnotationInfo **) &_gsd_accounts_user_method_set_automatic_login_annotation_info_pointers
+  },
+  "handle-set-automatic-login",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gsd_accounts_user_method_info_get_password_expiration_policy_OUT_ARG_expiration_time =
+{
+  {
+    -1,
+    (gchar *) "expiration_time",
+    (gchar *) "x",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gsd_accounts_user_method_info_get_password_expiration_policy_OUT_ARG_last_change_time =
+{
+  {
+    -1,
+    (gchar *) "last_change_time",
+    (gchar *) "x",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gsd_accounts_user_method_info_get_password_expiration_policy_OUT_ARG_min_days_between_changes =
+{
+  {
+    -1,
+    (gchar *) "min_days_between_changes",
+    (gchar *) "x",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gsd_accounts_user_method_info_get_password_expiration_policy_OUT_ARG_max_days_between_changes =
+{
+  {
+    -1,
+    (gchar *) "max_days_between_changes",
+    (gchar *) "x",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gsd_accounts_user_method_info_get_password_expiration_policy_OUT_ARG_days_to_warn =
+{
+  {
+    -1,
+    (gchar *) "days_to_warn",
+    (gchar *) "x",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gsd_accounts_user_method_info_get_password_expiration_policy_OUT_ARG_days_after_expiration_until_lock =
+{
+  {
+    -1,
+    (gchar *) "days_after_expiration_until_lock",
+    (gchar *) "x",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo * const _gsd_accounts_user_method_info_get_password_expiration_policy_OUT_ARG_pointers[] =
+{
+  &_gsd_accounts_user_method_info_get_password_expiration_policy_OUT_ARG_expiration_time,
+  &_gsd_accounts_user_method_info_get_password_expiration_policy_OUT_ARG_last_change_time,
+  &_gsd_accounts_user_method_info_get_password_expiration_policy_OUT_ARG_min_days_between_changes,
+  &_gsd_accounts_user_method_info_get_password_expiration_policy_OUT_ARG_max_days_between_changes,
+  &_gsd_accounts_user_method_info_get_password_expiration_policy_OUT_ARG_days_to_warn,
+  &_gsd_accounts_user_method_info_get_password_expiration_policy_OUT_ARG_days_after_expiration_until_lock,
+  NULL
+};
+
+static const GDBusAnnotationInfo _gsd_accounts_user_method_get_password_expiration_policy_annotation_info_0 =
+{
+  -1,
+  (gchar *) "org.freedesktop.DBus.GLib.Async",
+  (gchar *) "",
+  NULL
+};
+
+static const GDBusAnnotationInfo * const _gsd_accounts_user_method_get_password_expiration_policy_annotation_info_pointers[] =
+{
+  &_gsd_accounts_user_method_get_password_expiration_policy_annotation_info_0,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _gsd_accounts_user_method_info_get_password_expiration_policy =
+{
+  {
+    -1,
+    (gchar *) "GetPasswordExpirationPolicy",
+    NULL,
+    (GDBusArgInfo **) &_gsd_accounts_user_method_info_get_password_expiration_policy_OUT_ARG_pointers,
+    (GDBusAnnotationInfo **) &_gsd_accounts_user_method_get_password_expiration_policy_annotation_info_pointers
+  },
+  "handle-get-password-expiration-policy",
+  FALSE
+};
+
+static const _ExtendedGDBusMethodInfo * const _gsd_accounts_user_method_info_pointers[] =
+{
+  &_gsd_accounts_user_method_info_set_user_name,
+  &_gsd_accounts_user_method_info_set_real_name,
+  &_gsd_accounts_user_method_info_set_email,
+  &_gsd_accounts_user_method_info_set_language,
+  &_gsd_accounts_user_method_info_set_xsession,
+  &_gsd_accounts_user_method_info_set_location,
+  &_gsd_accounts_user_method_info_set_home_directory,
+  &_gsd_accounts_user_method_info_set_shell,
+  &_gsd_accounts_user_method_info_set_icon_file,
+  &_gsd_accounts_user_method_info_set_locked,
+  &_gsd_accounts_user_method_info_set_account_type,
+  &_gsd_accounts_user_method_info_set_password_mode,
+  &_gsd_accounts_user_method_info_set_password,
+  &_gsd_accounts_user_method_info_set_password_hint,
+  &_gsd_accounts_user_method_info_set_automatic_login,
+  &_gsd_accounts_user_method_info_get_password_expiration_policy,
+  NULL
+};
+
+static const _ExtendedGDBusSignalInfo _gsd_accounts_user_signal_info_changed =
+{
+  {
+    -1,
+    (gchar *) "Changed",
+    NULL,
+    NULL
+  },
+  "changed"
+};
+
+static const _ExtendedGDBusSignalInfo * const _gsd_accounts_user_signal_info_pointers[] =
+{
+  &_gsd_accounts_user_signal_info_changed,
+  NULL
+};
+
+static const _ExtendedGDBusPropertyInfo _gsd_accounts_user_property_info_uid =
+{
+  {
+    -1,
+    (gchar *) "Uid",
+    (gchar *) "t",
+    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
+    NULL
+  },
+  "uid",
+  FALSE
+};
+
+static const _ExtendedGDBusPropertyInfo _gsd_accounts_user_property_info_user_name =
+{
+  {
+    -1,
+    (gchar *) "UserName",
+    (gchar *) "s",
+    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
+    NULL
+  },
+  "user-name",
+  FALSE
+};
+
+static const _ExtendedGDBusPropertyInfo _gsd_accounts_user_property_info_real_name =
+{
+  {
+    -1,
+    (gchar *) "RealName",
+    (gchar *) "s",
+    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
+    NULL
+  },
+  "real-name",
+  FALSE
+};
+
+static const _ExtendedGDBusPropertyInfo _gsd_accounts_user_property_info_account_type =
+{
+  {
+    -1,
+    (gchar *) "AccountType",
+    (gchar *) "i",
+    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
+    NULL
+  },
+  "account-type",
+  FALSE
+};
+
+static const _ExtendedGDBusPropertyInfo _gsd_accounts_user_property_info_home_directory =
+{
+  {
+    -1,
+    (gchar *) "HomeDirectory",
+    (gchar *) "s",
+    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
+    NULL
+  },
+  "home-directory",
+  FALSE
+};
+
+static const _ExtendedGDBusPropertyInfo _gsd_accounts_user_property_info_shell =
+{
+  {
+    -1,
+    (gchar *) "Shell",
+    (gchar *) "s",
+    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
+    NULL
+  },
+  "shell",
+  FALSE
+};
+
+static const _ExtendedGDBusPropertyInfo _gsd_accounts_user_property_info_email =
+{
+  {
+    -1,
+    (gchar *) "Email",
+    (gchar *) "s",
+    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
+    NULL
+  },
+  "email",
+  FALSE
+};
+
+static const _ExtendedGDBusPropertyInfo _gsd_accounts_user_property_info_language =
+{
+  {
+    -1,
+    (gchar *) "Language",
+    (gchar *) "s",
+    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
+    NULL
+  },
+  "language",
+  FALSE
+};
+
+static const _ExtendedGDBusPropertyInfo _gsd_accounts_user_property_info_xsession =
+{
+  {
+    -1,
+    (gchar *) "XSession",
+    (gchar *) "s",
+    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
+    NULL
+  },
+  "xsession",
+  FALSE
+};
+
+static const _ExtendedGDBusPropertyInfo _gsd_accounts_user_property_info_location =
+{
+  {
+    -1,
+    (gchar *) "Location",
+    (gchar *) "s",
+    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
+    NULL
+  },
+  "location",
+  FALSE
+};
+
+static const _ExtendedGDBusPropertyInfo _gsd_accounts_user_property_info_login_frequency =
+{
+  {
+    -1,
+    (gchar *) "LoginFrequency",
+    (gchar *) "t",
+    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
+    NULL
+  },
+  "login-frequency",
+  FALSE
+};
+
+static const _ExtendedGDBusPropertyInfo _gsd_accounts_user_property_info_login_time =
+{
+  {
+    -1,
+    (gchar *) "LoginTime",
+    (gchar *) "x",
+    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
+    NULL
+  },
+  "login-time",
+  FALSE
+};
+
+static const _ExtendedGDBusPropertyInfo _gsd_accounts_user_property_info_login_history =
+{
+  {
+    -1,
+    (gchar *) "LoginHistory",
+    (gchar *) "a(xxa{sv})",
+    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
+    NULL
+  },
+  "login-history",
+  FALSE
+};
+
+static const _ExtendedGDBusPropertyInfo _gsd_accounts_user_property_info_icon_file =
+{
+  {
+    -1,
+    (gchar *) "IconFile",
+    (gchar *) "s",
+    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
+    NULL
+  },
+  "icon-file",
+  FALSE
+};
+
+static const _ExtendedGDBusPropertyInfo _gsd_accounts_user_property_info_locked =
+{
+  {
+    -1,
+    (gchar *) "Locked",
+    (gchar *) "b",
+    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
+    NULL
+  },
+  "locked",
+  FALSE
+};
+
+static const _ExtendedGDBusPropertyInfo _gsd_accounts_user_property_info_password_mode =
+{
+  {
+    -1,
+    (gchar *) "PasswordMode",
+    (gchar *) "i",
+    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
+    NULL
+  },
+  "password-mode",
+  FALSE
+};
+
+static const _ExtendedGDBusPropertyInfo _gsd_accounts_user_property_info_password_hint =
+{
+  {
+    -1,
+    (gchar *) "PasswordHint",
+    (gchar *) "s",
+    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
+    NULL
+  },
+  "password-hint",
+  FALSE
+};
+
+static const _ExtendedGDBusPropertyInfo _gsd_accounts_user_property_info_automatic_login =
+{
+  {
+    -1,
+    (gchar *) "AutomaticLogin",
+    (gchar *) "b",
+    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
+    NULL
+  },
+  "automatic-login",
+  FALSE
+};
+
+static const _ExtendedGDBusPropertyInfo _gsd_accounts_user_property_info_system_account =
+{
+  {
+    -1,
+    (gchar *) "SystemAccount",
+    (gchar *) "b",
+    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
+    NULL
+  },
+  "system-account",
+  FALSE
+};
+
+static const _ExtendedGDBusPropertyInfo _gsd_accounts_user_property_info_local_account =
+{
+  {
+    -1,
+    (gchar *) "LocalAccount",
+    (gchar *) "b",
+    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
+    NULL
+  },
+  "local-account",
+  FALSE
+};
+
+static const _ExtendedGDBusPropertyInfo * const _gsd_accounts_user_property_info_pointers[] =
+{
+  &_gsd_accounts_user_property_info_uid,
+  &_gsd_accounts_user_property_info_user_name,
+  &_gsd_accounts_user_property_info_real_name,
+  &_gsd_accounts_user_property_info_account_type,
+  &_gsd_accounts_user_property_info_home_directory,
+  &_gsd_accounts_user_property_info_shell,
+  &_gsd_accounts_user_property_info_email,
+  &_gsd_accounts_user_property_info_language,
+  &_gsd_accounts_user_property_info_xsession,
+  &_gsd_accounts_user_property_info_location,
+  &_gsd_accounts_user_property_info_login_frequency,
+  &_gsd_accounts_user_property_info_login_time,
+  &_gsd_accounts_user_property_info_login_history,
+  &_gsd_accounts_user_property_info_icon_file,
+  &_gsd_accounts_user_property_info_locked,
+  &_gsd_accounts_user_property_info_password_mode,
+  &_gsd_accounts_user_property_info_password_hint,
+  &_gsd_accounts_user_property_info_automatic_login,
+  &_gsd_accounts_user_property_info_system_account,
+  &_gsd_accounts_user_property_info_local_account,
+  NULL
+};
+
+static const _ExtendedGDBusInterfaceInfo _gsd_accounts_user_interface_info =
+{
+  {
+    -1,
+    (gchar *) "org.freedesktop.Accounts.User",
+    (GDBusMethodInfo **) &_gsd_accounts_user_method_info_pointers,
+    (GDBusSignalInfo **) &_gsd_accounts_user_signal_info_pointers,
+    (GDBusPropertyInfo **) &_gsd_accounts_user_property_info_pointers,
+    NULL
+  },
+  "accounts-user",
+};
+
+
+/**
+ * gsd_accounts_user_interface_info:
+ *
+ * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-Accounts-User.top_of_page">org.freedesktop.Accounts.User</link> D-Bus interface.
+ *
+ * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
+ */
+GDBusInterfaceInfo *
+gsd_accounts_user_interface_info (void)
+{
+  return (GDBusInterfaceInfo *) &_gsd_accounts_user_interface_info.parent_struct;
+}
+
+/**
+ * gsd_accounts_user_override_properties:
+ * @klass: The class structure for a #GObject<!-- -->-derived class.
+ * @property_id_begin: The property id to assign to the first overridden property.
+ *
+ * Overrides all #GObject properties in the #GsdAccountsUser interface for a concrete class.
+ * The properties are overridden in the order they are defined.
+ *
+ * Returns: The last property id.
+ */
+guint
+gsd_accounts_user_override_properties (GObjectClass *klass, guint property_id_begin)
+{
+  g_object_class_override_property (klass, property_id_begin++, "uid");
+  g_object_class_override_property (klass, property_id_begin++, "user-name");
+  g_object_class_override_property (klass, property_id_begin++, "real-name");
+  g_object_class_override_property (klass, property_id_begin++, "account-type");
+  g_object_class_override_property (klass, property_id_begin++, "home-directory");
+  g_object_class_override_property (klass, property_id_begin++, "shell");
+  g_object_class_override_property (klass, property_id_begin++, "email");
+  g_object_class_override_property (klass, property_id_begin++, "language");
+  g_object_class_override_property (klass, property_id_begin++, "xsession");
+  g_object_class_override_property (klass, property_id_begin++, "location");
+  g_object_class_override_property (klass, property_id_begin++, "login-frequency");
+  g_object_class_override_property (klass, property_id_begin++, "login-time");
+  g_object_class_override_property (klass, property_id_begin++, "login-history");
+  g_object_class_override_property (klass, property_id_begin++, "icon-file");
+  g_object_class_override_property (klass, property_id_begin++, "locked");
+  g_object_class_override_property (klass, property_id_begin++, "password-mode");
+  g_object_class_override_property (klass, property_id_begin++, "password-hint");
+  g_object_class_override_property (klass, property_id_begin++, "automatic-login");
+  g_object_class_override_property (klass, property_id_begin++, "system-account");
+  g_object_class_override_property (klass, property_id_begin++, "local-account");
+  return property_id_begin - 1;
+}
+
+
+
+/**
+ * GsdAccountsUser:
+ *
+ * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-Accounts-User.top_of_page">org.freedesktop.Accounts.User</link>.
+ */
+
+/**
+ * GsdAccountsUserIface:
+ * @parent_iface: The parent interface.
+ * @handle_get_password_expiration_policy: Handler for the #GsdAccountsUser::handle-get-password-expiration-policy signal.
+ * @handle_set_account_type: Handler for the #GsdAccountsUser::handle-set-account-type signal.
+ * @handle_set_automatic_login: Handler for the #GsdAccountsUser::handle-set-automatic-login signal.
+ * @handle_set_email: Handler for the #GsdAccountsUser::handle-set-email signal.
+ * @handle_set_home_directory: Handler for the #GsdAccountsUser::handle-set-home-directory signal.
+ * @handle_set_icon_file: Handler for the #GsdAccountsUser::handle-set-icon-file signal.
+ * @handle_set_language: Handler for the #GsdAccountsUser::handle-set-language signal.
+ * @handle_set_location: Handler for the #GsdAccountsUser::handle-set-location signal.
+ * @handle_set_locked: Handler for the #GsdAccountsUser::handle-set-locked signal.
+ * @handle_set_password: Handler for the #GsdAccountsUser::handle-set-password signal.
+ * @handle_set_password_hint: Handler for the #GsdAccountsUser::handle-set-password-hint signal.
+ * @handle_set_password_mode: Handler for the #GsdAccountsUser::handle-set-password-mode signal.
+ * @handle_set_real_name: Handler for the #GsdAccountsUser::handle-set-real-name signal.
+ * @handle_set_shell: Handler for the #GsdAccountsUser::handle-set-shell signal.
+ * @handle_set_user_name: Handler for the #GsdAccountsUser::handle-set-user-name signal.
+ * @handle_set_xsession: Handler for the #GsdAccountsUser::handle-set-xsession signal.
+ * @get_account_type: Getter for the #GsdAccountsUser:account-type property.
+ * @get_automatic_login: Getter for the #GsdAccountsUser:automatic-login property.
+ * @get_email: Getter for the #GsdAccountsUser:email property.
+ * @get_home_directory: Getter for the #GsdAccountsUser:home-directory property.
+ * @get_icon_file: Getter for the #GsdAccountsUser:icon-file property.
+ * @get_language: Getter for the #GsdAccountsUser:language property.
+ * @get_local_account: Getter for the #GsdAccountsUser:local-account property.
+ * @get_location: Getter for the #GsdAccountsUser:location property.
+ * @get_locked: Getter for the #GsdAccountsUser:locked property.
+ * @get_login_frequency: Getter for the #GsdAccountsUser:login-frequency property.
+ * @get_login_history: Getter for the #GsdAccountsUser:login-history property.
+ * @get_login_time: Getter for the #GsdAccountsUser:login-time property.
+ * @get_password_hint: Getter for the #GsdAccountsUser:password-hint property.
+ * @get_password_mode: Getter for the #GsdAccountsUser:password-mode property.
+ * @get_real_name: Getter for the #GsdAccountsUser:real-name property.
+ * @get_shell: Getter for the #GsdAccountsUser:shell property.
+ * @get_system_account: Getter for the #GsdAccountsUser:system-account property.
+ * @get_uid: Getter for the #GsdAccountsUser:uid property.
+ * @get_user_name: Getter for the #GsdAccountsUser:user-name property.
+ * @get_xsession: Getter for the #GsdAccountsUser:xsession property.
+ * @changed: Handler for the #GsdAccountsUser::changed signal.
+ *
+ * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-Accounts-User.top_of_page">org.freedesktop.Accounts.User</link>.
+ */
+
+typedef GsdAccountsUserIface GsdAccountsUserInterface;
+G_DEFINE_INTERFACE (GsdAccountsUser, gsd_accounts_user, G_TYPE_OBJECT)
+
+static void
+gsd_accounts_user_default_init (GsdAccountsUserIface *iface)
+{
+  /* GObject signals for incoming D-Bus method calls: */
+  /**
+   * GsdAccountsUser::handle-set-user-name:
+   * @object: A #GsdAccountsUser.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_name: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetUserName">SetUserName()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call gsd_accounts_user_complete_set_user_name() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-set-user-name",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GsdAccountsUserIface, handle_set_user_name),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);
+
+  /**
+   * GsdAccountsUser::handle-set-real-name:
+   * @object: A #GsdAccountsUser.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_name: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetRealName">SetRealName()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call gsd_accounts_user_complete_set_real_name() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-set-real-name",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GsdAccountsUserIface, handle_set_real_name),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);
+
+  /**
+   * GsdAccountsUser::handle-set-email:
+   * @object: A #GsdAccountsUser.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_email: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetEmail">SetEmail()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call gsd_accounts_user_complete_set_email() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-set-email",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GsdAccountsUserIface, handle_set_email),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);
+
+  /**
+   * GsdAccountsUser::handle-set-language:
+   * @object: A #GsdAccountsUser.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_language: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetLanguage">SetLanguage()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call gsd_accounts_user_complete_set_language() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-set-language",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GsdAccountsUserIface, handle_set_language),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);
+
+  /**
+   * GsdAccountsUser::handle-set-xsession:
+   * @object: A #GsdAccountsUser.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_x_session: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetXSession">SetXSession()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call gsd_accounts_user_complete_set_xsession() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-set-xsession",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GsdAccountsUserIface, handle_set_xsession),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);
+
+  /**
+   * GsdAccountsUser::handle-set-location:
+   * @object: A #GsdAccountsUser.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_location: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetLocation">SetLocation()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call gsd_accounts_user_complete_set_location() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-set-location",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GsdAccountsUserIface, handle_set_location),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);
+
+  /**
+   * GsdAccountsUser::handle-set-home-directory:
+   * @object: A #GsdAccountsUser.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_homedir: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetHomeDirectory">SetHomeDirectory()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call gsd_accounts_user_complete_set_home_directory() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-set-home-directory",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GsdAccountsUserIface, handle_set_home_directory),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);
+
+  /**
+   * GsdAccountsUser::handle-set-shell:
+   * @object: A #GsdAccountsUser.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_shell: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetShell">SetShell()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call gsd_accounts_user_complete_set_shell() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-set-shell",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GsdAccountsUserIface, handle_set_shell),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);
+
+  /**
+   * GsdAccountsUser::handle-set-icon-file:
+   * @object: A #GsdAccountsUser.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_filename: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetIconFile">SetIconFile()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call gsd_accounts_user_complete_set_icon_file() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-set-icon-file",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GsdAccountsUserIface, handle_set_icon_file),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);
+
+  /**
+   * GsdAccountsUser::handle-set-locked:
+   * @object: A #GsdAccountsUser.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_locked: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetLocked">SetLocked()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call gsd_accounts_user_complete_set_locked() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-set-locked",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GsdAccountsUserIface, handle_set_locked),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_BOOLEAN);
+
+  /**
+   * GsdAccountsUser::handle-set-account-type:
+   * @object: A #GsdAccountsUser.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_accountType: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetAccountType">SetAccountType()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call gsd_accounts_user_complete_set_account_type() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-set-account-type",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GsdAccountsUserIface, handle_set_account_type),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_INT);
+
+  /**
+   * GsdAccountsUser::handle-set-password-mode:
+   * @object: A #GsdAccountsUser.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_mode: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetPasswordMode">SetPasswordMode()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call gsd_accounts_user_complete_set_password_mode() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-set-password-mode",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GsdAccountsUserIface, handle_set_password_mode),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_INT);
+
+  /**
+   * GsdAccountsUser::handle-set-password:
+   * @object: A #GsdAccountsUser.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_password: Argument passed by remote caller.
+   * @arg_hint: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetPassword">SetPassword()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call gsd_accounts_user_complete_set_password() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-set-password",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GsdAccountsUserIface, handle_set_password),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    3,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING, G_TYPE_STRING);
+
+  /**
+   * GsdAccountsUser::handle-set-password-hint:
+   * @object: A #GsdAccountsUser.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_hint: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetPasswordHint">SetPasswordHint()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call gsd_accounts_user_complete_set_password_hint() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-set-password-hint",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GsdAccountsUserIface, handle_set_password_hint),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);
+
+  /**
+   * GsdAccountsUser::handle-set-automatic-login:
+   * @object: A #GsdAccountsUser.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_enabled: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetAutomaticLogin">SetAutomaticLogin()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call gsd_accounts_user_complete_set_automatic_login() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-set-automatic-login",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GsdAccountsUserIface, handle_set_automatic_login),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_BOOLEAN);
+
+  /**
+   * GsdAccountsUser::handle-get-password-expiration-policy:
+   * @object: A #GsdAccountsUser.
+   * @invocation: A #GDBusMethodInvocation.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-Accounts-User.GetPasswordExpirationPolicy">GetPasswordExpirationPolicy()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call gsd_accounts_user_complete_get_password_expiration_policy() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-get-password-expiration-policy",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GsdAccountsUserIface, handle_get_password_expiration_policy),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    1,
+    G_TYPE_DBUS_METHOD_INVOCATION);
+
+  /* GObject signals for received D-Bus signals: */
+  /**
+   * GsdAccountsUser::changed:
+   * @object: A #GsdAccountsUser.
+   *
+   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-freedesktop-Accounts-User.Changed">"Changed"</link> is received.
+   *
+   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
+   */
+  g_signal_new ("changed",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GsdAccountsUserIface, changed),
+    NULL,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_NONE,
+    0);
+
+  /* GObject properties for D-Bus properties: */
+  /**
+   * GsdAccountsUser:uid:
+   *
+   * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-Accounts-User.Uid">"Uid"</link>.
+   *
+   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
+   */
+  g_object_interface_install_property (iface,
+    g_param_spec_uint64 ("uid", "Uid", "Uid", 0, G_MAXUINT64, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  /**
+   * GsdAccountsUser:user-name:
+   *
+   * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-Accounts-User.UserName">"UserName"</link>.
+   *
+   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
+   */
+  g_object_interface_install_property (iface,
+    g_param_spec_string ("user-name", "UserName", "UserName", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  /**
+   * GsdAccountsUser:real-name:
+   *
+   * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-Accounts-User.RealName">"RealName"</link>.
+   *
+   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
+   */
+  g_object_interface_install_property (iface,
+    g_param_spec_string ("real-name", "RealName", "RealName", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  /**
+   * GsdAccountsUser:account-type:
+   *
+   * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-Accounts-User.AccountType">"AccountType"</link>.
+   *
+   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
+   */
+  g_object_interface_install_property (iface,
+    g_param_spec_int ("account-type", "AccountType", "AccountType", G_MININT32, G_MAXINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  /**
+   * GsdAccountsUser:home-directory:
+   *
+   * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-Accounts-User.HomeDirectory">"HomeDirectory"</link>.
+   *
+   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
+   */
+  g_object_interface_install_property (iface,
+    g_param_spec_string ("home-directory", "HomeDirectory", "HomeDirectory", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  /**
+   * GsdAccountsUser:shell:
+   *
+   * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-Accounts-User.Shell">"Shell"</link>.
+   *
+   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
+   */
+  g_object_interface_install_property (iface,
+    g_param_spec_string ("shell", "Shell", "Shell", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  /**
+   * GsdAccountsUser:email:
+   *
+   * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-Accounts-User.Email">"Email"</link>.
+   *
+   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
+   */
+  g_object_interface_install_property (iface,
+    g_param_spec_string ("email", "Email", "Email", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  /**
+   * GsdAccountsUser:language:
+   *
+   * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-Accounts-User.Language">"Language"</link>.
+   *
+   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
+   */
+  g_object_interface_install_property (iface,
+    g_param_spec_string ("language", "Language", "Language", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  /**
+   * GsdAccountsUser:xsession:
+   *
+   * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-Accounts-User.XSession">"XSession"</link>.
+   *
+   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
+   */
+  g_object_interface_install_property (iface,
+    g_param_spec_string ("xsession", "XSession", "XSession", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  /**
+   * GsdAccountsUser:location:
+   *
+   * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-Accounts-User.Location">"Location"</link>.
+   *
+   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
+   */
+  g_object_interface_install_property (iface,
+    g_param_spec_string ("location", "Location", "Location", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  /**
+   * GsdAccountsUser:login-frequency:
+   *
+   * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-Accounts-User.LoginFrequency">"LoginFrequency"</link>.
+   *
+   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
+   */
+  g_object_interface_install_property (iface,
+    g_param_spec_uint64 ("login-frequency", "LoginFrequency", "LoginFrequency", 0, G_MAXUINT64, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  /**
+   * GsdAccountsUser:login-time:
+   *
+   * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-Accounts-User.LoginTime">"LoginTime"</link>.
+   *
+   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
+   */
+  g_object_interface_install_property (iface,
+    g_param_spec_int64 ("login-time", "LoginTime", "LoginTime", G_MININT64, G_MAXINT64, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  /**
+   * GsdAccountsUser:login-history:
+   *
+   * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-Accounts-User.LoginHistory">"LoginHistory"</link>.
+   *
+   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
+   */
+  g_object_interface_install_property (iface,
+    g_param_spec_variant ("login-history", "LoginHistory", "LoginHistory", G_VARIANT_TYPE ("a(xxa{sv})"), NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  /**
+   * GsdAccountsUser:icon-file:
+   *
+   * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-Accounts-User.IconFile">"IconFile"</link>.
+   *
+   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
+   */
+  g_object_interface_install_property (iface,
+    g_param_spec_string ("icon-file", "IconFile", "IconFile", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  /**
+   * GsdAccountsUser:locked:
+   *
+   * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-Accounts-User.Locked">"Locked"</link>.
+   *
+   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
+   */
+  g_object_interface_install_property (iface,
+    g_param_spec_boolean ("locked", "Locked", "Locked", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  /**
+   * GsdAccountsUser:password-mode:
+   *
+   * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-Accounts-User.PasswordMode">"PasswordMode"</link>.
+   *
+   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
+   */
+  g_object_interface_install_property (iface,
+    g_param_spec_int ("password-mode", "PasswordMode", "PasswordMode", G_MININT32, G_MAXINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  /**
+   * GsdAccountsUser:password-hint:
+   *
+   * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-Accounts-User.PasswordHint">"PasswordHint"</link>.
+   *
+   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
+   */
+  g_object_interface_install_property (iface,
+    g_param_spec_string ("password-hint", "PasswordHint", "PasswordHint", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  /**
+   * GsdAccountsUser:automatic-login:
+   *
+   * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-Accounts-User.AutomaticLogin">"AutomaticLogin"</link>.
+   *
+   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
+   */
+  g_object_interface_install_property (iface,
+    g_param_spec_boolean ("automatic-login", "AutomaticLogin", "AutomaticLogin", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  /**
+   * GsdAccountsUser:system-account:
+   *
+   * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-Accounts-User.SystemAccount">"SystemAccount"</link>.
+   *
+   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
+   */
+  g_object_interface_install_property (iface,
+    g_param_spec_boolean ("system-account", "SystemAccount", "SystemAccount", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  /**
+   * GsdAccountsUser:local-account:
+   *
+   * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-Accounts-User.LocalAccount">"LocalAccount"</link>.
+   *
+   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
+   */
+  g_object_interface_install_property (iface,
+    g_param_spec_boolean ("local-account", "LocalAccount", "LocalAccount", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+}
+
+/**
+ * gsd_accounts_user_get_uid: (skip)
+ * @object: A #GsdAccountsUser.
+ *
+ * Gets the value of the <link linkend="gdbus-property-org-freedesktop-Accounts-User.Uid">"Uid"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * Returns: The property value.
+ */
+guint64
+gsd_accounts_user_get_uid (GsdAccountsUser *object)
+{
+  return GSD_ACCOUNTS_USER_GET_IFACE (object)->get_uid (object);
+}
+
+/**
+ * gsd_accounts_user_set_uid: (skip)
+ * @object: A #GsdAccountsUser.
+ * @value: The value to set.
+ *
+ * Sets the <link linkend="gdbus-property-org-freedesktop-Accounts-User.Uid">"Uid"</link> D-Bus property to @value.
+ *
+ * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
+ */
+void
+gsd_accounts_user_set_uid (GsdAccountsUser *object, guint64 value)
+{
+  g_object_set (G_OBJECT (object), "uid", value, NULL);
+}
+
+/**
+ * gsd_accounts_user_get_user_name: (skip)
+ * @object: A #GsdAccountsUser.
+ *
+ * Gets the value of the <link linkend="gdbus-property-org-freedesktop-Accounts-User.UserName">"UserName"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use gsd_accounts_user_dup_user_name() if on another thread.</warning>
+ *
+ * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
+ */
+const gchar *
+gsd_accounts_user_get_user_name (GsdAccountsUser *object)
+{
+  return GSD_ACCOUNTS_USER_GET_IFACE (object)->get_user_name (object);
+}
+
+/**
+ * gsd_accounts_user_dup_user_name: (skip)
+ * @object: A #GsdAccountsUser.
+ *
+ * Gets a copy of the <link linkend="gdbus-property-org-freedesktop-Accounts-User.UserName">"UserName"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
+ */
+gchar *
+gsd_accounts_user_dup_user_name (GsdAccountsUser *object)
+{
+  gchar *value;
+  g_object_get (G_OBJECT (object), "user-name", &value, NULL);
+  return value;
+}
+
+/**
+ * gsd_accounts_user_set_user_name: (skip)
+ * @object: A #GsdAccountsUser.
+ * @value: The value to set.
+ *
+ * Sets the <link linkend="gdbus-property-org-freedesktop-Accounts-User.UserName">"UserName"</link> D-Bus property to @value.
+ *
+ * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
+ */
+void
+gsd_accounts_user_set_user_name (GsdAccountsUser *object, const gchar *value)
+{
+  g_object_set (G_OBJECT (object), "user-name", value, NULL);
+}
+
+/**
+ * gsd_accounts_user_get_real_name: (skip)
+ * @object: A #GsdAccountsUser.
+ *
+ * Gets the value of the <link linkend="gdbus-property-org-freedesktop-Accounts-User.RealName">"RealName"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use gsd_accounts_user_dup_real_name() if on another thread.</warning>
+ *
+ * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
+ */
+const gchar *
+gsd_accounts_user_get_real_name (GsdAccountsUser *object)
+{
+  return GSD_ACCOUNTS_USER_GET_IFACE (object)->get_real_name (object);
+}
+
+/**
+ * gsd_accounts_user_dup_real_name: (skip)
+ * @object: A #GsdAccountsUser.
+ *
+ * Gets a copy of the <link linkend="gdbus-property-org-freedesktop-Accounts-User.RealName">"RealName"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
+ */
+gchar *
+gsd_accounts_user_dup_real_name (GsdAccountsUser *object)
+{
+  gchar *value;
+  g_object_get (G_OBJECT (object), "real-name", &value, NULL);
+  return value;
+}
+
+/**
+ * gsd_accounts_user_set_real_name: (skip)
+ * @object: A #GsdAccountsUser.
+ * @value: The value to set.
+ *
+ * Sets the <link linkend="gdbus-property-org-freedesktop-Accounts-User.RealName">"RealName"</link> D-Bus property to @value.
+ *
+ * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
+ */
+void
+gsd_accounts_user_set_real_name (GsdAccountsUser *object, const gchar *value)
+{
+  g_object_set (G_OBJECT (object), "real-name", value, NULL);
+}
+
+/**
+ * gsd_accounts_user_get_account_type: (skip)
+ * @object: A #GsdAccountsUser.
+ *
+ * Gets the value of the <link linkend="gdbus-property-org-freedesktop-Accounts-User.AccountType">"AccountType"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * Returns: The property value.
+ */
+gint
+gsd_accounts_user_get_account_type (GsdAccountsUser *object)
+{
+  return GSD_ACCOUNTS_USER_GET_IFACE (object)->get_account_type (object);
+}
+
+/**
+ * gsd_accounts_user_set_account_type: (skip)
+ * @object: A #GsdAccountsUser.
+ * @value: The value to set.
+ *
+ * Sets the <link linkend="gdbus-property-org-freedesktop-Accounts-User.AccountType">"AccountType"</link> D-Bus property to @value.
+ *
+ * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
+ */
+void
+gsd_accounts_user_set_account_type (GsdAccountsUser *object, gint value)
+{
+  g_object_set (G_OBJECT (object), "account-type", value, NULL);
+}
+
+/**
+ * gsd_accounts_user_get_home_directory: (skip)
+ * @object: A #GsdAccountsUser.
+ *
+ * Gets the value of the <link linkend="gdbus-property-org-freedesktop-Accounts-User.HomeDirectory">"HomeDirectory"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use gsd_accounts_user_dup_home_directory() if on another thread.</warning>
+ *
+ * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
+ */
+const gchar *
+gsd_accounts_user_get_home_directory (GsdAccountsUser *object)
+{
+  return GSD_ACCOUNTS_USER_GET_IFACE (object)->get_home_directory (object);
+}
+
+/**
+ * gsd_accounts_user_dup_home_directory: (skip)
+ * @object: A #GsdAccountsUser.
+ *
+ * Gets a copy of the <link linkend="gdbus-property-org-freedesktop-Accounts-User.HomeDirectory">"HomeDirectory"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
+ */
+gchar *
+gsd_accounts_user_dup_home_directory (GsdAccountsUser *object)
+{
+  gchar *value;
+  g_object_get (G_OBJECT (object), "home-directory", &value, NULL);
+  return value;
+}
+
+/**
+ * gsd_accounts_user_set_home_directory: (skip)
+ * @object: A #GsdAccountsUser.
+ * @value: The value to set.
+ *
+ * Sets the <link linkend="gdbus-property-org-freedesktop-Accounts-User.HomeDirectory">"HomeDirectory"</link> D-Bus property to @value.
+ *
+ * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
+ */
+void
+gsd_accounts_user_set_home_directory (GsdAccountsUser *object, const gchar *value)
+{
+  g_object_set (G_OBJECT (object), "home-directory", value, NULL);
+}
+
+/**
+ * gsd_accounts_user_get_shell: (skip)
+ * @object: A #GsdAccountsUser.
+ *
+ * Gets the value of the <link linkend="gdbus-property-org-freedesktop-Accounts-User.Shell">"Shell"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use gsd_accounts_user_dup_shell() if on another thread.</warning>
+ *
+ * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
+ */
+const gchar *
+gsd_accounts_user_get_shell (GsdAccountsUser *object)
+{
+  return GSD_ACCOUNTS_USER_GET_IFACE (object)->get_shell (object);
+}
+
+/**
+ * gsd_accounts_user_dup_shell: (skip)
+ * @object: A #GsdAccountsUser.
+ *
+ * Gets a copy of the <link linkend="gdbus-property-org-freedesktop-Accounts-User.Shell">"Shell"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
+ */
+gchar *
+gsd_accounts_user_dup_shell (GsdAccountsUser *object)
+{
+  gchar *value;
+  g_object_get (G_OBJECT (object), "shell", &value, NULL);
+  return value;
+}
+
+/**
+ * gsd_accounts_user_set_shell: (skip)
+ * @object: A #GsdAccountsUser.
+ * @value: The value to set.
+ *
+ * Sets the <link linkend="gdbus-property-org-freedesktop-Accounts-User.Shell">"Shell"</link> D-Bus property to @value.
+ *
+ * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
+ */
+void
+gsd_accounts_user_set_shell (GsdAccountsUser *object, const gchar *value)
+{
+  g_object_set (G_OBJECT (object), "shell", value, NULL);
+}
+
+/**
+ * gsd_accounts_user_get_email: (skip)
+ * @object: A #GsdAccountsUser.
+ *
+ * Gets the value of the <link linkend="gdbus-property-org-freedesktop-Accounts-User.Email">"Email"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use gsd_accounts_user_dup_email() if on another thread.</warning>
+ *
+ * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
+ */
+const gchar *
+gsd_accounts_user_get_email (GsdAccountsUser *object)
+{
+  return GSD_ACCOUNTS_USER_GET_IFACE (object)->get_email (object);
+}
+
+/**
+ * gsd_accounts_user_dup_email: (skip)
+ * @object: A #GsdAccountsUser.
+ *
+ * Gets a copy of the <link linkend="gdbus-property-org-freedesktop-Accounts-User.Email">"Email"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
+ */
+gchar *
+gsd_accounts_user_dup_email (GsdAccountsUser *object)
+{
+  gchar *value;
+  g_object_get (G_OBJECT (object), "email", &value, NULL);
+  return value;
+}
+
+/**
+ * gsd_accounts_user_set_email: (skip)
+ * @object: A #GsdAccountsUser.
+ * @value: The value to set.
+ *
+ * Sets the <link linkend="gdbus-property-org-freedesktop-Accounts-User.Email">"Email"</link> D-Bus property to @value.
+ *
+ * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
+ */
+void
+gsd_accounts_user_set_email (GsdAccountsUser *object, const gchar *value)
+{
+  g_object_set (G_OBJECT (object), "email", value, NULL);
+}
+
+/**
+ * gsd_accounts_user_get_language: (skip)
+ * @object: A #GsdAccountsUser.
+ *
+ * Gets the value of the <link linkend="gdbus-property-org-freedesktop-Accounts-User.Language">"Language"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use gsd_accounts_user_dup_language() if on another thread.</warning>
+ *
+ * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
+ */
+const gchar *
+gsd_accounts_user_get_language (GsdAccountsUser *object)
+{
+  return GSD_ACCOUNTS_USER_GET_IFACE (object)->get_language (object);
+}
+
+/**
+ * gsd_accounts_user_dup_language: (skip)
+ * @object: A #GsdAccountsUser.
+ *
+ * Gets a copy of the <link linkend="gdbus-property-org-freedesktop-Accounts-User.Language">"Language"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
+ */
+gchar *
+gsd_accounts_user_dup_language (GsdAccountsUser *object)
+{
+  gchar *value;
+  g_object_get (G_OBJECT (object), "language", &value, NULL);
+  return value;
+}
+
+/**
+ * gsd_accounts_user_set_language: (skip)
+ * @object: A #GsdAccountsUser.
+ * @value: The value to set.
+ *
+ * Sets the <link linkend="gdbus-property-org-freedesktop-Accounts-User.Language">"Language"</link> D-Bus property to @value.
+ *
+ * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
+ */
+void
+gsd_accounts_user_set_language (GsdAccountsUser *object, const gchar *value)
+{
+  g_object_set (G_OBJECT (object), "language", value, NULL);
+}
+
+/**
+ * gsd_accounts_user_get_xsession: (skip)
+ * @object: A #GsdAccountsUser.
+ *
+ * Gets the value of the <link linkend="gdbus-property-org-freedesktop-Accounts-User.XSession">"XSession"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use gsd_accounts_user_dup_xsession() if on another thread.</warning>
+ *
+ * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
+ */
+const gchar *
+gsd_accounts_user_get_xsession (GsdAccountsUser *object)
+{
+  return GSD_ACCOUNTS_USER_GET_IFACE (object)->get_xsession (object);
+}
+
+/**
+ * gsd_accounts_user_dup_xsession: (skip)
+ * @object: A #GsdAccountsUser.
+ *
+ * Gets a copy of the <link linkend="gdbus-property-org-freedesktop-Accounts-User.XSession">"XSession"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
+ */
+gchar *
+gsd_accounts_user_dup_xsession (GsdAccountsUser *object)
+{
+  gchar *value;
+  g_object_get (G_OBJECT (object), "xsession", &value, NULL);
+  return value;
+}
+
+/**
+ * gsd_accounts_user_set_xsession: (skip)
+ * @object: A #GsdAccountsUser.
+ * @value: The value to set.
+ *
+ * Sets the <link linkend="gdbus-property-org-freedesktop-Accounts-User.XSession">"XSession"</link> D-Bus property to @value.
+ *
+ * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
+ */
+void
+gsd_accounts_user_set_xsession (GsdAccountsUser *object, const gchar *value)
+{
+  g_object_set (G_OBJECT (object), "xsession", value, NULL);
+}
+
+/**
+ * gsd_accounts_user_get_location: (skip)
+ * @object: A #GsdAccountsUser.
+ *
+ * Gets the value of the <link linkend="gdbus-property-org-freedesktop-Accounts-User.Location">"Location"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use gsd_accounts_user_dup_location() if on another thread.</warning>
+ *
+ * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
+ */
+const gchar *
+gsd_accounts_user_get_location (GsdAccountsUser *object)
+{
+  return GSD_ACCOUNTS_USER_GET_IFACE (object)->get_location (object);
+}
+
+/**
+ * gsd_accounts_user_dup_location: (skip)
+ * @object: A #GsdAccountsUser.
+ *
+ * Gets a copy of the <link linkend="gdbus-property-org-freedesktop-Accounts-User.Location">"Location"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
+ */
+gchar *
+gsd_accounts_user_dup_location (GsdAccountsUser *object)
+{
+  gchar *value;
+  g_object_get (G_OBJECT (object), "location", &value, NULL);
+  return value;
+}
+
+/**
+ * gsd_accounts_user_set_location: (skip)
+ * @object: A #GsdAccountsUser.
+ * @value: The value to set.
+ *
+ * Sets the <link linkend="gdbus-property-org-freedesktop-Accounts-User.Location">"Location"</link> D-Bus property to @value.
+ *
+ * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
+ */
+void
+gsd_accounts_user_set_location (GsdAccountsUser *object, const gchar *value)
+{
+  g_object_set (G_OBJECT (object), "location", value, NULL);
+}
+
+/**
+ * gsd_accounts_user_get_login_frequency: (skip)
+ * @object: A #GsdAccountsUser.
+ *
+ * Gets the value of the <link linkend="gdbus-property-org-freedesktop-Accounts-User.LoginFrequency">"LoginFrequency"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * Returns: The property value.
+ */
+guint64
+gsd_accounts_user_get_login_frequency (GsdAccountsUser *object)
+{
+  return GSD_ACCOUNTS_USER_GET_IFACE (object)->get_login_frequency (object);
+}
+
+/**
+ * gsd_accounts_user_set_login_frequency: (skip)
+ * @object: A #GsdAccountsUser.
+ * @value: The value to set.
+ *
+ * Sets the <link linkend="gdbus-property-org-freedesktop-Accounts-User.LoginFrequency">"LoginFrequency"</link> D-Bus property to @value.
+ *
+ * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
+ */
+void
+gsd_accounts_user_set_login_frequency (GsdAccountsUser *object, guint64 value)
+{
+  g_object_set (G_OBJECT (object), "login-frequency", value, NULL);
+}
+
+/**
+ * gsd_accounts_user_get_login_time: (skip)
+ * @object: A #GsdAccountsUser.
+ *
+ * Gets the value of the <link linkend="gdbus-property-org-freedesktop-Accounts-User.LoginTime">"LoginTime"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * Returns: The property value.
+ */
+gint64
+gsd_accounts_user_get_login_time (GsdAccountsUser *object)
+{
+  return GSD_ACCOUNTS_USER_GET_IFACE (object)->get_login_time (object);
+}
+
+/**
+ * gsd_accounts_user_set_login_time: (skip)
+ * @object: A #GsdAccountsUser.
+ * @value: The value to set.
+ *
+ * Sets the <link linkend="gdbus-property-org-freedesktop-Accounts-User.LoginTime">"LoginTime"</link> D-Bus property to @value.
+ *
+ * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
+ */
+void
+gsd_accounts_user_set_login_time (GsdAccountsUser *object, gint64 value)
+{
+  g_object_set (G_OBJECT (object), "login-time", value, NULL);
+}
+
+/**
+ * gsd_accounts_user_get_login_history: (skip)
+ * @object: A #GsdAccountsUser.
+ *
+ * Gets the value of the <link linkend="gdbus-property-org-freedesktop-Accounts-User.LoginHistory">"LoginHistory"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use gsd_accounts_user_dup_login_history() if on another thread.</warning>
+ *
+ * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
+ */
+GVariant *
+gsd_accounts_user_get_login_history (GsdAccountsUser *object)
+{
+  return GSD_ACCOUNTS_USER_GET_IFACE (object)->get_login_history (object);
+}
+
+/**
+ * gsd_accounts_user_dup_login_history: (skip)
+ * @object: A #GsdAccountsUser.
+ *
+ * Gets a copy of the <link linkend="gdbus-property-org-freedesktop-Accounts-User.LoginHistory">"LoginHistory"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_variant_unref().
+ */
+GVariant *
+gsd_accounts_user_dup_login_history (GsdAccountsUser *object)
+{
+  GVariant *value;
+  g_object_get (G_OBJECT (object), "login-history", &value, NULL);
+  return value;
+}
+
+/**
+ * gsd_accounts_user_set_login_history: (skip)
+ * @object: A #GsdAccountsUser.
+ * @value: The value to set.
+ *
+ * Sets the <link linkend="gdbus-property-org-freedesktop-Accounts-User.LoginHistory">"LoginHistory"</link> D-Bus property to @value.
+ *
+ * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
+ */
+void
+gsd_accounts_user_set_login_history (GsdAccountsUser *object, GVariant *value)
+{
+  g_object_set (G_OBJECT (object), "login-history", value, NULL);
+}
+
+/**
+ * gsd_accounts_user_get_icon_file: (skip)
+ * @object: A #GsdAccountsUser.
+ *
+ * Gets the value of the <link linkend="gdbus-property-org-freedesktop-Accounts-User.IconFile">"IconFile"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use gsd_accounts_user_dup_icon_file() if on another thread.</warning>
+ *
+ * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
+ */
+const gchar *
+gsd_accounts_user_get_icon_file (GsdAccountsUser *object)
+{
+  return GSD_ACCOUNTS_USER_GET_IFACE (object)->get_icon_file (object);
+}
+
+/**
+ * gsd_accounts_user_dup_icon_file: (skip)
+ * @object: A #GsdAccountsUser.
+ *
+ * Gets a copy of the <link linkend="gdbus-property-org-freedesktop-Accounts-User.IconFile">"IconFile"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
+ */
+gchar *
+gsd_accounts_user_dup_icon_file (GsdAccountsUser *object)
+{
+  gchar *value;
+  g_object_get (G_OBJECT (object), "icon-file", &value, NULL);
+  return value;
+}
+
+/**
+ * gsd_accounts_user_set_icon_file: (skip)
+ * @object: A #GsdAccountsUser.
+ * @value: The value to set.
+ *
+ * Sets the <link linkend="gdbus-property-org-freedesktop-Accounts-User.IconFile">"IconFile"</link> D-Bus property to @value.
+ *
+ * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
+ */
+void
+gsd_accounts_user_set_icon_file (GsdAccountsUser *object, const gchar *value)
+{
+  g_object_set (G_OBJECT (object), "icon-file", value, NULL);
+}
+
+/**
+ * gsd_accounts_user_get_locked: (skip)
+ * @object: A #GsdAccountsUser.
+ *
+ * Gets the value of the <link linkend="gdbus-property-org-freedesktop-Accounts-User.Locked">"Locked"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * Returns: The property value.
+ */
+gboolean
+gsd_accounts_user_get_locked (GsdAccountsUser *object)
+{
+  return GSD_ACCOUNTS_USER_GET_IFACE (object)->get_locked (object);
+}
+
+/**
+ * gsd_accounts_user_set_locked: (skip)
+ * @object: A #GsdAccountsUser.
+ * @value: The value to set.
+ *
+ * Sets the <link linkend="gdbus-property-org-freedesktop-Accounts-User.Locked">"Locked"</link> D-Bus property to @value.
+ *
+ * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
+ */
+void
+gsd_accounts_user_set_locked (GsdAccountsUser *object, gboolean value)
+{
+  g_object_set (G_OBJECT (object), "locked", value, NULL);
+}
+
+/**
+ * gsd_accounts_user_get_password_mode: (skip)
+ * @object: A #GsdAccountsUser.
+ *
+ * Gets the value of the <link linkend="gdbus-property-org-freedesktop-Accounts-User.PasswordMode">"PasswordMode"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * Returns: The property value.
+ */
+gint
+gsd_accounts_user_get_password_mode (GsdAccountsUser *object)
+{
+  return GSD_ACCOUNTS_USER_GET_IFACE (object)->get_password_mode (object);
+}
+
+/**
+ * gsd_accounts_user_set_password_mode: (skip)
+ * @object: A #GsdAccountsUser.
+ * @value: The value to set.
+ *
+ * Sets the <link linkend="gdbus-property-org-freedesktop-Accounts-User.PasswordMode">"PasswordMode"</link> D-Bus property to @value.
+ *
+ * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
+ */
+void
+gsd_accounts_user_set_password_mode (GsdAccountsUser *object, gint value)
+{
+  g_object_set (G_OBJECT (object), "password-mode", value, NULL);
+}
+
+/**
+ * gsd_accounts_user_get_password_hint: (skip)
+ * @object: A #GsdAccountsUser.
+ *
+ * Gets the value of the <link linkend="gdbus-property-org-freedesktop-Accounts-User.PasswordHint">"PasswordHint"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use gsd_accounts_user_dup_password_hint() if on another thread.</warning>
+ *
+ * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
+ */
+const gchar *
+gsd_accounts_user_get_password_hint (GsdAccountsUser *object)
+{
+  return GSD_ACCOUNTS_USER_GET_IFACE (object)->get_password_hint (object);
+}
+
+/**
+ * gsd_accounts_user_dup_password_hint: (skip)
+ * @object: A #GsdAccountsUser.
+ *
+ * Gets a copy of the <link linkend="gdbus-property-org-freedesktop-Accounts-User.PasswordHint">"PasswordHint"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
+ */
+gchar *
+gsd_accounts_user_dup_password_hint (GsdAccountsUser *object)
+{
+  gchar *value;
+  g_object_get (G_OBJECT (object), "password-hint", &value, NULL);
+  return value;
+}
+
+/**
+ * gsd_accounts_user_set_password_hint: (skip)
+ * @object: A #GsdAccountsUser.
+ * @value: The value to set.
+ *
+ * Sets the <link linkend="gdbus-property-org-freedesktop-Accounts-User.PasswordHint">"PasswordHint"</link> D-Bus property to @value.
+ *
+ * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
+ */
+void
+gsd_accounts_user_set_password_hint (GsdAccountsUser *object, const gchar *value)
+{
+  g_object_set (G_OBJECT (object), "password-hint", value, NULL);
+}
+
+/**
+ * gsd_accounts_user_get_automatic_login: (skip)
+ * @object: A #GsdAccountsUser.
+ *
+ * Gets the value of the <link linkend="gdbus-property-org-freedesktop-Accounts-User.AutomaticLogin">"AutomaticLogin"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * Returns: The property value.
+ */
+gboolean
+gsd_accounts_user_get_automatic_login (GsdAccountsUser *object)
+{
+  return GSD_ACCOUNTS_USER_GET_IFACE (object)->get_automatic_login (object);
+}
+
+/**
+ * gsd_accounts_user_set_automatic_login: (skip)
+ * @object: A #GsdAccountsUser.
+ * @value: The value to set.
+ *
+ * Sets the <link linkend="gdbus-property-org-freedesktop-Accounts-User.AutomaticLogin">"AutomaticLogin"</link> D-Bus property to @value.
+ *
+ * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
+ */
+void
+gsd_accounts_user_set_automatic_login (GsdAccountsUser *object, gboolean value)
+{
+  g_object_set (G_OBJECT (object), "automatic-login", value, NULL);
+}
+
+/**
+ * gsd_accounts_user_get_system_account: (skip)
+ * @object: A #GsdAccountsUser.
+ *
+ * Gets the value of the <link linkend="gdbus-property-org-freedesktop-Accounts-User.SystemAccount">"SystemAccount"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * Returns: The property value.
+ */
+gboolean
+gsd_accounts_user_get_system_account (GsdAccountsUser *object)
+{
+  return GSD_ACCOUNTS_USER_GET_IFACE (object)->get_system_account (object);
+}
+
+/**
+ * gsd_accounts_user_set_system_account: (skip)
+ * @object: A #GsdAccountsUser.
+ * @value: The value to set.
+ *
+ * Sets the <link linkend="gdbus-property-org-freedesktop-Accounts-User.SystemAccount">"SystemAccount"</link> D-Bus property to @value.
+ *
+ * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
+ */
+void
+gsd_accounts_user_set_system_account (GsdAccountsUser *object, gboolean value)
+{
+  g_object_set (G_OBJECT (object), "system-account", value, NULL);
+}
+
+/**
+ * gsd_accounts_user_get_local_account: (skip)
+ * @object: A #GsdAccountsUser.
+ *
+ * Gets the value of the <link linkend="gdbus-property-org-freedesktop-Accounts-User.LocalAccount">"LocalAccount"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * Returns: The property value.
+ */
+gboolean
+gsd_accounts_user_get_local_account (GsdAccountsUser *object)
+{
+  return GSD_ACCOUNTS_USER_GET_IFACE (object)->get_local_account (object);
+}
+
+/**
+ * gsd_accounts_user_set_local_account: (skip)
+ * @object: A #GsdAccountsUser.
+ * @value: The value to set.
+ *
+ * Sets the <link linkend="gdbus-property-org-freedesktop-Accounts-User.LocalAccount">"LocalAccount"</link> D-Bus property to @value.
+ *
+ * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
+ */
+void
+gsd_accounts_user_set_local_account (GsdAccountsUser *object, gboolean value)
+{
+  g_object_set (G_OBJECT (object), "local-account", value, NULL);
+}
+
+/**
+ * gsd_accounts_user_emit_changed:
+ * @object: A #GsdAccountsUser.
+ *
+ * Emits the <link linkend="gdbus-signal-org-freedesktop-Accounts-User.Changed">"Changed"</link> D-Bus signal.
+ */
+void
+gsd_accounts_user_emit_changed (
+    GsdAccountsUser *object)
+{
+  g_signal_emit_by_name (object, "changed");
+}
+
+/**
+ * gsd_accounts_user_call_set_user_name:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @arg_name: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetUserName">SetUserName()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call gsd_accounts_user_call_set_user_name_finish() to get the result of the operation.
+ *
+ * See gsd_accounts_user_call_set_user_name_sync() for the synchronous, blocking version of this method.
+ */
+void
+gsd_accounts_user_call_set_user_name (
+    GsdAccountsUser *proxy,
+    const gchar *arg_name,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "SetUserName",
+    g_variant_new ("(s)",
+                   arg_name),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * gsd_accounts_user_call_set_user_name_finish:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gsd_accounts_user_call_set_user_name().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with gsd_accounts_user_call_set_user_name().
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_user_call_set_user_name_finish (
+    GsdAccountsUser *proxy,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_user_call_set_user_name_sync:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @arg_name: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetUserName">SetUserName()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See gsd_accounts_user_call_set_user_name() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_user_call_set_user_name_sync (
+    GsdAccountsUser *proxy,
+    const gchar *arg_name,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "SetUserName",
+    g_variant_new ("(s)",
+                   arg_name),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_user_call_set_real_name:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @arg_name: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetRealName">SetRealName()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call gsd_accounts_user_call_set_real_name_finish() to get the result of the operation.
+ *
+ * See gsd_accounts_user_call_set_real_name_sync() for the synchronous, blocking version of this method.
+ */
+void
+gsd_accounts_user_call_set_real_name (
+    GsdAccountsUser *proxy,
+    const gchar *arg_name,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "SetRealName",
+    g_variant_new ("(s)",
+                   arg_name),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * gsd_accounts_user_call_set_real_name_finish:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gsd_accounts_user_call_set_real_name().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with gsd_accounts_user_call_set_real_name().
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_user_call_set_real_name_finish (
+    GsdAccountsUser *proxy,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_user_call_set_real_name_sync:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @arg_name: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetRealName">SetRealName()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See gsd_accounts_user_call_set_real_name() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_user_call_set_real_name_sync (
+    GsdAccountsUser *proxy,
+    const gchar *arg_name,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "SetRealName",
+    g_variant_new ("(s)",
+                   arg_name),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_user_call_set_email:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @arg_email: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetEmail">SetEmail()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call gsd_accounts_user_call_set_email_finish() to get the result of the operation.
+ *
+ * See gsd_accounts_user_call_set_email_sync() for the synchronous, blocking version of this method.
+ */
+void
+gsd_accounts_user_call_set_email (
+    GsdAccountsUser *proxy,
+    const gchar *arg_email,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "SetEmail",
+    g_variant_new ("(s)",
+                   arg_email),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * gsd_accounts_user_call_set_email_finish:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gsd_accounts_user_call_set_email().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with gsd_accounts_user_call_set_email().
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_user_call_set_email_finish (
+    GsdAccountsUser *proxy,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_user_call_set_email_sync:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @arg_email: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetEmail">SetEmail()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See gsd_accounts_user_call_set_email() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_user_call_set_email_sync (
+    GsdAccountsUser *proxy,
+    const gchar *arg_email,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "SetEmail",
+    g_variant_new ("(s)",
+                   arg_email),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_user_call_set_language:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @arg_language: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetLanguage">SetLanguage()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call gsd_accounts_user_call_set_language_finish() to get the result of the operation.
+ *
+ * See gsd_accounts_user_call_set_language_sync() for the synchronous, blocking version of this method.
+ */
+void
+gsd_accounts_user_call_set_language (
+    GsdAccountsUser *proxy,
+    const gchar *arg_language,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "SetLanguage",
+    g_variant_new ("(s)",
+                   arg_language),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * gsd_accounts_user_call_set_language_finish:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gsd_accounts_user_call_set_language().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with gsd_accounts_user_call_set_language().
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_user_call_set_language_finish (
+    GsdAccountsUser *proxy,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_user_call_set_language_sync:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @arg_language: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetLanguage">SetLanguage()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See gsd_accounts_user_call_set_language() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_user_call_set_language_sync (
+    GsdAccountsUser *proxy,
+    const gchar *arg_language,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "SetLanguage",
+    g_variant_new ("(s)",
+                   arg_language),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_user_call_set_xsession:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @arg_x_session: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetXSession">SetXSession()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call gsd_accounts_user_call_set_xsession_finish() to get the result of the operation.
+ *
+ * See gsd_accounts_user_call_set_xsession_sync() for the synchronous, blocking version of this method.
+ */
+void
+gsd_accounts_user_call_set_xsession (
+    GsdAccountsUser *proxy,
+    const gchar *arg_x_session,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "SetXSession",
+    g_variant_new ("(s)",
+                   arg_x_session),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * gsd_accounts_user_call_set_xsession_finish:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gsd_accounts_user_call_set_xsession().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with gsd_accounts_user_call_set_xsession().
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_user_call_set_xsession_finish (
+    GsdAccountsUser *proxy,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_user_call_set_xsession_sync:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @arg_x_session: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetXSession">SetXSession()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See gsd_accounts_user_call_set_xsession() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_user_call_set_xsession_sync (
+    GsdAccountsUser *proxy,
+    const gchar *arg_x_session,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "SetXSession",
+    g_variant_new ("(s)",
+                   arg_x_session),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_user_call_set_location:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @arg_location: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetLocation">SetLocation()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call gsd_accounts_user_call_set_location_finish() to get the result of the operation.
+ *
+ * See gsd_accounts_user_call_set_location_sync() for the synchronous, blocking version of this method.
+ */
+void
+gsd_accounts_user_call_set_location (
+    GsdAccountsUser *proxy,
+    const gchar *arg_location,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "SetLocation",
+    g_variant_new ("(s)",
+                   arg_location),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * gsd_accounts_user_call_set_location_finish:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gsd_accounts_user_call_set_location().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with gsd_accounts_user_call_set_location().
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_user_call_set_location_finish (
+    GsdAccountsUser *proxy,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_user_call_set_location_sync:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @arg_location: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetLocation">SetLocation()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See gsd_accounts_user_call_set_location() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_user_call_set_location_sync (
+    GsdAccountsUser *proxy,
+    const gchar *arg_location,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "SetLocation",
+    g_variant_new ("(s)",
+                   arg_location),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_user_call_set_home_directory:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @arg_homedir: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetHomeDirectory">SetHomeDirectory()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call gsd_accounts_user_call_set_home_directory_finish() to get the result of the operation.
+ *
+ * See gsd_accounts_user_call_set_home_directory_sync() for the synchronous, blocking version of this method.
+ */
+void
+gsd_accounts_user_call_set_home_directory (
+    GsdAccountsUser *proxy,
+    const gchar *arg_homedir,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "SetHomeDirectory",
+    g_variant_new ("(s)",
+                   arg_homedir),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * gsd_accounts_user_call_set_home_directory_finish:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gsd_accounts_user_call_set_home_directory().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with gsd_accounts_user_call_set_home_directory().
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_user_call_set_home_directory_finish (
+    GsdAccountsUser *proxy,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_user_call_set_home_directory_sync:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @arg_homedir: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetHomeDirectory">SetHomeDirectory()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See gsd_accounts_user_call_set_home_directory() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_user_call_set_home_directory_sync (
+    GsdAccountsUser *proxy,
+    const gchar *arg_homedir,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "SetHomeDirectory",
+    g_variant_new ("(s)",
+                   arg_homedir),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_user_call_set_shell:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @arg_shell: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetShell">SetShell()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call gsd_accounts_user_call_set_shell_finish() to get the result of the operation.
+ *
+ * See gsd_accounts_user_call_set_shell_sync() for the synchronous, blocking version of this method.
+ */
+void
+gsd_accounts_user_call_set_shell (
+    GsdAccountsUser *proxy,
+    const gchar *arg_shell,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "SetShell",
+    g_variant_new ("(s)",
+                   arg_shell),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * gsd_accounts_user_call_set_shell_finish:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gsd_accounts_user_call_set_shell().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with gsd_accounts_user_call_set_shell().
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_user_call_set_shell_finish (
+    GsdAccountsUser *proxy,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_user_call_set_shell_sync:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @arg_shell: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetShell">SetShell()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See gsd_accounts_user_call_set_shell() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_user_call_set_shell_sync (
+    GsdAccountsUser *proxy,
+    const gchar *arg_shell,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "SetShell",
+    g_variant_new ("(s)",
+                   arg_shell),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_user_call_set_icon_file:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @arg_filename: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetIconFile">SetIconFile()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call gsd_accounts_user_call_set_icon_file_finish() to get the result of the operation.
+ *
+ * See gsd_accounts_user_call_set_icon_file_sync() for the synchronous, blocking version of this method.
+ */
+void
+gsd_accounts_user_call_set_icon_file (
+    GsdAccountsUser *proxy,
+    const gchar *arg_filename,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "SetIconFile",
+    g_variant_new ("(s)",
+                   arg_filename),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * gsd_accounts_user_call_set_icon_file_finish:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gsd_accounts_user_call_set_icon_file().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with gsd_accounts_user_call_set_icon_file().
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_user_call_set_icon_file_finish (
+    GsdAccountsUser *proxy,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_user_call_set_icon_file_sync:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @arg_filename: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetIconFile">SetIconFile()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See gsd_accounts_user_call_set_icon_file() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_user_call_set_icon_file_sync (
+    GsdAccountsUser *proxy,
+    const gchar *arg_filename,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "SetIconFile",
+    g_variant_new ("(s)",
+                   arg_filename),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_user_call_set_locked:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @arg_locked: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetLocked">SetLocked()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call gsd_accounts_user_call_set_locked_finish() to get the result of the operation.
+ *
+ * See gsd_accounts_user_call_set_locked_sync() for the synchronous, blocking version of this method.
+ */
+void
+gsd_accounts_user_call_set_locked (
+    GsdAccountsUser *proxy,
+    gboolean arg_locked,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "SetLocked",
+    g_variant_new ("(b)",
+                   arg_locked),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * gsd_accounts_user_call_set_locked_finish:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gsd_accounts_user_call_set_locked().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with gsd_accounts_user_call_set_locked().
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_user_call_set_locked_finish (
+    GsdAccountsUser *proxy,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_user_call_set_locked_sync:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @arg_locked: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetLocked">SetLocked()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See gsd_accounts_user_call_set_locked() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_user_call_set_locked_sync (
+    GsdAccountsUser *proxy,
+    gboolean arg_locked,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "SetLocked",
+    g_variant_new ("(b)",
+                   arg_locked),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_user_call_set_account_type:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @arg_accountType: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetAccountType">SetAccountType()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call gsd_accounts_user_call_set_account_type_finish() to get the result of the operation.
+ *
+ * See gsd_accounts_user_call_set_account_type_sync() for the synchronous, blocking version of this method.
+ */
+void
+gsd_accounts_user_call_set_account_type (
+    GsdAccountsUser *proxy,
+    gint arg_accountType,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "SetAccountType",
+    g_variant_new ("(i)",
+                   arg_accountType),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * gsd_accounts_user_call_set_account_type_finish:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gsd_accounts_user_call_set_account_type().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with gsd_accounts_user_call_set_account_type().
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_user_call_set_account_type_finish (
+    GsdAccountsUser *proxy,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_user_call_set_account_type_sync:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @arg_accountType: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetAccountType">SetAccountType()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See gsd_accounts_user_call_set_account_type() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_user_call_set_account_type_sync (
+    GsdAccountsUser *proxy,
+    gint arg_accountType,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "SetAccountType",
+    g_variant_new ("(i)",
+                   arg_accountType),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_user_call_set_password_mode:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @arg_mode: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetPasswordMode">SetPasswordMode()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call gsd_accounts_user_call_set_password_mode_finish() to get the result of the operation.
+ *
+ * See gsd_accounts_user_call_set_password_mode_sync() for the synchronous, blocking version of this method.
+ */
+void
+gsd_accounts_user_call_set_password_mode (
+    GsdAccountsUser *proxy,
+    gint arg_mode,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "SetPasswordMode",
+    g_variant_new ("(i)",
+                   arg_mode),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * gsd_accounts_user_call_set_password_mode_finish:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gsd_accounts_user_call_set_password_mode().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with gsd_accounts_user_call_set_password_mode().
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_user_call_set_password_mode_finish (
+    GsdAccountsUser *proxy,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_user_call_set_password_mode_sync:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @arg_mode: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetPasswordMode">SetPasswordMode()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See gsd_accounts_user_call_set_password_mode() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_user_call_set_password_mode_sync (
+    GsdAccountsUser *proxy,
+    gint arg_mode,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "SetPasswordMode",
+    g_variant_new ("(i)",
+                   arg_mode),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_user_call_set_password:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @arg_password: Argument to pass with the method invocation.
+ * @arg_hint: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetPassword">SetPassword()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call gsd_accounts_user_call_set_password_finish() to get the result of the operation.
+ *
+ * See gsd_accounts_user_call_set_password_sync() for the synchronous, blocking version of this method.
+ */
+void
+gsd_accounts_user_call_set_password (
+    GsdAccountsUser *proxy,
+    const gchar *arg_password,
+    const gchar *arg_hint,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "SetPassword",
+    g_variant_new ("(ss)",
+                   arg_password,
+                   arg_hint),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * gsd_accounts_user_call_set_password_finish:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gsd_accounts_user_call_set_password().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with gsd_accounts_user_call_set_password().
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_user_call_set_password_finish (
+    GsdAccountsUser *proxy,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_user_call_set_password_sync:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @arg_password: Argument to pass with the method invocation.
+ * @arg_hint: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetPassword">SetPassword()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See gsd_accounts_user_call_set_password() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_user_call_set_password_sync (
+    GsdAccountsUser *proxy,
+    const gchar *arg_password,
+    const gchar *arg_hint,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "SetPassword",
+    g_variant_new ("(ss)",
+                   arg_password,
+                   arg_hint),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_user_call_set_password_hint:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @arg_hint: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetPasswordHint">SetPasswordHint()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call gsd_accounts_user_call_set_password_hint_finish() to get the result of the operation.
+ *
+ * See gsd_accounts_user_call_set_password_hint_sync() for the synchronous, blocking version of this method.
+ */
+void
+gsd_accounts_user_call_set_password_hint (
+    GsdAccountsUser *proxy,
+    const gchar *arg_hint,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "SetPasswordHint",
+    g_variant_new ("(s)",
+                   arg_hint),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * gsd_accounts_user_call_set_password_hint_finish:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gsd_accounts_user_call_set_password_hint().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with gsd_accounts_user_call_set_password_hint().
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_user_call_set_password_hint_finish (
+    GsdAccountsUser *proxy,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_user_call_set_password_hint_sync:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @arg_hint: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetPasswordHint">SetPasswordHint()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See gsd_accounts_user_call_set_password_hint() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_user_call_set_password_hint_sync (
+    GsdAccountsUser *proxy,
+    const gchar *arg_hint,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "SetPasswordHint",
+    g_variant_new ("(s)",
+                   arg_hint),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_user_call_set_automatic_login:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @arg_enabled: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetAutomaticLogin">SetAutomaticLogin()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call gsd_accounts_user_call_set_automatic_login_finish() to get the result of the operation.
+ *
+ * See gsd_accounts_user_call_set_automatic_login_sync() for the synchronous, blocking version of this method.
+ */
+void
+gsd_accounts_user_call_set_automatic_login (
+    GsdAccountsUser *proxy,
+    gboolean arg_enabled,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "SetAutomaticLogin",
+    g_variant_new ("(b)",
+                   arg_enabled),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * gsd_accounts_user_call_set_automatic_login_finish:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gsd_accounts_user_call_set_automatic_login().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with gsd_accounts_user_call_set_automatic_login().
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_user_call_set_automatic_login_finish (
+    GsdAccountsUser *proxy,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_user_call_set_automatic_login_sync:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @arg_enabled: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetAutomaticLogin">SetAutomaticLogin()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See gsd_accounts_user_call_set_automatic_login() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_user_call_set_automatic_login_sync (
+    GsdAccountsUser *proxy,
+    gboolean arg_enabled,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "SetAutomaticLogin",
+    g_variant_new ("(b)",
+                   arg_enabled),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_user_call_get_password_expiration_policy:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts-User.GetPasswordExpirationPolicy">GetPasswordExpirationPolicy()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call gsd_accounts_user_call_get_password_expiration_policy_finish() to get the result of the operation.
+ *
+ * See gsd_accounts_user_call_get_password_expiration_policy_sync() for the synchronous, blocking version of this method.
+ */
+void
+gsd_accounts_user_call_get_password_expiration_policy (
+    GsdAccountsUser *proxy,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "GetPasswordExpirationPolicy",
+    g_variant_new ("()"),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * gsd_accounts_user_call_get_password_expiration_policy_finish:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @out_expiration_time: (out): Return location for return parameter or %NULL to ignore.
+ * @out_last_change_time: (out): Return location for return parameter or %NULL to ignore.
+ * @out_min_days_between_changes: (out): Return location for return parameter or %NULL to ignore.
+ * @out_max_days_between_changes: (out): Return location for return parameter or %NULL to ignore.
+ * @out_days_to_warn: (out): Return location for return parameter or %NULL to ignore.
+ * @out_days_after_expiration_until_lock: (out): Return location for return parameter or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gsd_accounts_user_call_get_password_expiration_policy().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with gsd_accounts_user_call_get_password_expiration_policy().
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_user_call_get_password_expiration_policy_finish (
+    GsdAccountsUser *proxy,
+    gint64 *out_expiration_time,
+    gint64 *out_last_change_time,
+    gint64 *out_min_days_between_changes,
+    gint64 *out_max_days_between_changes,
+    gint64 *out_days_to_warn,
+    gint64 *out_days_after_expiration_until_lock,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(xxxxxx)",
+                 out_expiration_time,
+                 out_last_change_time,
+                 out_min_days_between_changes,
+                 out_max_days_between_changes,
+                 out_days_to_warn,
+                 out_days_after_expiration_until_lock);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_user_call_get_password_expiration_policy_sync:
+ * @proxy: A #GsdAccountsUserProxy.
+ * @out_expiration_time: (out): Return location for return parameter or %NULL to ignore.
+ * @out_last_change_time: (out): Return location for return parameter or %NULL to ignore.
+ * @out_min_days_between_changes: (out): Return location for return parameter or %NULL to ignore.
+ * @out_max_days_between_changes: (out): Return location for return parameter or %NULL to ignore.
+ * @out_days_to_warn: (out): Return location for return parameter or %NULL to ignore.
+ * @out_days_after_expiration_until_lock: (out): Return location for return parameter or %NULL to ignore.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts-User.GetPasswordExpirationPolicy">GetPasswordExpirationPolicy()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See gsd_accounts_user_call_get_password_expiration_policy() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_user_call_get_password_expiration_policy_sync (
+    GsdAccountsUser *proxy,
+    gint64 *out_expiration_time,
+    gint64 *out_last_change_time,
+    gint64 *out_min_days_between_changes,
+    gint64 *out_max_days_between_changes,
+    gint64 *out_days_to_warn,
+    gint64 *out_days_after_expiration_until_lock,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "GetPasswordExpirationPolicy",
+    g_variant_new ("()"),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(xxxxxx)",
+                 out_expiration_time,
+                 out_last_change_time,
+                 out_min_days_between_changes,
+                 out_max_days_between_changes,
+                 out_days_to_warn,
+                 out_days_after_expiration_until_lock);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_user_complete_set_user_name:
+ * @object: A #GsdAccountsUser.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetUserName">SetUserName()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+gsd_accounts_user_complete_set_user_name (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("()"));
+}
+
+/**
+ * gsd_accounts_user_complete_set_real_name:
+ * @object: A #GsdAccountsUser.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetRealName">SetRealName()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+gsd_accounts_user_complete_set_real_name (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("()"));
+}
+
+/**
+ * gsd_accounts_user_complete_set_email:
+ * @object: A #GsdAccountsUser.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetEmail">SetEmail()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+gsd_accounts_user_complete_set_email (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("()"));
+}
+
+/**
+ * gsd_accounts_user_complete_set_language:
+ * @object: A #GsdAccountsUser.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetLanguage">SetLanguage()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+gsd_accounts_user_complete_set_language (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("()"));
+}
+
+/**
+ * gsd_accounts_user_complete_set_xsession:
+ * @object: A #GsdAccountsUser.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetXSession">SetXSession()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+gsd_accounts_user_complete_set_xsession (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("()"));
+}
+
+/**
+ * gsd_accounts_user_complete_set_location:
+ * @object: A #GsdAccountsUser.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetLocation">SetLocation()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+gsd_accounts_user_complete_set_location (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("()"));
+}
+
+/**
+ * gsd_accounts_user_complete_set_home_directory:
+ * @object: A #GsdAccountsUser.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetHomeDirectory">SetHomeDirectory()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+gsd_accounts_user_complete_set_home_directory (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("()"));
+}
+
+/**
+ * gsd_accounts_user_complete_set_shell:
+ * @object: A #GsdAccountsUser.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetShell">SetShell()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+gsd_accounts_user_complete_set_shell (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("()"));
+}
+
+/**
+ * gsd_accounts_user_complete_set_icon_file:
+ * @object: A #GsdAccountsUser.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetIconFile">SetIconFile()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+gsd_accounts_user_complete_set_icon_file (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("()"));
+}
+
+/**
+ * gsd_accounts_user_complete_set_locked:
+ * @object: A #GsdAccountsUser.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetLocked">SetLocked()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+gsd_accounts_user_complete_set_locked (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("()"));
+}
+
+/**
+ * gsd_accounts_user_complete_set_account_type:
+ * @object: A #GsdAccountsUser.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetAccountType">SetAccountType()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+gsd_accounts_user_complete_set_account_type (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("()"));
+}
+
+/**
+ * gsd_accounts_user_complete_set_password_mode:
+ * @object: A #GsdAccountsUser.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetPasswordMode">SetPasswordMode()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+gsd_accounts_user_complete_set_password_mode (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("()"));
+}
+
+/**
+ * gsd_accounts_user_complete_set_password:
+ * @object: A #GsdAccountsUser.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetPassword">SetPassword()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+gsd_accounts_user_complete_set_password (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("()"));
+}
+
+/**
+ * gsd_accounts_user_complete_set_password_hint:
+ * @object: A #GsdAccountsUser.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetPasswordHint">SetPasswordHint()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+gsd_accounts_user_complete_set_password_hint (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("()"));
+}
+
+/**
+ * gsd_accounts_user_complete_set_automatic_login:
+ * @object: A #GsdAccountsUser.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-Accounts-User.SetAutomaticLogin">SetAutomaticLogin()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+gsd_accounts_user_complete_set_automatic_login (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("()"));
+}
+
+/**
+ * gsd_accounts_user_complete_get_password_expiration_policy:
+ * @object: A #GsdAccountsUser.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @expiration_time: Parameter to return.
+ * @last_change_time: Parameter to return.
+ * @min_days_between_changes: Parameter to return.
+ * @max_days_between_changes: Parameter to return.
+ * @days_to_warn: Parameter to return.
+ * @days_after_expiration_until_lock: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-Accounts-User.GetPasswordExpirationPolicy">GetPasswordExpirationPolicy()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+gsd_accounts_user_complete_get_password_expiration_policy (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation,
+    gint64 expiration_time,
+    gint64 last_change_time,
+    gint64 min_days_between_changes,
+    gint64 max_days_between_changes,
+    gint64 days_to_warn,
+    gint64 days_after_expiration_until_lock)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("(xxxxxx)",
+                   expiration_time,
+                   last_change_time,
+                   min_days_between_changes,
+                   max_days_between_changes,
+                   days_to_warn,
+                   days_after_expiration_until_lock));
+}
+
+/* ------------------------------------------------------------------------ */
+
+/**
+ * GsdAccountsUserProxy:
+ *
+ * The #GsdAccountsUserProxy structure contains only private data and should only be accessed using the provided API.
+ */
+
+/**
+ * GsdAccountsUserProxyClass:
+ * @parent_class: The parent class.
+ *
+ * Class structure for #GsdAccountsUserProxy.
+ */
+
+struct _GsdAccountsUserProxyPrivate
+{
+  GData *qdata;
+};
+
+static void gsd_accounts_user_proxy_iface_init (GsdAccountsUserIface *iface);
+
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+G_DEFINE_TYPE_WITH_CODE (GsdAccountsUserProxy, gsd_accounts_user_proxy, G_TYPE_DBUS_PROXY,
+                         G_ADD_PRIVATE (GsdAccountsUserProxy)
+                         G_IMPLEMENT_INTERFACE (GSD_TYPE_ACCOUNTS_USER, gsd_accounts_user_proxy_iface_init))
+
+#else
+G_DEFINE_TYPE_WITH_CODE (GsdAccountsUserProxy, gsd_accounts_user_proxy, G_TYPE_DBUS_PROXY,
+                         G_IMPLEMENT_INTERFACE (GSD_TYPE_ACCOUNTS_USER, gsd_accounts_user_proxy_iface_init))
+
+#endif
+static void
+gsd_accounts_user_proxy_finalize (GObject *object)
+{
+  GsdAccountsUserProxy *proxy = GSD_ACCOUNTS_USER_PROXY (object);
+  g_datalist_clear (&proxy->priv->qdata);
+  G_OBJECT_CLASS (gsd_accounts_user_proxy_parent_class)->finalize (object);
+}
+
+static void
+gsd_accounts_user_proxy_get_property (GObject      *object,
+  guint         prop_id,
+  GValue       *value,
+  GParamSpec   *pspec G_GNUC_UNUSED)
+{
+  const _ExtendedGDBusPropertyInfo *info;
+  GVariant *variant;
+  g_assert (prop_id != 0 && prop_id - 1 < 20);
+  info = _gsd_accounts_user_property_info_pointers[prop_id - 1];
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
+  if (info->use_gvariant)
+    {
+      g_value_set_variant (value, variant);
+    }
+  else
+    {
+      if (variant != NULL)
+        g_dbus_gvariant_to_gvalue (variant, value);
+    }
+  if (variant != NULL)
+    g_variant_unref (variant);
+}
+
+static void
+gsd_accounts_user_proxy_set_property_cb (GDBusProxy *proxy,
+  GAsyncResult *res,
+  gpointer      user_data)
+{
+  const _ExtendedGDBusPropertyInfo *info = user_data;
+  GError *error;
+  GVariant *_ret;
+  error = NULL;
+  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
+  if (!_ret)
+    {
+      g_warning ("Error setting property '%s' on interface org.freedesktop.Accounts.User: %s (%s, %d)",
+                 info->parent_struct.name,
+                 error->message, g_quark_to_string (error->domain), error->code);
+      g_error_free (error);
+    }
+  else
+    {
+      g_variant_unref (_ret);
+    }
+}
+
+static void
+gsd_accounts_user_proxy_set_property (GObject      *object,
+  guint         prop_id,
+  const GValue *value,
+  GParamSpec   *pspec G_GNUC_UNUSED)
+{
+  const _ExtendedGDBusPropertyInfo *info;
+  GVariant *variant;
+  g_assert (prop_id != 0 && prop_id - 1 < 20);
+  info = _gsd_accounts_user_property_info_pointers[prop_id - 1];
+  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
+  g_dbus_proxy_call (G_DBUS_PROXY (object),
+    "org.freedesktop.DBus.Properties.Set",
+    g_variant_new ("(ssv)", "org.freedesktop.Accounts.User", info->parent_struct.name, variant),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    NULL, (GAsyncReadyCallback) gsd_accounts_user_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
+  g_variant_unref (variant);
+}
+
+static void
+gsd_accounts_user_proxy_g_signal (GDBusProxy *proxy,
+  const gchar *sender_name G_GNUC_UNUSED,
+  const gchar *signal_name,
+  GVariant *parameters)
+{
+  _ExtendedGDBusSignalInfo *info;
+  GVariantIter iter;
+  GVariant *child;
+  GValue *paramv;
+  gsize num_params;
+  gsize n;
+  guint signal_id;
+  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_gsd_accounts_user_interface_info.parent_struct, signal_name);
+  if (info == NULL)
+    return;
+  num_params = g_variant_n_children (parameters);
+  paramv = g_new0 (GValue, num_params + 1);
+  g_value_init (&paramv[0], GSD_TYPE_ACCOUNTS_USER);
+  g_value_set_object (&paramv[0], proxy);
+  g_variant_iter_init (&iter, parameters);
+  n = 1;
+  while ((child = g_variant_iter_next_value (&iter)) != NULL)
+    {
+      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
+      if (arg_info->use_gvariant)
+        {
+          g_value_init (&paramv[n], G_TYPE_VARIANT);
+          g_value_set_variant (&paramv[n], child);
+          n++;
+        }
+      else
+        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
+      g_variant_unref (child);
+    }
+  signal_id = g_signal_lookup (info->signal_name, GSD_TYPE_ACCOUNTS_USER);
+  g_signal_emitv (paramv, signal_id, 0, NULL);
+  for (n = 0; n < num_params + 1; n++)
+    g_value_unset (&paramv[n]);
+  g_free (paramv);
+}
+
+static void
+gsd_accounts_user_proxy_g_properties_changed (GDBusProxy *_proxy,
+  GVariant *changed_properties,
+  const gchar *const *invalidated_properties)
+{
+  GsdAccountsUserProxy *proxy = GSD_ACCOUNTS_USER_PROXY (_proxy);
+  guint n;
+  const gchar *key;
+  GVariantIter *iter;
+  _ExtendedGDBusPropertyInfo *info;
+  g_variant_get (changed_properties, "a{sv}", &iter);
+  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
+    {
+      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_gsd_accounts_user_interface_info.parent_struct, key);
+      g_datalist_remove_data (&proxy->priv->qdata, key);
+      if (info != NULL)
+        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
+    }
+  g_variant_iter_free (iter);
+  for (n = 0; invalidated_properties[n] != NULL; n++)
+    {
+      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_gsd_accounts_user_interface_info.parent_struct, invalidated_properties[n]);
+      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
+      if (info != NULL)
+        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
+    }
+}
+
+static guint64
+gsd_accounts_user_proxy_get_uid (GsdAccountsUser *object)
+{
+  GsdAccountsUserProxy *proxy = GSD_ACCOUNTS_USER_PROXY (object);
+  GVariant *variant;
+  guint64 value = 0;
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Uid");
+  if (variant != NULL)
+    {
+      value = g_variant_get_uint64 (variant);
+      g_variant_unref (variant);
+    }
+  return value;
+}
+
+static const gchar *
+gsd_accounts_user_proxy_get_user_name (GsdAccountsUser *object)
+{
+  GsdAccountsUserProxy *proxy = GSD_ACCOUNTS_USER_PROXY (object);
+  GVariant *variant;
+  const gchar *value = NULL;
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "UserName");
+  if (variant != NULL)
+    {
+      value = g_variant_get_string (variant, NULL);
+      g_variant_unref (variant);
+    }
+  return value;
+}
+
+static const gchar *
+gsd_accounts_user_proxy_get_real_name (GsdAccountsUser *object)
+{
+  GsdAccountsUserProxy *proxy = GSD_ACCOUNTS_USER_PROXY (object);
+  GVariant *variant;
+  const gchar *value = NULL;
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "RealName");
+  if (variant != NULL)
+    {
+      value = g_variant_get_string (variant, NULL);
+      g_variant_unref (variant);
+    }
+  return value;
+}
+
+static gint
+gsd_accounts_user_proxy_get_account_type (GsdAccountsUser *object)
+{
+  GsdAccountsUserProxy *proxy = GSD_ACCOUNTS_USER_PROXY (object);
+  GVariant *variant;
+  gint value = 0;
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "AccountType");
+  if (variant != NULL)
+    {
+      value = g_variant_get_int32 (variant);
+      g_variant_unref (variant);
+    }
+  return value;
+}
+
+static const gchar *
+gsd_accounts_user_proxy_get_home_directory (GsdAccountsUser *object)
+{
+  GsdAccountsUserProxy *proxy = GSD_ACCOUNTS_USER_PROXY (object);
+  GVariant *variant;
+  const gchar *value = NULL;
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "HomeDirectory");
+  if (variant != NULL)
+    {
+      value = g_variant_get_string (variant, NULL);
+      g_variant_unref (variant);
+    }
+  return value;
+}
+
+static const gchar *
+gsd_accounts_user_proxy_get_shell (GsdAccountsUser *object)
+{
+  GsdAccountsUserProxy *proxy = GSD_ACCOUNTS_USER_PROXY (object);
+  GVariant *variant;
+  const gchar *value = NULL;
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Shell");
+  if (variant != NULL)
+    {
+      value = g_variant_get_string (variant, NULL);
+      g_variant_unref (variant);
+    }
+  return value;
+}
+
+static const gchar *
+gsd_accounts_user_proxy_get_email (GsdAccountsUser *object)
+{
+  GsdAccountsUserProxy *proxy = GSD_ACCOUNTS_USER_PROXY (object);
+  GVariant *variant;
+  const gchar *value = NULL;
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Email");
+  if (variant != NULL)
+    {
+      value = g_variant_get_string (variant, NULL);
+      g_variant_unref (variant);
+    }
+  return value;
+}
+
+static const gchar *
+gsd_accounts_user_proxy_get_language (GsdAccountsUser *object)
+{
+  GsdAccountsUserProxy *proxy = GSD_ACCOUNTS_USER_PROXY (object);
+  GVariant *variant;
+  const gchar *value = NULL;
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Language");
+  if (variant != NULL)
+    {
+      value = g_variant_get_string (variant, NULL);
+      g_variant_unref (variant);
+    }
+  return value;
+}
+
+static const gchar *
+gsd_accounts_user_proxy_get_xsession (GsdAccountsUser *object)
+{
+  GsdAccountsUserProxy *proxy = GSD_ACCOUNTS_USER_PROXY (object);
+  GVariant *variant;
+  const gchar *value = NULL;
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "XSession");
+  if (variant != NULL)
+    {
+      value = g_variant_get_string (variant, NULL);
+      g_variant_unref (variant);
+    }
+  return value;
+}
+
+static const gchar *
+gsd_accounts_user_proxy_get_location (GsdAccountsUser *object)
+{
+  GsdAccountsUserProxy *proxy = GSD_ACCOUNTS_USER_PROXY (object);
+  GVariant *variant;
+  const gchar *value = NULL;
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Location");
+  if (variant != NULL)
+    {
+      value = g_variant_get_string (variant, NULL);
+      g_variant_unref (variant);
+    }
+  return value;
+}
+
+static guint64
+gsd_accounts_user_proxy_get_login_frequency (GsdAccountsUser *object)
+{
+  GsdAccountsUserProxy *proxy = GSD_ACCOUNTS_USER_PROXY (object);
+  GVariant *variant;
+  guint64 value = 0;
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "LoginFrequency");
+  if (variant != NULL)
+    {
+      value = g_variant_get_uint64 (variant);
+      g_variant_unref (variant);
+    }
+  return value;
+}
+
+static gint64
+gsd_accounts_user_proxy_get_login_time (GsdAccountsUser *object)
+{
+  GsdAccountsUserProxy *proxy = GSD_ACCOUNTS_USER_PROXY (object);
+  GVariant *variant;
+  gint64 value = 0;
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "LoginTime");
+  if (variant != NULL)
+    {
+      value = g_variant_get_int64 (variant);
+      g_variant_unref (variant);
+    }
+  return value;
+}
+
+static GVariant *
+gsd_accounts_user_proxy_get_login_history (GsdAccountsUser *object)
+{
+  GsdAccountsUserProxy *proxy = GSD_ACCOUNTS_USER_PROXY (object);
+  GVariant *variant;
+  GVariant *value = NULL;
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "LoginHistory");
+  value = variant;
+  if (variant != NULL)
+    g_variant_unref (variant);
+  return value;
+}
+
+static const gchar *
+gsd_accounts_user_proxy_get_icon_file (GsdAccountsUser *object)
+{
+  GsdAccountsUserProxy *proxy = GSD_ACCOUNTS_USER_PROXY (object);
+  GVariant *variant;
+  const gchar *value = NULL;
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "IconFile");
+  if (variant != NULL)
+    {
+      value = g_variant_get_string (variant, NULL);
+      g_variant_unref (variant);
+    }
+  return value;
+}
+
+static gboolean
+gsd_accounts_user_proxy_get_locked (GsdAccountsUser *object)
+{
+  GsdAccountsUserProxy *proxy = GSD_ACCOUNTS_USER_PROXY (object);
+  GVariant *variant;
+  gboolean value = 0;
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Locked");
+  if (variant != NULL)
+    {
+      value = g_variant_get_boolean (variant);
+      g_variant_unref (variant);
+    }
+  return value;
+}
+
+static gint
+gsd_accounts_user_proxy_get_password_mode (GsdAccountsUser *object)
+{
+  GsdAccountsUserProxy *proxy = GSD_ACCOUNTS_USER_PROXY (object);
+  GVariant *variant;
+  gint value = 0;
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "PasswordMode");
+  if (variant != NULL)
+    {
+      value = g_variant_get_int32 (variant);
+      g_variant_unref (variant);
+    }
+  return value;
+}
+
+static const gchar *
+gsd_accounts_user_proxy_get_password_hint (GsdAccountsUser *object)
+{
+  GsdAccountsUserProxy *proxy = GSD_ACCOUNTS_USER_PROXY (object);
+  GVariant *variant;
+  const gchar *value = NULL;
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "PasswordHint");
+  if (variant != NULL)
+    {
+      value = g_variant_get_string (variant, NULL);
+      g_variant_unref (variant);
+    }
+  return value;
+}
+
+static gboolean
+gsd_accounts_user_proxy_get_automatic_login (GsdAccountsUser *object)
+{
+  GsdAccountsUserProxy *proxy = GSD_ACCOUNTS_USER_PROXY (object);
+  GVariant *variant;
+  gboolean value = 0;
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "AutomaticLogin");
+  if (variant != NULL)
+    {
+      value = g_variant_get_boolean (variant);
+      g_variant_unref (variant);
+    }
+  return value;
+}
+
+static gboolean
+gsd_accounts_user_proxy_get_system_account (GsdAccountsUser *object)
+{
+  GsdAccountsUserProxy *proxy = GSD_ACCOUNTS_USER_PROXY (object);
+  GVariant *variant;
+  gboolean value = 0;
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "SystemAccount");
+  if (variant != NULL)
+    {
+      value = g_variant_get_boolean (variant);
+      g_variant_unref (variant);
+    }
+  return value;
+}
+
+static gboolean
+gsd_accounts_user_proxy_get_local_account (GsdAccountsUser *object)
+{
+  GsdAccountsUserProxy *proxy = GSD_ACCOUNTS_USER_PROXY (object);
+  GVariant *variant;
+  gboolean value = 0;
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "LocalAccount");
+  if (variant != NULL)
+    {
+      value = g_variant_get_boolean (variant);
+      g_variant_unref (variant);
+    }
+  return value;
+}
+
+static void
+gsd_accounts_user_proxy_init (GsdAccountsUserProxy *proxy)
+{
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+  proxy->priv = gsd_accounts_user_proxy_get_instance_private (proxy);
+#else
+  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, GSD_TYPE_ACCOUNTS_USER_PROXY, GsdAccountsUserProxyPrivate);
+#endif
+
+  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), gsd_accounts_user_interface_info ());
+}
+
+static void
+gsd_accounts_user_proxy_class_init (GsdAccountsUserProxyClass *klass)
+{
+  GObjectClass *gobject_class;
+  GDBusProxyClass *proxy_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  gobject_class->finalize     = gsd_accounts_user_proxy_finalize;
+  gobject_class->get_property = gsd_accounts_user_proxy_get_property;
+  gobject_class->set_property = gsd_accounts_user_proxy_set_property;
+
+  proxy_class = G_DBUS_PROXY_CLASS (klass);
+  proxy_class->g_signal = gsd_accounts_user_proxy_g_signal;
+  proxy_class->g_properties_changed = gsd_accounts_user_proxy_g_properties_changed;
+
+  gsd_accounts_user_override_properties (gobject_class, 1);
+
+#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
+  g_type_class_add_private (klass, sizeof (GsdAccountsUserProxyPrivate));
+#endif
+}
+
+static void
+gsd_accounts_user_proxy_iface_init (GsdAccountsUserIface *iface)
+{
+  iface->get_uid = gsd_accounts_user_proxy_get_uid;
+  iface->get_user_name = gsd_accounts_user_proxy_get_user_name;
+  iface->get_real_name = gsd_accounts_user_proxy_get_real_name;
+  iface->get_account_type = gsd_accounts_user_proxy_get_account_type;
+  iface->get_home_directory = gsd_accounts_user_proxy_get_home_directory;
+  iface->get_shell = gsd_accounts_user_proxy_get_shell;
+  iface->get_email = gsd_accounts_user_proxy_get_email;
+  iface->get_language = gsd_accounts_user_proxy_get_language;
+  iface->get_xsession = gsd_accounts_user_proxy_get_xsession;
+  iface->get_location = gsd_accounts_user_proxy_get_location;
+  iface->get_login_frequency = gsd_accounts_user_proxy_get_login_frequency;
+  iface->get_login_time = gsd_accounts_user_proxy_get_login_time;
+  iface->get_login_history = gsd_accounts_user_proxy_get_login_history;
+  iface->get_icon_file = gsd_accounts_user_proxy_get_icon_file;
+  iface->get_locked = gsd_accounts_user_proxy_get_locked;
+  iface->get_password_mode = gsd_accounts_user_proxy_get_password_mode;
+  iface->get_password_hint = gsd_accounts_user_proxy_get_password_hint;
+  iface->get_automatic_login = gsd_accounts_user_proxy_get_automatic_login;
+  iface->get_system_account = gsd_accounts_user_proxy_get_system_account;
+  iface->get_local_account = gsd_accounts_user_proxy_get_local_account;
+}
+
+/**
+ * gsd_accounts_user_proxy_new:
+ * @connection: A #GDBusConnection.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
+ * @object_path: An object path.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-Accounts-User.top_of_page">org.freedesktop.Accounts.User</link>. See g_dbus_proxy_new() for more details.
+ *
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call gsd_accounts_user_proxy_new_finish() to get the result of the operation.
+ *
+ * See gsd_accounts_user_proxy_new_sync() for the synchronous, blocking version of this constructor.
+ */
+void
+gsd_accounts_user_proxy_new (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data)
+{
+  g_async_initable_new_async (GSD_TYPE_ACCOUNTS_USER_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.freedesktop.Accounts.User", NULL);
+}
+
+/**
+ * gsd_accounts_user_proxy_new_finish:
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gsd_accounts_user_proxy_new().
+ * @error: Return location for error or %NULL
+ *
+ * Finishes an operation started with gsd_accounts_user_proxy_new().
+ *
+ * Returns: (transfer full) (type GsdAccountsUserProxy): The constructed proxy object or %NULL if @error is set.
+ */
+GsdAccountsUser *
+gsd_accounts_user_proxy_new_finish (
+    GAsyncResult        *res,
+    GError             **error)
+{
+  GObject *ret;
+  GObject *source_object;
+  source_object = g_async_result_get_source_object (res);
+  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
+  g_object_unref (source_object);
+  if (ret != NULL)
+    return GSD_ACCOUNTS_USER (ret);
+  else
+    return NULL;
+}
+
+/**
+ * gsd_accounts_user_proxy_new_sync:
+ * @connection: A #GDBusConnection.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
+ * @object_path: An object path.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL
+ *
+ * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-Accounts-User.top_of_page">org.freedesktop.Accounts.User</link>. See g_dbus_proxy_new_sync() for more details.
+ *
+ * The calling thread is blocked until a reply is received.
+ *
+ * See gsd_accounts_user_proxy_new() for the asynchronous version of this constructor.
+ *
+ * Returns: (transfer full) (type GsdAccountsUserProxy): The constructed proxy object or %NULL if @error is set.
+ */
+GsdAccountsUser *
+gsd_accounts_user_proxy_new_sync (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error)
+{
+  GInitable *ret;
+  ret = g_initable_new (GSD_TYPE_ACCOUNTS_USER_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.freedesktop.Accounts.User", NULL);
+  if (ret != NULL)
+    return GSD_ACCOUNTS_USER (ret);
+  else
+    return NULL;
+}
+
+
+/**
+ * gsd_accounts_user_proxy_new_for_bus:
+ * @bus_type: A #GBusType.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: A bus name (well-known or unique).
+ * @object_path: An object path.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
+ * @user_data: User data to pass to @callback.
+ *
+ * Like gsd_accounts_user_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
+ *
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call gsd_accounts_user_proxy_new_for_bus_finish() to get the result of the operation.
+ *
+ * See gsd_accounts_user_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
+ */
+void
+gsd_accounts_user_proxy_new_for_bus (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data)
+{
+  g_async_initable_new_async (GSD_TYPE_ACCOUNTS_USER_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.freedesktop.Accounts.User", NULL);
+}
+
+/**
+ * gsd_accounts_user_proxy_new_for_bus_finish:
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gsd_accounts_user_proxy_new_for_bus().
+ * @error: Return location for error or %NULL
+ *
+ * Finishes an operation started with gsd_accounts_user_proxy_new_for_bus().
+ *
+ * Returns: (transfer full) (type GsdAccountsUserProxy): The constructed proxy object or %NULL if @error is set.
+ */
+GsdAccountsUser *
+gsd_accounts_user_proxy_new_for_bus_finish (
+    GAsyncResult        *res,
+    GError             **error)
+{
+  GObject *ret;
+  GObject *source_object;
+  source_object = g_async_result_get_source_object (res);
+  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
+  g_object_unref (source_object);
+  if (ret != NULL)
+    return GSD_ACCOUNTS_USER (ret);
+  else
+    return NULL;
+}
+
+/**
+ * gsd_accounts_user_proxy_new_for_bus_sync:
+ * @bus_type: A #GBusType.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: A bus name (well-known or unique).
+ * @object_path: An object path.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL
+ *
+ * Like gsd_accounts_user_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
+ *
+ * The calling thread is blocked until a reply is received.
+ *
+ * See gsd_accounts_user_proxy_new_for_bus() for the asynchronous version of this constructor.
+ *
+ * Returns: (transfer full) (type GsdAccountsUserProxy): The constructed proxy object or %NULL if @error is set.
+ */
+GsdAccountsUser *
+gsd_accounts_user_proxy_new_for_bus_sync (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error)
+{
+  GInitable *ret;
+  ret = g_initable_new (GSD_TYPE_ACCOUNTS_USER_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.freedesktop.Accounts.User", NULL);
+  if (ret != NULL)
+    return GSD_ACCOUNTS_USER (ret);
+  else
+    return NULL;
+}
+
+
+/* ------------------------------------------------------------------------ */
+
+/**
+ * GsdAccountsUserSkeleton:
+ *
+ * The #GsdAccountsUserSkeleton structure contains only private data and should only be accessed using the provided API.
+ */
+
+/**
+ * GsdAccountsUserSkeletonClass:
+ * @parent_class: The parent class.
+ *
+ * Class structure for #GsdAccountsUserSkeleton.
+ */
+
+struct _GsdAccountsUserSkeletonPrivate
+{
+  GValue *properties;
+  GList *changed_properties;
+  GSource *changed_properties_idle_source;
+  GMainContext *context;
+  GMutex lock;
+};
+
+static void
+_gsd_accounts_user_skeleton_handle_method_call (
+  GDBusConnection *connection G_GNUC_UNUSED,
+  const gchar *sender G_GNUC_UNUSED,
+  const gchar *object_path G_GNUC_UNUSED,
+  const gchar *interface_name,
+  const gchar *method_name,
+  GVariant *parameters,
+  GDBusMethodInvocation *invocation,
+  gpointer user_data)
+{
+  GsdAccountsUserSkeleton *skeleton = GSD_ACCOUNTS_USER_SKELETON (user_data);
+  _ExtendedGDBusMethodInfo *info;
+  GVariantIter iter;
+  GVariant *child;
+  GValue *paramv;
+  gsize num_params;
+  guint num_extra;
+  gsize n;
+  guint signal_id;
+  GValue return_value = G_VALUE_INIT;
+  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
+  g_assert (info != NULL);
+  num_params = g_variant_n_children (parameters);
+  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
+  n = 0;
+  g_value_init (&paramv[n], GSD_TYPE_ACCOUNTS_USER);
+  g_value_set_object (&paramv[n++], skeleton);
+  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
+  g_value_set_object (&paramv[n++], invocation);
+  if (info->pass_fdlist)
+    {
+#ifdef G_OS_UNIX
+      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
+      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
+#else
+      g_assert_not_reached ();
+#endif
+    }
+  g_variant_iter_init (&iter, parameters);
+  while ((child = g_variant_iter_next_value (&iter)) != NULL)
+    {
+      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
+      if (arg_info->use_gvariant)
+        {
+          g_value_init (&paramv[n], G_TYPE_VARIANT);
+          g_value_set_variant (&paramv[n], child);
+          n++;
+        }
+      else
+        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
+      g_variant_unref (child);
+    }
+  signal_id = g_signal_lookup (info->signal_name, GSD_TYPE_ACCOUNTS_USER);
+  g_value_init (&return_value, G_TYPE_BOOLEAN);
+  g_signal_emitv (paramv, signal_id, 0, &return_value);
+  if (!g_value_get_boolean (&return_value))
+    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
+  g_value_unset (&return_value);
+  for (n = 0; n < num_params + num_extra; n++)
+    g_value_unset (&paramv[n]);
+  g_free (paramv);
+}
+
+static GVariant *
+_gsd_accounts_user_skeleton_handle_get_property (
+  GDBusConnection *connection G_GNUC_UNUSED,
+  const gchar *sender G_GNUC_UNUSED,
+  const gchar *object_path G_GNUC_UNUSED,
+  const gchar *interface_name G_GNUC_UNUSED,
+  const gchar *property_name,
+  GError **error,
+  gpointer user_data)
+{
+  GsdAccountsUserSkeleton *skeleton = GSD_ACCOUNTS_USER_SKELETON (user_data);
+  GValue value = G_VALUE_INIT;
+  GParamSpec *pspec;
+  _ExtendedGDBusPropertyInfo *info;
+  GVariant *ret;
+  ret = NULL;
+  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_gsd_accounts_user_interface_info.parent_struct, property_name);
+  g_assert (info != NULL);
+  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
+  if (pspec == NULL)
+    {
+      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
+    }
+  else
+    {
+      g_value_init (&value, pspec->value_type);
+      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
+      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
+      g_value_unset (&value);
+    }
+  return ret;
+}
+
+static gboolean
+_gsd_accounts_user_skeleton_handle_set_property (
+  GDBusConnection *connection G_GNUC_UNUSED,
+  const gchar *sender G_GNUC_UNUSED,
+  const gchar *object_path G_GNUC_UNUSED,
+  const gchar *interface_name G_GNUC_UNUSED,
+  const gchar *property_name,
+  GVariant *variant,
+  GError **error,
+  gpointer user_data)
+{
+  GsdAccountsUserSkeleton *skeleton = GSD_ACCOUNTS_USER_SKELETON (user_data);
+  GValue value = G_VALUE_INIT;
+  GParamSpec *pspec;
+  _ExtendedGDBusPropertyInfo *info;
+  gboolean ret;
+  ret = FALSE;
+  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_gsd_accounts_user_interface_info.parent_struct, property_name);
+  g_assert (info != NULL);
+  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
+  if (pspec == NULL)
+    {
+      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
+    }
+  else
+    {
+      if (info->use_gvariant)
+        g_value_set_variant (&value, variant);
+      else
+        g_dbus_gvariant_to_gvalue (variant, &value);
+      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
+      g_value_unset (&value);
+      ret = TRUE;
+    }
+  return ret;
+}
+
+static const GDBusInterfaceVTable _gsd_accounts_user_skeleton_vtable =
+{
+  _gsd_accounts_user_skeleton_handle_method_call,
+  _gsd_accounts_user_skeleton_handle_get_property,
+  _gsd_accounts_user_skeleton_handle_set_property,
+  {NULL}
+};
+
+static GDBusInterfaceInfo *
+gsd_accounts_user_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
+{
+  return gsd_accounts_user_interface_info ();
+}
+
+static GDBusInterfaceVTable *
+gsd_accounts_user_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
+{
+  return (GDBusInterfaceVTable *) &_gsd_accounts_user_skeleton_vtable;
+}
+
+static GVariant *
+gsd_accounts_user_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
+{
+  GsdAccountsUserSkeleton *skeleton = GSD_ACCOUNTS_USER_SKELETON (_skeleton);
+
+  GVariantBuilder builder;
+  guint n;
+  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
+  if (_gsd_accounts_user_interface_info.parent_struct.properties == NULL)
+    goto out;
+  for (n = 0; _gsd_accounts_user_interface_info.parent_struct.properties[n] != NULL; n++)
+    {
+      GDBusPropertyInfo *info = _gsd_accounts_user_interface_info.parent_struct.properties[n];
+      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
+        {
+          GVariant *value;
+          value = _gsd_accounts_user_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.freedesktop.Accounts.User", info->name, NULL, skeleton);
+          if (value != NULL)
+            {
+              g_variant_take_ref (value);
+              g_variant_builder_add (&builder, "{sv}", info->name, value);
+              g_variant_unref (value);
+            }
+        }
+    }
+out:
+  return g_variant_builder_end (&builder);
+}
+
+static gboolean _gsd_accounts_user_emit_changed (gpointer user_data);
+
+static void
+gsd_accounts_user_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
+{
+  GsdAccountsUserSkeleton *skeleton = GSD_ACCOUNTS_USER_SKELETON (_skeleton);
+  gboolean emit_changed = FALSE;
+
+  g_mutex_lock (&skeleton->priv->lock);
+  if (skeleton->priv->changed_properties_idle_source != NULL)
+    {
+      g_source_destroy (skeleton->priv->changed_properties_idle_source);
+      skeleton->priv->changed_properties_idle_source = NULL;
+      emit_changed = TRUE;
+    }
+  g_mutex_unlock (&skeleton->priv->lock);
+
+  if (emit_changed)
+    _gsd_accounts_user_emit_changed (skeleton);
+}
+
+static void
+_gsd_accounts_user_on_signal_changed (
+    GsdAccountsUser *object)
+{
+  GsdAccountsUserSkeleton *skeleton = GSD_ACCOUNTS_USER_SKELETON (object);
+
+  GList      *connections, *l;
+  GVariant   *signal_variant;
+  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
+
+  signal_variant = g_variant_ref_sink (g_variant_new ("()"));
+  for (l = connections; l != NULL; l = l->next)
+    {
+      GDBusConnection *connection = l->data;
+      g_dbus_connection_emit_signal (connection,
+        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.freedesktop.Accounts.User", "Changed",
+        signal_variant, NULL);
+    }
+  g_variant_unref (signal_variant);
+  g_list_free_full (connections, g_object_unref);
+}
+
+static void gsd_accounts_user_skeleton_iface_init (GsdAccountsUserIface *iface);
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+G_DEFINE_TYPE_WITH_CODE (GsdAccountsUserSkeleton, gsd_accounts_user_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
+                         G_ADD_PRIVATE (GsdAccountsUserSkeleton)
+                         G_IMPLEMENT_INTERFACE (GSD_TYPE_ACCOUNTS_USER, gsd_accounts_user_skeleton_iface_init))
+
+#else
+G_DEFINE_TYPE_WITH_CODE (GsdAccountsUserSkeleton, gsd_accounts_user_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
+                         G_IMPLEMENT_INTERFACE (GSD_TYPE_ACCOUNTS_USER, gsd_accounts_user_skeleton_iface_init))
+
+#endif
+static void
+gsd_accounts_user_skeleton_finalize (GObject *object)
+{
+  GsdAccountsUserSkeleton *skeleton = GSD_ACCOUNTS_USER_SKELETON (object);
+  guint n;
+  for (n = 0; n < 20; n++)
+    g_value_unset (&skeleton->priv->properties[n]);
+  g_free (skeleton->priv->properties);
+  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
+  if (skeleton->priv->changed_properties_idle_source != NULL)
+    g_source_destroy (skeleton->priv->changed_properties_idle_source);
+  g_main_context_unref (skeleton->priv->context);
+  g_mutex_clear (&skeleton->priv->lock);
+  G_OBJECT_CLASS (gsd_accounts_user_skeleton_parent_class)->finalize (object);
+}
+
+static void
+gsd_accounts_user_skeleton_get_property (GObject      *object,
+  guint         prop_id,
+  GValue       *value,
+  GParamSpec   *pspec G_GNUC_UNUSED)
+{
+  GsdAccountsUserSkeleton *skeleton = GSD_ACCOUNTS_USER_SKELETON (object);
+  g_assert (prop_id != 0 && prop_id - 1 < 20);
+  g_mutex_lock (&skeleton->priv->lock);
+  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
+  g_mutex_unlock (&skeleton->priv->lock);
+}
+
+static gboolean
+_gsd_accounts_user_emit_changed (gpointer user_data)
+{
+  GsdAccountsUserSkeleton *skeleton = GSD_ACCOUNTS_USER_SKELETON (user_data);
+  GList *l;
+  GVariantBuilder builder;
+  GVariantBuilder invalidated_builder;
+  guint num_changes;
+
+  g_mutex_lock (&skeleton->priv->lock);
+  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
+  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
+  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
+    {
+      ChangedProperty *cp = l->data;
+      GVariant *variant;
+      const GValue *cur_value;
+
+      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
+      if (!_g_value_equal (cur_value, &cp->orig_value))
+        {
+          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
+          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
+          g_variant_unref (variant);
+          num_changes++;
+        }
+    }
+  if (num_changes > 0)
+    {
+      GList *connections, *ll;
+      GVariant *signal_variant;
+      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "org.freedesktop.Accounts.User",
+                                           &builder, &invalidated_builder));
+      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
+      for (ll = connections; ll != NULL; ll = ll->next)
+        {
+          GDBusConnection *connection = ll->data;
+
+          g_dbus_connection_emit_signal (connection,
+                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
+                                         "org.freedesktop.DBus.Properties",
+                                         "PropertiesChanged",
+                                         signal_variant,
+                                         NULL);
+        }
+      g_variant_unref (signal_variant);
+      g_list_free_full (connections, g_object_unref);
+    }
+  else
+    {
+      g_variant_builder_clear (&builder);
+      g_variant_builder_clear (&invalidated_builder);
+    }
+  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
+  skeleton->priv->changed_properties = NULL;
+  skeleton->priv->changed_properties_idle_source = NULL;
+  g_mutex_unlock (&skeleton->priv->lock);
+  return FALSE;
+}
+
+static void
+_gsd_accounts_user_schedule_emit_changed (GsdAccountsUserSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
+{
+  ChangedProperty *cp;
+  GList *l;
+  cp = NULL;
+  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
+    {
+      ChangedProperty *i_cp = l->data;
+      if (i_cp->info == info)
+        {
+          cp = i_cp;
+          break;
+        }
+    }
+  if (cp == NULL)
+    {
+      cp = g_new0 (ChangedProperty, 1);
+      cp->prop_id = prop_id;
+      cp->info = info;
+      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
+      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
+      g_value_copy (orig_value, &cp->orig_value);
+    }
+}
+
+static void
+gsd_accounts_user_skeleton_notify (GObject      *object,
+  GParamSpec *pspec G_GNUC_UNUSED)
+{
+  GsdAccountsUserSkeleton *skeleton = GSD_ACCOUNTS_USER_SKELETON (object);
+  g_mutex_lock (&skeleton->priv->lock);
+  if (skeleton->priv->changed_properties != NULL &&
+      skeleton->priv->changed_properties_idle_source == NULL)
+    {
+      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
+      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
+      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _gsd_accounts_user_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
+      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _gsd_accounts_user_emit_changed");
+      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
+      g_source_unref (skeleton->priv->changed_properties_idle_source);
+    }
+  g_mutex_unlock (&skeleton->priv->lock);
+}
+
+static void
+gsd_accounts_user_skeleton_set_property (GObject      *object,
+  guint         prop_id,
+  const GValue *value,
+  GParamSpec   *pspec)
+{
+  GsdAccountsUserSkeleton *skeleton = GSD_ACCOUNTS_USER_SKELETON (object);
+  g_assert (prop_id != 0 && prop_id - 1 < 20);
+  g_mutex_lock (&skeleton->priv->lock);
+  g_object_freeze_notify (object);
+  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
+    {
+      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
+        _gsd_accounts_user_schedule_emit_changed (skeleton, _gsd_accounts_user_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties[prop_id - 1]);
+      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
+      g_object_notify_by_pspec (object, pspec);
+    }
+  g_mutex_unlock (&skeleton->priv->lock);
+  g_object_thaw_notify (object);
+}
+
+static void
+gsd_accounts_user_skeleton_init (GsdAccountsUserSkeleton *skeleton)
+{
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+  skeleton->priv = gsd_accounts_user_skeleton_get_instance_private (skeleton);
+#else
+  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, GSD_TYPE_ACCOUNTS_USER_SKELETON, GsdAccountsUserSkeletonPrivate);
+#endif
+
+  g_mutex_init (&skeleton->priv->lock);
+  skeleton->priv->context = g_main_context_ref_thread_default ();
+  skeleton->priv->properties = g_new0 (GValue, 20);
+  g_value_init (&skeleton->priv->properties[0], G_TYPE_UINT64);
+  g_value_init (&skeleton->priv->properties[1], G_TYPE_STRING);
+  g_value_init (&skeleton->priv->properties[2], G_TYPE_STRING);
+  g_value_init (&skeleton->priv->properties[3], G_TYPE_INT);
+  g_value_init (&skeleton->priv->properties[4], G_TYPE_STRING);
+  g_value_init (&skeleton->priv->properties[5], G_TYPE_STRING);
+  g_value_init (&skeleton->priv->properties[6], G_TYPE_STRING);
+  g_value_init (&skeleton->priv->properties[7], G_TYPE_STRING);
+  g_value_init (&skeleton->priv->properties[8], G_TYPE_STRING);
+  g_value_init (&skeleton->priv->properties[9], G_TYPE_STRING);
+  g_value_init (&skeleton->priv->properties[10], G_TYPE_UINT64);
+  g_value_init (&skeleton->priv->properties[11], G_TYPE_INT64);
+  g_value_init (&skeleton->priv->properties[12], G_TYPE_VARIANT);
+  g_value_init (&skeleton->priv->properties[13], G_TYPE_STRING);
+  g_value_init (&skeleton->priv->properties[14], G_TYPE_BOOLEAN);
+  g_value_init (&skeleton->priv->properties[15], G_TYPE_INT);
+  g_value_init (&skeleton->priv->properties[16], G_TYPE_STRING);
+  g_value_init (&skeleton->priv->properties[17], G_TYPE_BOOLEAN);
+  g_value_init (&skeleton->priv->properties[18], G_TYPE_BOOLEAN);
+  g_value_init (&skeleton->priv->properties[19], G_TYPE_BOOLEAN);
+}
+
+static guint64
+gsd_accounts_user_skeleton_get_uid (GsdAccountsUser *object)
+{
+  GsdAccountsUserSkeleton *skeleton = GSD_ACCOUNTS_USER_SKELETON (object);
+  guint64 value;
+  g_mutex_lock (&skeleton->priv->lock);
+  value = g_value_get_uint64 (&(skeleton->priv->properties[0]));
+  g_mutex_unlock (&skeleton->priv->lock);
+  return value;
+}
+
+static const gchar *
+gsd_accounts_user_skeleton_get_user_name (GsdAccountsUser *object)
+{
+  GsdAccountsUserSkeleton *skeleton = GSD_ACCOUNTS_USER_SKELETON (object);
+  const gchar *value;
+  g_mutex_lock (&skeleton->priv->lock);
+  value = g_value_get_string (&(skeleton->priv->properties[1]));
+  g_mutex_unlock (&skeleton->priv->lock);
+  return value;
+}
+
+static const gchar *
+gsd_accounts_user_skeleton_get_real_name (GsdAccountsUser *object)
+{
+  GsdAccountsUserSkeleton *skeleton = GSD_ACCOUNTS_USER_SKELETON (object);
+  const gchar *value;
+  g_mutex_lock (&skeleton->priv->lock);
+  value = g_value_get_string (&(skeleton->priv->properties[2]));
+  g_mutex_unlock (&skeleton->priv->lock);
+  return value;
+}
+
+static gint
+gsd_accounts_user_skeleton_get_account_type (GsdAccountsUser *object)
+{
+  GsdAccountsUserSkeleton *skeleton = GSD_ACCOUNTS_USER_SKELETON (object);
+  gint value;
+  g_mutex_lock (&skeleton->priv->lock);
+  value = g_value_get_int (&(skeleton->priv->properties[3]));
+  g_mutex_unlock (&skeleton->priv->lock);
+  return value;
+}
+
+static const gchar *
+gsd_accounts_user_skeleton_get_home_directory (GsdAccountsUser *object)
+{
+  GsdAccountsUserSkeleton *skeleton = GSD_ACCOUNTS_USER_SKELETON (object);
+  const gchar *value;
+  g_mutex_lock (&skeleton->priv->lock);
+  value = g_value_get_string (&(skeleton->priv->properties[4]));
+  g_mutex_unlock (&skeleton->priv->lock);
+  return value;
+}
+
+static const gchar *
+gsd_accounts_user_skeleton_get_shell (GsdAccountsUser *object)
+{
+  GsdAccountsUserSkeleton *skeleton = GSD_ACCOUNTS_USER_SKELETON (object);
+  const gchar *value;
+  g_mutex_lock (&skeleton->priv->lock);
+  value = g_value_get_string (&(skeleton->priv->properties[5]));
+  g_mutex_unlock (&skeleton->priv->lock);
+  return value;
+}
+
+static const gchar *
+gsd_accounts_user_skeleton_get_email (GsdAccountsUser *object)
+{
+  GsdAccountsUserSkeleton *skeleton = GSD_ACCOUNTS_USER_SKELETON (object);
+  const gchar *value;
+  g_mutex_lock (&skeleton->priv->lock);
+  value = g_value_get_string (&(skeleton->priv->properties[6]));
+  g_mutex_unlock (&skeleton->priv->lock);
+  return value;
+}
+
+static const gchar *
+gsd_accounts_user_skeleton_get_language (GsdAccountsUser *object)
+{
+  GsdAccountsUserSkeleton *skeleton = GSD_ACCOUNTS_USER_SKELETON (object);
+  const gchar *value;
+  g_mutex_lock (&skeleton->priv->lock);
+  value = g_value_get_string (&(skeleton->priv->properties[7]));
+  g_mutex_unlock (&skeleton->priv->lock);
+  return value;
+}
+
+static const gchar *
+gsd_accounts_user_skeleton_get_xsession (GsdAccountsUser *object)
+{
+  GsdAccountsUserSkeleton *skeleton = GSD_ACCOUNTS_USER_SKELETON (object);
+  const gchar *value;
+  g_mutex_lock (&skeleton->priv->lock);
+  value = g_value_get_string (&(skeleton->priv->properties[8]));
+  g_mutex_unlock (&skeleton->priv->lock);
+  return value;
+}
+
+static const gchar *
+gsd_accounts_user_skeleton_get_location (GsdAccountsUser *object)
+{
+  GsdAccountsUserSkeleton *skeleton = GSD_ACCOUNTS_USER_SKELETON (object);
+  const gchar *value;
+  g_mutex_lock (&skeleton->priv->lock);
+  value = g_value_get_string (&(skeleton->priv->properties[9]));
+  g_mutex_unlock (&skeleton->priv->lock);
+  return value;
+}
+
+static guint64
+gsd_accounts_user_skeleton_get_login_frequency (GsdAccountsUser *object)
+{
+  GsdAccountsUserSkeleton *skeleton = GSD_ACCOUNTS_USER_SKELETON (object);
+  guint64 value;
+  g_mutex_lock (&skeleton->priv->lock);
+  value = g_value_get_uint64 (&(skeleton->priv->properties[10]));
+  g_mutex_unlock (&skeleton->priv->lock);
+  return value;
+}
+
+static gint64
+gsd_accounts_user_skeleton_get_login_time (GsdAccountsUser *object)
+{
+  GsdAccountsUserSkeleton *skeleton = GSD_ACCOUNTS_USER_SKELETON (object);
+  gint64 value;
+  g_mutex_lock (&skeleton->priv->lock);
+  value = g_value_get_int64 (&(skeleton->priv->properties[11]));
+  g_mutex_unlock (&skeleton->priv->lock);
+  return value;
+}
+
+static GVariant *
+gsd_accounts_user_skeleton_get_login_history (GsdAccountsUser *object)
+{
+  GsdAccountsUserSkeleton *skeleton = GSD_ACCOUNTS_USER_SKELETON (object);
+  GVariant *value;
+  g_mutex_lock (&skeleton->priv->lock);
+  value = g_value_get_variant (&(skeleton->priv->properties[12]));
+  g_mutex_unlock (&skeleton->priv->lock);
+  return value;
+}
+
+static const gchar *
+gsd_accounts_user_skeleton_get_icon_file (GsdAccountsUser *object)
+{
+  GsdAccountsUserSkeleton *skeleton = GSD_ACCOUNTS_USER_SKELETON (object);
+  const gchar *value;
+  g_mutex_lock (&skeleton->priv->lock);
+  value = g_value_get_string (&(skeleton->priv->properties[13]));
+  g_mutex_unlock (&skeleton->priv->lock);
+  return value;
+}
+
+static gboolean
+gsd_accounts_user_skeleton_get_locked (GsdAccountsUser *object)
+{
+  GsdAccountsUserSkeleton *skeleton = GSD_ACCOUNTS_USER_SKELETON (object);
+  gboolean value;
+  g_mutex_lock (&skeleton->priv->lock);
+  value = g_value_get_boolean (&(skeleton->priv->properties[14]));
+  g_mutex_unlock (&skeleton->priv->lock);
+  return value;
+}
+
+static gint
+gsd_accounts_user_skeleton_get_password_mode (GsdAccountsUser *object)
+{
+  GsdAccountsUserSkeleton *skeleton = GSD_ACCOUNTS_USER_SKELETON (object);
+  gint value;
+  g_mutex_lock (&skeleton->priv->lock);
+  value = g_value_get_int (&(skeleton->priv->properties[15]));
+  g_mutex_unlock (&skeleton->priv->lock);
+  return value;
+}
+
+static const gchar *
+gsd_accounts_user_skeleton_get_password_hint (GsdAccountsUser *object)
+{
+  GsdAccountsUserSkeleton *skeleton = GSD_ACCOUNTS_USER_SKELETON (object);
+  const gchar *value;
+  g_mutex_lock (&skeleton->priv->lock);
+  value = g_value_get_string (&(skeleton->priv->properties[16]));
+  g_mutex_unlock (&skeleton->priv->lock);
+  return value;
+}
+
+static gboolean
+gsd_accounts_user_skeleton_get_automatic_login (GsdAccountsUser *object)
+{
+  GsdAccountsUserSkeleton *skeleton = GSD_ACCOUNTS_USER_SKELETON (object);
+  gboolean value;
+  g_mutex_lock (&skeleton->priv->lock);
+  value = g_value_get_boolean (&(skeleton->priv->properties[17]));
+  g_mutex_unlock (&skeleton->priv->lock);
+  return value;
+}
+
+static gboolean
+gsd_accounts_user_skeleton_get_system_account (GsdAccountsUser *object)
+{
+  GsdAccountsUserSkeleton *skeleton = GSD_ACCOUNTS_USER_SKELETON (object);
+  gboolean value;
+  g_mutex_lock (&skeleton->priv->lock);
+  value = g_value_get_boolean (&(skeleton->priv->properties[18]));
+  g_mutex_unlock (&skeleton->priv->lock);
+  return value;
+}
+
+static gboolean
+gsd_accounts_user_skeleton_get_local_account (GsdAccountsUser *object)
+{
+  GsdAccountsUserSkeleton *skeleton = GSD_ACCOUNTS_USER_SKELETON (object);
+  gboolean value;
+  g_mutex_lock (&skeleton->priv->lock);
+  value = g_value_get_boolean (&(skeleton->priv->properties[19]));
+  g_mutex_unlock (&skeleton->priv->lock);
+  return value;
+}
+
+static void
+gsd_accounts_user_skeleton_class_init (GsdAccountsUserSkeletonClass *klass)
+{
+  GObjectClass *gobject_class;
+  GDBusInterfaceSkeletonClass *skeleton_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  gobject_class->finalize = gsd_accounts_user_skeleton_finalize;
+  gobject_class->get_property = gsd_accounts_user_skeleton_get_property;
+  gobject_class->set_property = gsd_accounts_user_skeleton_set_property;
+  gobject_class->notify       = gsd_accounts_user_skeleton_notify;
+
+
+  gsd_accounts_user_override_properties (gobject_class, 1);
+
+  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
+  skeleton_class->get_info = gsd_accounts_user_skeleton_dbus_interface_get_info;
+  skeleton_class->get_properties = gsd_accounts_user_skeleton_dbus_interface_get_properties;
+  skeleton_class->flush = gsd_accounts_user_skeleton_dbus_interface_flush;
+  skeleton_class->get_vtable = gsd_accounts_user_skeleton_dbus_interface_get_vtable;
+
+#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
+  g_type_class_add_private (klass, sizeof (GsdAccountsUserSkeletonPrivate));
+#endif
+}
+
+static void
+gsd_accounts_user_skeleton_iface_init (GsdAccountsUserIface *iface)
+{
+  iface->changed = _gsd_accounts_user_on_signal_changed;
+  iface->get_uid = gsd_accounts_user_skeleton_get_uid;
+  iface->get_user_name = gsd_accounts_user_skeleton_get_user_name;
+  iface->get_real_name = gsd_accounts_user_skeleton_get_real_name;
+  iface->get_account_type = gsd_accounts_user_skeleton_get_account_type;
+  iface->get_home_directory = gsd_accounts_user_skeleton_get_home_directory;
+  iface->get_shell = gsd_accounts_user_skeleton_get_shell;
+  iface->get_email = gsd_accounts_user_skeleton_get_email;
+  iface->get_language = gsd_accounts_user_skeleton_get_language;
+  iface->get_xsession = gsd_accounts_user_skeleton_get_xsession;
+  iface->get_location = gsd_accounts_user_skeleton_get_location;
+  iface->get_login_frequency = gsd_accounts_user_skeleton_get_login_frequency;
+  iface->get_login_time = gsd_accounts_user_skeleton_get_login_time;
+  iface->get_login_history = gsd_accounts_user_skeleton_get_login_history;
+  iface->get_icon_file = gsd_accounts_user_skeleton_get_icon_file;
+  iface->get_locked = gsd_accounts_user_skeleton_get_locked;
+  iface->get_password_mode = gsd_accounts_user_skeleton_get_password_mode;
+  iface->get_password_hint = gsd_accounts_user_skeleton_get_password_hint;
+  iface->get_automatic_login = gsd_accounts_user_skeleton_get_automatic_login;
+  iface->get_system_account = gsd_accounts_user_skeleton_get_system_account;
+  iface->get_local_account = gsd_accounts_user_skeleton_get_local_account;
+}
+
+/**
+ * gsd_accounts_user_skeleton_new:
+ *
+ * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-Accounts-User.top_of_page">org.freedesktop.Accounts.User</link>.
+ *
+ * Returns: (transfer full) (type GsdAccountsUserSkeleton): The skeleton object.
+ */
+GsdAccountsUser *
+gsd_accounts_user_skeleton_new (void)
+{
+  return GSD_ACCOUNTS_USER (g_object_new (GSD_TYPE_ACCOUNTS_USER_SKELETON, NULL));
+}
diff --git a/plugins/account/org.freedesktop.Accounts.User.h b/plugins/account/org.freedesktop.Accounts.User.h
new file mode 100644
index 00000000..f5a0ca0f
--- /dev/null
+++ b/plugins/account/org.freedesktop.Accounts.User.h
@@ -0,0 +1,725 @@
+/*
+ * Generated by gdbus-codegen 2.54.1. DO NOT EDIT.
+ *
+ * The license of this code is the same as for the source it was derived from.
+ */
+
+#ifndef __ORG_FREEDESKTOP_ACCOUNTS_USER_H__
+#define __ORG_FREEDESKTOP_ACCOUNTS_USER_H__
+
+#include <gio/gio.h>
+
+G_BEGIN_DECLS
+
+
+/* ------------------------------------------------------------------------ */
+/* Declarations for org.freedesktop.Accounts.User */
+
+#define GSD_TYPE_ACCOUNTS_USER (gsd_accounts_user_get_type ())
+#define GSD_ACCOUNTS_USER(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), GSD_TYPE_ACCOUNTS_USER, GsdAccountsUser))
+#define GSD_IS_ACCOUNTS_USER(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), GSD_TYPE_ACCOUNTS_USER))
+#define GSD_ACCOUNTS_USER_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), GSD_TYPE_ACCOUNTS_USER, GsdAccountsUserIface))
+
+struct _GsdAccountsUser;
+typedef struct _GsdAccountsUser GsdAccountsUser;
+typedef struct _GsdAccountsUserIface GsdAccountsUserIface;
+
+struct _GsdAccountsUserIface
+{
+  GTypeInterface parent_iface;
+
+
+
+  gboolean (*handle_get_password_expiration_policy) (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation);
+
+  gboolean (*handle_set_account_type) (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation,
+    gint arg_accountType);
+
+  gboolean (*handle_set_automatic_login) (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation,
+    gboolean arg_enabled);
+
+  gboolean (*handle_set_email) (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *arg_email);
+
+  gboolean (*handle_set_home_directory) (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *arg_homedir);
+
+  gboolean (*handle_set_icon_file) (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *arg_filename);
+
+  gboolean (*handle_set_language) (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *arg_language);
+
+  gboolean (*handle_set_location) (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *arg_location);
+
+  gboolean (*handle_set_locked) (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation,
+    gboolean arg_locked);
+
+  gboolean (*handle_set_password) (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *arg_password,
+    const gchar *arg_hint);
+
+  gboolean (*handle_set_password_hint) (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *arg_hint);
+
+  gboolean (*handle_set_password_mode) (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation,
+    gint arg_mode);
+
+  gboolean (*handle_set_real_name) (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *arg_name);
+
+  gboolean (*handle_set_shell) (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *arg_shell);
+
+  gboolean (*handle_set_user_name) (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *arg_name);
+
+  gboolean (*handle_set_xsession) (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *arg_x_session);
+
+  gint  (*get_account_type) (GsdAccountsUser *object);
+
+  gboolean  (*get_automatic_login) (GsdAccountsUser *object);
+
+  const gchar * (*get_email) (GsdAccountsUser *object);
+
+  const gchar * (*get_home_directory) (GsdAccountsUser *object);
+
+  const gchar * (*get_icon_file) (GsdAccountsUser *object);
+
+  const gchar * (*get_language) (GsdAccountsUser *object);
+
+  gboolean  (*get_local_account) (GsdAccountsUser *object);
+
+  const gchar * (*get_location) (GsdAccountsUser *object);
+
+  gboolean  (*get_locked) (GsdAccountsUser *object);
+
+  guint64  (*get_login_frequency) (GsdAccountsUser *object);
+
+  GVariant * (*get_login_history) (GsdAccountsUser *object);
+
+  gint64  (*get_login_time) (GsdAccountsUser *object);
+
+  const gchar * (*get_password_hint) (GsdAccountsUser *object);
+
+  gint  (*get_password_mode) (GsdAccountsUser *object);
+
+  const gchar * (*get_real_name) (GsdAccountsUser *object);
+
+  const gchar * (*get_shell) (GsdAccountsUser *object);
+
+  gboolean  (*get_system_account) (GsdAccountsUser *object);
+
+  guint64  (*get_uid) (GsdAccountsUser *object);
+
+  const gchar * (*get_user_name) (GsdAccountsUser *object);
+
+  const gchar * (*get_xsession) (GsdAccountsUser *object);
+
+  void (*changed) (
+    GsdAccountsUser *object);
+
+};
+
+GType gsd_accounts_user_get_type (void) G_GNUC_CONST;
+
+GDBusInterfaceInfo *gsd_accounts_user_interface_info (void);
+guint gsd_accounts_user_override_properties (GObjectClass *klass, guint property_id_begin);
+
+
+/* D-Bus method call completion functions: */
+void gsd_accounts_user_complete_set_user_name (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation);
+
+void gsd_accounts_user_complete_set_real_name (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation);
+
+void gsd_accounts_user_complete_set_email (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation);
+
+void gsd_accounts_user_complete_set_language (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation);
+
+void gsd_accounts_user_complete_set_xsession (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation);
+
+void gsd_accounts_user_complete_set_location (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation);
+
+void gsd_accounts_user_complete_set_home_directory (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation);
+
+void gsd_accounts_user_complete_set_shell (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation);
+
+void gsd_accounts_user_complete_set_icon_file (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation);
+
+void gsd_accounts_user_complete_set_locked (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation);
+
+void gsd_accounts_user_complete_set_account_type (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation);
+
+void gsd_accounts_user_complete_set_password_mode (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation);
+
+void gsd_accounts_user_complete_set_password (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation);
+
+void gsd_accounts_user_complete_set_password_hint (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation);
+
+void gsd_accounts_user_complete_set_automatic_login (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation);
+
+void gsd_accounts_user_complete_get_password_expiration_policy (
+    GsdAccountsUser *object,
+    GDBusMethodInvocation *invocation,
+    gint64 expiration_time,
+    gint64 last_change_time,
+    gint64 min_days_between_changes,
+    gint64 max_days_between_changes,
+    gint64 days_to_warn,
+    gint64 days_after_expiration_until_lock);
+
+
+
+/* D-Bus signal emissions functions: */
+void gsd_accounts_user_emit_changed (
+    GsdAccountsUser *object);
+
+
+
+/* D-Bus method calls: */
+void gsd_accounts_user_call_set_user_name (
+    GsdAccountsUser *proxy,
+    const gchar *arg_name,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean gsd_accounts_user_call_set_user_name_finish (
+    GsdAccountsUser *proxy,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean gsd_accounts_user_call_set_user_name_sync (
+    GsdAccountsUser *proxy,
+    const gchar *arg_name,
+    GCancellable *cancellable,
+    GError **error);
+
+void gsd_accounts_user_call_set_real_name (
+    GsdAccountsUser *proxy,
+    const gchar *arg_name,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean gsd_accounts_user_call_set_real_name_finish (
+    GsdAccountsUser *proxy,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean gsd_accounts_user_call_set_real_name_sync (
+    GsdAccountsUser *proxy,
+    const gchar *arg_name,
+    GCancellable *cancellable,
+    GError **error);
+
+void gsd_accounts_user_call_set_email (
+    GsdAccountsUser *proxy,
+    const gchar *arg_email,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean gsd_accounts_user_call_set_email_finish (
+    GsdAccountsUser *proxy,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean gsd_accounts_user_call_set_email_sync (
+    GsdAccountsUser *proxy,
+    const gchar *arg_email,
+    GCancellable *cancellable,
+    GError **error);
+
+void gsd_accounts_user_call_set_language (
+    GsdAccountsUser *proxy,
+    const gchar *arg_language,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean gsd_accounts_user_call_set_language_finish (
+    GsdAccountsUser *proxy,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean gsd_accounts_user_call_set_language_sync (
+    GsdAccountsUser *proxy,
+    const gchar *arg_language,
+    GCancellable *cancellable,
+    GError **error);
+
+void gsd_accounts_user_call_set_xsession (
+    GsdAccountsUser *proxy,
+    const gchar *arg_x_session,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean gsd_accounts_user_call_set_xsession_finish (
+    GsdAccountsUser *proxy,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean gsd_accounts_user_call_set_xsession_sync (
+    GsdAccountsUser *proxy,
+    const gchar *arg_x_session,
+    GCancellable *cancellable,
+    GError **error);
+
+void gsd_accounts_user_call_set_location (
+    GsdAccountsUser *proxy,
+    const gchar *arg_location,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean gsd_accounts_user_call_set_location_finish (
+    GsdAccountsUser *proxy,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean gsd_accounts_user_call_set_location_sync (
+    GsdAccountsUser *proxy,
+    const gchar *arg_location,
+    GCancellable *cancellable,
+    GError **error);
+
+void gsd_accounts_user_call_set_home_directory (
+    GsdAccountsUser *proxy,
+    const gchar *arg_homedir,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean gsd_accounts_user_call_set_home_directory_finish (
+    GsdAccountsUser *proxy,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean gsd_accounts_user_call_set_home_directory_sync (
+    GsdAccountsUser *proxy,
+    const gchar *arg_homedir,
+    GCancellable *cancellable,
+    GError **error);
+
+void gsd_accounts_user_call_set_shell (
+    GsdAccountsUser *proxy,
+    const gchar *arg_shell,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean gsd_accounts_user_call_set_shell_finish (
+    GsdAccountsUser *proxy,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean gsd_accounts_user_call_set_shell_sync (
+    GsdAccountsUser *proxy,
+    const gchar *arg_shell,
+    GCancellable *cancellable,
+    GError **error);
+
+void gsd_accounts_user_call_set_icon_file (
+    GsdAccountsUser *proxy,
+    const gchar *arg_filename,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean gsd_accounts_user_call_set_icon_file_finish (
+    GsdAccountsUser *proxy,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean gsd_accounts_user_call_set_icon_file_sync (
+    GsdAccountsUser *proxy,
+    const gchar *arg_filename,
+    GCancellable *cancellable,
+    GError **error);
+
+void gsd_accounts_user_call_set_locked (
+    GsdAccountsUser *proxy,
+    gboolean arg_locked,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean gsd_accounts_user_call_set_locked_finish (
+    GsdAccountsUser *proxy,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean gsd_accounts_user_call_set_locked_sync (
+    GsdAccountsUser *proxy,
+    gboolean arg_locked,
+    GCancellable *cancellable,
+    GError **error);
+
+void gsd_accounts_user_call_set_account_type (
+    GsdAccountsUser *proxy,
+    gint arg_accountType,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean gsd_accounts_user_call_set_account_type_finish (
+    GsdAccountsUser *proxy,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean gsd_accounts_user_call_set_account_type_sync (
+    GsdAccountsUser *proxy,
+    gint arg_accountType,
+    GCancellable *cancellable,
+    GError **error);
+
+void gsd_accounts_user_call_set_password_mode (
+    GsdAccountsUser *proxy,
+    gint arg_mode,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean gsd_accounts_user_call_set_password_mode_finish (
+    GsdAccountsUser *proxy,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean gsd_accounts_user_call_set_password_mode_sync (
+    GsdAccountsUser *proxy,
+    gint arg_mode,
+    GCancellable *cancellable,
+    GError **error);
+
+void gsd_accounts_user_call_set_password (
+    GsdAccountsUser *proxy,
+    const gchar *arg_password,
+    const gchar *arg_hint,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean gsd_accounts_user_call_set_password_finish (
+    GsdAccountsUser *proxy,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean gsd_accounts_user_call_set_password_sync (
+    GsdAccountsUser *proxy,
+    const gchar *arg_password,
+    const gchar *arg_hint,
+    GCancellable *cancellable,
+    GError **error);
+
+void gsd_accounts_user_call_set_password_hint (
+    GsdAccountsUser *proxy,
+    const gchar *arg_hint,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean gsd_accounts_user_call_set_password_hint_finish (
+    GsdAccountsUser *proxy,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean gsd_accounts_user_call_set_password_hint_sync (
+    GsdAccountsUser *proxy,
+    const gchar *arg_hint,
+    GCancellable *cancellable,
+    GError **error);
+
+void gsd_accounts_user_call_set_automatic_login (
+    GsdAccountsUser *proxy,
+    gboolean arg_enabled,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean gsd_accounts_user_call_set_automatic_login_finish (
+    GsdAccountsUser *proxy,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean gsd_accounts_user_call_set_automatic_login_sync (
+    GsdAccountsUser *proxy,
+    gboolean arg_enabled,
+    GCancellable *cancellable,
+    GError **error);
+
+void gsd_accounts_user_call_get_password_expiration_policy (
+    GsdAccountsUser *proxy,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean gsd_accounts_user_call_get_password_expiration_policy_finish (
+    GsdAccountsUser *proxy,
+    gint64 *out_expiration_time,
+    gint64 *out_last_change_time,
+    gint64 *out_min_days_between_changes,
+    gint64 *out_max_days_between_changes,
+    gint64 *out_days_to_warn,
+    gint64 *out_days_after_expiration_until_lock,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean gsd_accounts_user_call_get_password_expiration_policy_sync (
+    GsdAccountsUser *proxy,
+    gint64 *out_expiration_time,
+    gint64 *out_last_change_time,
+    gint64 *out_min_days_between_changes,
+    gint64 *out_max_days_between_changes,
+    gint64 *out_days_to_warn,
+    gint64 *out_days_after_expiration_until_lock,
+    GCancellable *cancellable,
+    GError **error);
+
+
+
+/* D-Bus property accessors: */
+guint64 gsd_accounts_user_get_uid (GsdAccountsUser *object);
+void gsd_accounts_user_set_uid (GsdAccountsUser *object, guint64 value);
+
+const gchar *gsd_accounts_user_get_user_name (GsdAccountsUser *object);
+gchar *gsd_accounts_user_dup_user_name (GsdAccountsUser *object);
+void gsd_accounts_user_set_user_name (GsdAccountsUser *object, const gchar *value);
+
+const gchar *gsd_accounts_user_get_real_name (GsdAccountsUser *object);
+gchar *gsd_accounts_user_dup_real_name (GsdAccountsUser *object);
+void gsd_accounts_user_set_real_name (GsdAccountsUser *object, const gchar *value);
+
+gint gsd_accounts_user_get_account_type (GsdAccountsUser *object);
+void gsd_accounts_user_set_account_type (GsdAccountsUser *object, gint value);
+
+const gchar *gsd_accounts_user_get_home_directory (GsdAccountsUser *object);
+gchar *gsd_accounts_user_dup_home_directory (GsdAccountsUser *object);
+void gsd_accounts_user_set_home_directory (GsdAccountsUser *object, const gchar *value);
+
+const gchar *gsd_accounts_user_get_shell (GsdAccountsUser *object);
+gchar *gsd_accounts_user_dup_shell (GsdAccountsUser *object);
+void gsd_accounts_user_set_shell (GsdAccountsUser *object, const gchar *value);
+
+const gchar *gsd_accounts_user_get_email (GsdAccountsUser *object);
+gchar *gsd_accounts_user_dup_email (GsdAccountsUser *object);
+void gsd_accounts_user_set_email (GsdAccountsUser *object, const gchar *value);
+
+const gchar *gsd_accounts_user_get_language (GsdAccountsUser *object);
+gchar *gsd_accounts_user_dup_language (GsdAccountsUser *object);
+void gsd_accounts_user_set_language (GsdAccountsUser *object, const gchar *value);
+
+const gchar *gsd_accounts_user_get_xsession (GsdAccountsUser *object);
+gchar *gsd_accounts_user_dup_xsession (GsdAccountsUser *object);
+void gsd_accounts_user_set_xsession (GsdAccountsUser *object, const gchar *value);
+
+const gchar *gsd_accounts_user_get_location (GsdAccountsUser *object);
+gchar *gsd_accounts_user_dup_location (GsdAccountsUser *object);
+void gsd_accounts_user_set_location (GsdAccountsUser *object, const gchar *value);
+
+guint64 gsd_accounts_user_get_login_frequency (GsdAccountsUser *object);
+void gsd_accounts_user_set_login_frequency (GsdAccountsUser *object, guint64 value);
+
+gint64 gsd_accounts_user_get_login_time (GsdAccountsUser *object);
+void gsd_accounts_user_set_login_time (GsdAccountsUser *object, gint64 value);
+
+GVariant *gsd_accounts_user_get_login_history (GsdAccountsUser *object);
+GVariant *gsd_accounts_user_dup_login_history (GsdAccountsUser *object);
+void gsd_accounts_user_set_login_history (GsdAccountsUser *object, GVariant *value);
+
+const gchar *gsd_accounts_user_get_icon_file (GsdAccountsUser *object);
+gchar *gsd_accounts_user_dup_icon_file (GsdAccountsUser *object);
+void gsd_accounts_user_set_icon_file (GsdAccountsUser *object, const gchar *value);
+
+gboolean gsd_accounts_user_get_locked (GsdAccountsUser *object);
+void gsd_accounts_user_set_locked (GsdAccountsUser *object, gboolean value);
+
+gint gsd_accounts_user_get_password_mode (GsdAccountsUser *object);
+void gsd_accounts_user_set_password_mode (GsdAccountsUser *object, gint value);
+
+const gchar *gsd_accounts_user_get_password_hint (GsdAccountsUser *object);
+gchar *gsd_accounts_user_dup_password_hint (GsdAccountsUser *object);
+void gsd_accounts_user_set_password_hint (GsdAccountsUser *object, const gchar *value);
+
+gboolean gsd_accounts_user_get_automatic_login (GsdAccountsUser *object);
+void gsd_accounts_user_set_automatic_login (GsdAccountsUser *object, gboolean value);
+
+gboolean gsd_accounts_user_get_system_account (GsdAccountsUser *object);
+void gsd_accounts_user_set_system_account (GsdAccountsUser *object, gboolean value);
+
+gboolean gsd_accounts_user_get_local_account (GsdAccountsUser *object);
+void gsd_accounts_user_set_local_account (GsdAccountsUser *object, gboolean value);
+
+
+/* ---- */
+
+#define GSD_TYPE_ACCOUNTS_USER_PROXY (gsd_accounts_user_proxy_get_type ())
+#define GSD_ACCOUNTS_USER_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), GSD_TYPE_ACCOUNTS_USER_PROXY, GsdAccountsUserProxy))
+#define GSD_ACCOUNTS_USER_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), GSD_TYPE_ACCOUNTS_USER_PROXY, GsdAccountsUserProxyClass))
+#define GSD_ACCOUNTS_USER_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GSD_TYPE_ACCOUNTS_USER_PROXY, GsdAccountsUserProxyClass))
+#define GSD_IS_ACCOUNTS_USER_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), GSD_TYPE_ACCOUNTS_USER_PROXY))
+#define GSD_IS_ACCOUNTS_USER_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), GSD_TYPE_ACCOUNTS_USER_PROXY))
+
+typedef struct _GsdAccountsUserProxy GsdAccountsUserProxy;
+typedef struct _GsdAccountsUserProxyClass GsdAccountsUserProxyClass;
+typedef struct _GsdAccountsUserProxyPrivate GsdAccountsUserProxyPrivate;
+
+struct _GsdAccountsUserProxy
+{
+  /*< private >*/
+  GDBusProxy parent_instance;
+  GsdAccountsUserProxyPrivate *priv;
+};
+
+struct _GsdAccountsUserProxyClass
+{
+  GDBusProxyClass parent_class;
+};
+
+GType gsd_accounts_user_proxy_get_type (void) G_GNUC_CONST;
+
+#if GLIB_CHECK_VERSION(2, 44, 0)
+G_DEFINE_AUTOPTR_CLEANUP_FUNC (GsdAccountsUserProxy, g_object_unref)
+#endif
+
+void gsd_accounts_user_proxy_new (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data);
+GsdAccountsUser *gsd_accounts_user_proxy_new_finish (
+    GAsyncResult        *res,
+    GError             **error);
+GsdAccountsUser *gsd_accounts_user_proxy_new_sync (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error);
+
+void gsd_accounts_user_proxy_new_for_bus (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data);
+GsdAccountsUser *gsd_accounts_user_proxy_new_for_bus_finish (
+    GAsyncResult        *res,
+    GError             **error);
+GsdAccountsUser *gsd_accounts_user_proxy_new_for_bus_sync (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error);
+
+
+/* ---- */
+
+#define GSD_TYPE_ACCOUNTS_USER_SKELETON (gsd_accounts_user_skeleton_get_type ())
+#define GSD_ACCOUNTS_USER_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), GSD_TYPE_ACCOUNTS_USER_SKELETON, GsdAccountsUserSkeleton))
+#define GSD_ACCOUNTS_USER_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), GSD_TYPE_ACCOUNTS_USER_SKELETON, GsdAccountsUserSkeletonClass))
+#define GSD_ACCOUNTS_USER_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GSD_TYPE_ACCOUNTS_USER_SKELETON, GsdAccountsUserSkeletonClass))
+#define GSD_IS_ACCOUNTS_USER_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), GSD_TYPE_ACCOUNTS_USER_SKELETON))
+#define GSD_IS_ACCOUNTS_USER_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), GSD_TYPE_ACCOUNTS_USER_SKELETON))
+
+typedef struct _GsdAccountsUserSkeleton GsdAccountsUserSkeleton;
+typedef struct _GsdAccountsUserSkeletonClass GsdAccountsUserSkeletonClass;
+typedef struct _GsdAccountsUserSkeletonPrivate GsdAccountsUserSkeletonPrivate;
+
+struct _GsdAccountsUserSkeleton
+{
+  /*< private >*/
+  GDBusInterfaceSkeleton parent_instance;
+  GsdAccountsUserSkeletonPrivate *priv;
+};
+
+struct _GsdAccountsUserSkeletonClass
+{
+  GDBusInterfaceSkeletonClass parent_class;
+};
+
+GType gsd_accounts_user_skeleton_get_type (void) G_GNUC_CONST;
+
+#if GLIB_CHECK_VERSION(2, 44, 0)
+G_DEFINE_AUTOPTR_CLEANUP_FUNC (GsdAccountsUserSkeleton, g_object_unref)
+#endif
+
+GsdAccountsUser *gsd_accounts_user_skeleton_new (void);
+
+
+G_END_DECLS
+
+#endif /* __ORG_FREEDESKTOP_ACCOUNTS_USER_H__ */
diff --git a/plugins/account/org.freedesktop.Accounts.User.xml b/plugins/account/org.freedesktop.Accounts.User.xml
new file mode 100644
index 00000000..4ab989a0
--- /dev/null
+++ b/plugins/account/org.freedesktop.Accounts.User.xml
@@ -0,0 +1,825 @@
+<!DOCTYPE node PUBLIC
+"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN"
+"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd" >
+<node name="/" xmlns:doc="http://www.freedesktop.org/dbus/1.0/doc.dtd">
+  <interface name="org.freedesktop.Accounts.User">
+
+  <method name="SetUserName">
+    <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+    <arg name="name" direction="in" type="s">
+      <doc:doc>
+        <doc:summary>
+          The new username.
+        </doc:summary>
+      </doc:doc>
+    </arg>
+    <doc:doc>
+      <doc:description>
+        <doc:para>
+          Sets the users username. Note that it is usually not allowed
+          to have multiple users with the same username.
+        </doc:para>
+      </doc:description>
+      <doc:permission>
+        The caller needs one of the following PolicyKit authorizations:
+        <doc:list>
+          <doc:item>
+            <doc:term>org.freedesktop.accounts.user-administration</doc:term>
+            <doc:definition>To change the username of any user</doc:definition>
+          </doc:item>
+        </doc:list>
+      </doc:permission>
+      <doc:errors>
+        <doc:error name="org.freedesktop.Accounts.Error.PermissionDenied">if the caller lacks the appropriate PolicyKit authorization</doc:error>
+        <doc:error name="org.freedesktop.Accounts.Error.Failed">if the operation failed</doc:error>
+      </doc:errors>
+    </doc:doc>
+  </method>
+
+  <method name="SetRealName">
+    <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+    <arg name="name" direction="in" type="s">
+      <doc:doc>
+        <doc:summary>
+          The new name, typically in the form "Firstname Lastname".
+        </doc:summary>
+      </doc:doc>
+    </arg>
+    <doc:doc>
+      <doc:description>
+        <doc:para>
+          Sets the users real name.
+        </doc:para>
+      </doc:description>
+      <doc:permission>
+        The caller needs one of the following PolicyKit authorizations:
+        <doc:list>
+          <doc:item>
+            <doc:term>org.freedesktop.accounts.change-own-user-data</doc:term>
+            <doc:definition>To change his own name</doc:definition>
+          </doc:item>
+          <doc:item>
+            <doc:term>org.freedesktop.accounts.user-administration</doc:term>
+            <doc:definition>To change the name of another user</doc:definition>
+          </doc:item>
+        </doc:list>
+      </doc:permission>
+      <doc:errors>
+        <doc:error name="org.freedesktop.Accounts.Error.PermissionDenied">if the caller lacks the appropriate PolicyKit authorization</doc:error>
+        <doc:error name="org.freedesktop.Accounts.Error.Failed">if the operation failed</doc:error>
+      </doc:errors>
+    </doc:doc>
+  </method>
+
+  <method name="SetEmail">
+    <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+    <arg name="email" direction="in" type="s">
+      <doc:doc>
+        <doc:summary>
+          The new email address.
+        </doc:summary>
+      </doc:doc>
+    </arg>
+    <doc:doc>
+      <doc:description>
+        <doc:para>
+          Sets the users email address.
+        </doc:para>
+        <doc:para>
+          Note that setting an email address in the AccountsService is
+          not the same as configuring a mail client. Mail clients might
+          default to email address that is configured here, though.
+        </doc:para>
+      </doc:description>
+      <doc:permission>
+        The caller needs one of the following PolicyKit authorizations:
+        <doc:list>
+          <doc:item>
+            <doc:term>org.freedesktop.accounts.change-own-user-data</doc:term>
+            <doc:definition>To change his own email address</doc:definition>
+          </doc:item>
+          <doc:item>
+            <doc:term>org.freedesktop.accounts.user-administration</doc:term>
+            <doc:definition>To change the email address of another user</doc:definition>
+          </doc:item>
+        </doc:list>
+      </doc:permission>
+      <doc:errors>
+        <doc:error name="org.freedesktop.Accounts.Error.PermissionDenied">if the caller lacks the appropriate PolicyKit authorization</doc:error>
+        <doc:error name="org.freedesktop.Accounts.Error.Failed">if the operation failed</doc:error>
+      </doc:errors>
+    </doc:doc>
+  </method>
+
+  <method name="SetLanguage">
+    <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+    <arg name="language" direction="in" type="s">
+      <doc:doc>
+        <doc:summary>
+          The new language, as a locale specification like "de_DE.UTF-8".
+        </doc:summary>
+      </doc:doc>
+    </arg>
+    <doc:doc>
+      <doc:description>
+        <doc:para>
+          Sets the users language.
+        </doc:para>
+        <doc:para>
+          The expectation is that display managers will start the
+          users session with this locale.
+        </doc:para>
+      </doc:description>
+      <doc:permission>
+        The caller needs one of the following PolicyKit authorizations:
+        <doc:list>
+          <doc:item>
+            <doc:term>org.freedesktop.accounts.change-own-user-data</doc:term>
+            <doc:definition>To change his own language</doc:definition>
+          </doc:item>
+          <doc:item>
+            <doc:term>org.freedesktop.accounts.user-administration</doc:term>
+            <doc:definition>To change the language of another user</doc:definition>
+          </doc:item>
+        </doc:list>
+      </doc:permission>
+      <doc:errors>
+        <doc:error name="org.freedesktop.Accounts.Error.PermissionDenied">if the caller lacks the appropriate PolicyKit authorization</doc:error>
+        <doc:error name="org.freedesktop.Accounts.Error.Failed">if the operation failed</doc:error>
+      </doc:errors>
+    </doc:doc>
+  </method>
+
+  <method name="SetXSession">
+    <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+    <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="user_set_x_session"/>
+    <arg name="x_session" direction="in" type="s">
+      <doc:doc>
+        <doc:summary>
+          The new xsession to start (e.g. "gnome")
+        </doc:summary>
+      </doc:doc>
+    </arg>
+    <doc:doc>
+      <doc:description>
+        <doc:para>
+          Sets the users x session.
+        </doc:para>
+        <doc:para>
+          The expectation is that display managers will log the user in to this
+          specified session, if available.
+        </doc:para>
+      </doc:description>
+      <doc:permission>
+        The caller needs one of the following PolicyKit authorizations:
+        <doc:list>
+          <doc:item>
+            <doc:term>org.freedesktop.accounts.change-own-user-data</doc:term>
+            <doc:definition>To change his own language</doc:definition>
+          </doc:item>
+          <doc:item>
+            <doc:term>org.freedesktop.accounts.user-administration</doc:term>
+            <doc:definition>To change the language of another user</doc:definition>
+          </doc:item>
+        </doc:list>
+      </doc:permission>
+      <doc:errors>
+        <doc:error name="org.freedesktop.Accounts.Error.PermissionDenied">if the caller lacks the appropriate PolicyKit authorization</doc:error>
+        <doc:error name="org.freedesktop.Accounts.Error.Failed">if the operation failed</doc:error>
+      </doc:errors>
+   </doc:doc>
+  </method>
+
+  <method name="SetLocation">
+    <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+    <arg name="location" direction="in" type="s">
+      <doc:doc>
+        <doc:summary>
+          The new location as a freeform string.
+        </doc:summary>
+      </doc:doc>
+    </arg>
+    <doc:doc>
+      <doc:description>
+        <doc:para>
+          Sets the users location.
+        </doc:para>
+      </doc:description>
+      <doc:permission>
+        The caller needs one of the following PolicyKit authorizations:
+        <doc:list>
+          <doc:item>
+            <doc:term>org.freedesktop.accounts.change-own-user-data</doc:term>
+            <doc:definition>To change his own location</doc:definition>
+          </doc:item>
+          <doc:item>
+            <doc:term>org.freedesktop.accounts.user-administration</doc:term>
+            <doc:definition>To change the location of another user</doc:definition>
+          </doc:item>
+        </doc:list>
+      </doc:permission>
+      <doc:errors>
+        <doc:error name="org.freedesktop.Accounts.Error.PermissionDenied">if the caller lacks the appropriate PolicyKit authorization</doc:error>
+        <doc:error name="org.freedesktop.Accounts.Error.Failed">if the operation failed</doc:error>
+      </doc:errors>
+    </doc:doc>
+  </method>
+
+  <method name="SetHomeDirectory">
+    <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+    <arg name="homedir" direction="in" type="s">
+      <doc:doc>
+        <doc:summary>
+          The new homedir as an absolute path.
+        </doc:summary>
+      </doc:doc>
+    </arg>
+    <doc:doc>
+      <doc:description>
+        <doc:para>
+          Sets the users home directory.
+        </doc:para>
+        <doc:para>
+          Note that changing the users home directory moves all the content
+          from the old location to the new one, and is potentially an
+          expensive operation.
+        </doc:para>
+      </doc:description>
+      <doc:permission>
+        The caller needs one of the following PolicyKit authorizations:
+        <doc:list>
+          <doc:item>
+            <doc:term>org.freedesktop.accounts.user-administration</doc:term>
+            <doc:definition>To change the home directory of a user</doc:definition>
+          </doc:item>
+        </doc:list>
+      </doc:permission>
+      <doc:errors>
+        <doc:error name="org.freedesktop.Accounts.Error.PermissionDenied">if the caller lacks the appropriate PolicyKit authorization</doc:error>
+        <doc:error name="org.freedesktop.Accounts.Error.Failed">if the operation failed</doc:error>
+      </doc:errors>
+    </doc:doc>
+  </method>
+
+  <method name="SetShell">
+    <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+    <arg name="shell" direction="in" type="s">
+      <doc:doc>
+        <doc:summary>
+          The new user shell.
+        </doc:summary>
+      </doc:doc>
+    </arg>
+    <doc:doc>
+      <doc:description>
+        <doc:para>
+          Sets the users shell.
+        </doc:para>
+        <doc:para>
+          Note that setting the shell to a non-allowed program may
+          prevent the user from logging in.
+        </doc:para>
+      </doc:description>
+      <doc:permission>
+        The caller needs one of the following PolicyKit authorizations:
+        <doc:list>
+          <doc:item>
+            <doc:term>org.freedesktop.accounts.user-administration</doc:term>
+            <doc:definition>To change the shell of a user</doc:definition>
+          </doc:item>
+        </doc:list>
+      </doc:permission>
+      <doc:errors>
+        <doc:error name="org.freedesktop.Accounts.Error.PermissionDenied">if the caller lacks the appropriate PolicyKit authorization</doc:error>
+        <doc:error name="org.freedesktop.Accounts.Error.Failed">if the operation failed</doc:error>
+      </doc:errors>
+    </doc:doc>
+  </method>
+
+  <method name="SetIconFile">
+    <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+    <arg name="filename" direction="in" type="s">
+      <doc:doc>
+        <doc:summary>
+          The absolute filename of a png file to use as the users icon.
+        </doc:summary>
+      </doc:doc>
+    </arg>
+    <doc:doc>
+      <doc:description>
+        <doc:para>
+          Sets the users icon.
+        </doc:para>
+      </doc:description>
+      <doc:permission>
+        The caller needs one of the following PolicyKit authorizations:
+        <doc:list>
+          <doc:item>
+            <doc:term>org.freedesktop.accounts.change-own-user-data</doc:term>
+            <doc:definition>To change his own icon</doc:definition>
+          </doc:item>
+          <doc:item>
+            <doc:term>org.freedesktop.accounts.user-administration</doc:term>
+            <doc:definition>To change the icon of another user</doc:definition>
+          </doc:item>
+        </doc:list>
+      </doc:permission>
+      <doc:errors>
+        <doc:error name="org.freedesktop.Accounts.Error.PermissionDenied">if the caller lacks the appropriate PolicyKit authorization</doc:error>
+        <doc:error name="org.freedesktop.Accounts.Error.Failed">if the operation failed</doc:error>
+      </doc:errors>
+    </doc:doc>
+  </method>
+
+  <method name="SetLocked">
+    <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+    <arg name="locked" direction="in" type="b">
+      <doc:doc>
+        <doc:summary>
+          Whether to lock or unlock the users account.
+        </doc:summary>
+      </doc:doc>
+    </arg>
+    <doc:doc>
+      <doc:description>
+        <doc:para>
+          Locks or unlocks a users account.
+        </doc:para>
+        <doc:para>
+          Locking an account prevents the user from logging in.
+        </doc:para>
+      </doc:description>
+      <doc:permission>
+        The caller needs one of the following PolicyKit authorizations:
+        <doc:list>
+          <doc:item>
+            <doc:term>org.freedesktop.accounts.user-administration</doc:term>
+            <doc:definition>To lock or unlock user accounts</doc:definition>
+          </doc:item>
+        </doc:list>
+      </doc:permission>
+      <doc:errors>
+        <doc:error name="org.freedesktop.Accounts.Error.PermissionDenied">if the caller lacks the appropriate PolicyKit authorization</doc:error>
+        <doc:error name="org.freedesktop.Accounts.Error.Failed">if the operation failed</doc:error>
+      </doc:errors>
+    </doc:doc>
+  </method>
+
+  <method name="SetAccountType">
+    <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+    <arg name="accountType" direction="in" type="i">
+      <doc:doc>
+        <doc:summary>
+          The new account type, encoded as an integer:
+          <doc:list>
+            <doc:item>
+              <doc:term>0</doc:term>
+              <doc:definition>Standard user</doc:definition>
+            </doc:item>
+            <doc:item>
+              <doc:term>1</doc:term>
+              <doc:definition>Administrator</doc:definition>
+            </doc:item>
+          </doc:list>
+        </doc:summary>
+      </doc:doc>
+    </arg>
+    <doc:doc>
+      <doc:description>
+        <doc:para>
+          Changes the users account type.
+        </doc:para>
+      </doc:description>
+      <doc:permission>
+        The caller needs one of the following PolicyKit authorizations:
+        <doc:list>
+          <doc:item>
+            <doc:term>org.freedesktop.accounts.user-administration</doc:term>
+            <doc:definition>To change an account type</doc:definition>
+          </doc:item>
+        </doc:list>
+      </doc:permission>
+      <doc:errors>
+        <doc:error name="org.freedesktop.Accounts.Error.PermissionDenied">if the caller lacks the appropriate PolicyKit authorization</doc:error>
+        <doc:error name="org.freedesktop.Accounts.Error.Failed">if the operation failed</doc:error>
+      </doc:errors>
+    </doc:doc>
+  </method>
+
+  <method name="SetPasswordMode">
+    <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+    <arg name="mode" direction="in" type="i">
+      <doc:doc>
+        <doc:summary>
+          The new password mode, encoded as an integer:
+          <doc:list>
+            <doc:item>
+              <doc:term>0</doc:term>
+              <doc:definition>Regular password</doc:definition>
+            </doc:item>
+            <doc:item>
+              <doc:term>1</doc:term>
+              <doc:definition>Password must be set at next login</doc:definition>
+            </doc:item>
+            <doc:item>
+              <doc:term>2</doc:term>
+              <doc:definition>No password</doc:definition>
+            </doc:item>
+          </doc:list>
+        </doc:summary>
+      </doc:doc>
+    </arg>
+    <doc:doc>
+      <doc:description>
+        <doc:para>
+          Changes the users password mode.
+        </doc:para>
+        <doc:para>
+          Note that changing the password mode has the side-effect of
+          unlocking the account.
+        </doc:para>
+      </doc:description>
+      <doc:permission>
+        The caller needs one of the following PolicyKit authorizations:
+        <doc:list>
+          <doc:item>
+            <doc:term>org.freedesktop.accounts.user-administration</doc:term>
+            <doc:definition>To change a users password mode</doc:definition>
+          </doc:item>
+        </doc:list>
+      </doc:permission>
+      <doc:errors>
+        <doc:error name="org.freedesktop.Accounts.Error.PermissionDenied">if the caller lacks the appropriate PolicyKit authorization</doc:error>
+        <doc:error name="org.freedesktop.Accounts.Error.Failed">if the operation failed</doc:error>
+      </doc:errors>
+    </doc:doc>
+  </method>
+
+  <method name="SetPassword">
+    <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+    <arg name="password" direction="in" type="s">
+      <doc:doc>
+        <doc:summary>
+          The crypted password.
+        </doc:summary>
+      </doc:doc>
+    </arg>
+    <arg name="hint" direction="in" type="s">
+      <doc:doc>
+        <doc:summary>
+          The password hint.
+        </doc:summary>
+      </doc:doc>
+    </arg>
+    <doc:doc>
+      <doc:description>
+        <doc:para>
+          Sets a new password for this user.
+        </doc:para>
+        <doc:para>
+          Note that setting a password has the side-effect of
+          unlocking the account.
+        </doc:para>
+      </doc:description>
+      <doc:permission>
+        The caller needs one of the following PolicyKit authorizations:
+        <doc:list>
+          <doc:item>
+            <doc:term>org.freedesktop.accounts.user-administration</doc:term>
+            <doc:definition>To change the password of a user</doc:definition>
+          </doc:item>
+        </doc:list>
+      </doc:permission>
+      <doc:errors>
+        <doc:error name="org.freedesktop.Accounts.Error.PermissionDenied">if the caller lacks the appropriate PolicyKit authorization</doc:error>
+        <doc:error name="org.freedesktop.Accounts.Error.Failed">if the operation failed</doc:error>
+      </doc:errors>
+    </doc:doc>
+  </method>
+
+  <method name="SetPasswordHint">
+    <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+    <arg name="hint" direction="in" type="s">
+      <doc:doc>
+        <doc:summary>
+          The password hint.
+        </doc:summary>
+      </doc:doc>
+    </arg>
+    <doc:doc>
+      <doc:description>
+        <doc:para>
+          Sets the users password hint.
+        </doc:para>
+      </doc:description>
+      <doc:permission>
+        The caller needs one of the following PolicyKit authorizations:
+        <doc:list>
+          <doc:item>
+            <doc:term>org.freedesktop.accounts.change-own-user-data</doc:term>
+            <doc:definition>To change his own language</doc:definition>
+          </doc:item>
+          <doc:item>
+            <doc:term>org.freedesktop.accounts.user-administration</doc:term>
+            <doc:definition>To change the language of another user</doc:definition>
+          </doc:item>
+        </doc:list>
+      </doc:permission>
+      <doc:errors>
+        <doc:error name="org.freedesktop.Accounts.Error.PermissionDenied">if the caller lacks the appropriate PolicyKit authorization</doc:error>
+        <doc:error name="org.freedesktop.Accounts.Error.Failed">if the operation failed</doc:error>
+      </doc:errors>
+    </doc:doc>
+  </method>
+
+  <method name="SetAutomaticLogin">
+    <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+    <arg name="enabled" direction="in" type="b">
+      <doc:doc>
+        <doc:summary>
+          Whether to enable automatic login for this user.
+        </doc:summary>
+      </doc:doc>
+    </arg>
+    <doc:doc>
+      <doc:description>
+        <doc:para>
+          Enables or disables automatic login for a user.
+        </doc:para>
+        <doc:para>
+          Note that usually only one user can have automatic login
+          enabled, so turning it on for a user will disable it for
+          the previously configured autologin user.
+        </doc:para>
+      </doc:description>
+      <doc:permission>
+        The caller needs one of the following PolicyKit authorizations:
+        <doc:list>
+          <doc:item>
+            <doc:term>org.freedesktop.accounts.set-login-option</doc:term>
+            <doc:definition>To change the login screen configuration</doc:definition>
+          </doc:item>
+        </doc:list>
+      </doc:permission>
+      <doc:errors>
+        <doc:error name="org.freedesktop.Accounts.Error.PermissionDenied">if the caller lacks the appropriate PolicyKit authorization</doc:error>
+        <doc:error name="org.freedesktop.Accounts.Error.Failed">if the operation failed</doc:error>
+      </doc:errors>
+    </doc:doc>
+  </method>
+
+  <method name="GetPasswordExpirationPolicy">
+    <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+    <arg name="expiration_time" direction="out" type="x"/>
+    <arg name="last_change_time" direction="out" type="x"/>
+    <arg name="min_days_between_changes" direction="out" type="x"/>
+    <arg name="max_days_between_changes" direction="out" type="x"/>
+    <arg name="days_to_warn" direction="out" type="x"/>
+    <arg name="days_after_expiration_until_lock" direction="out" type="x"/>
+  </method>
+
+  <property name="Uid" type="t" access="read">
+    <doc:doc>
+      <doc:description>
+        <doc:para>
+          The uid of the user.
+        </doc:para>
+      </doc:description>
+    </doc:doc>
+  </property>
+
+  <property name="UserName" type="s" access="read">
+    <doc:doc>
+      <doc:description>
+        <doc:para>
+          The username of the user.
+        </doc:para>
+      </doc:description>
+    </doc:doc>
+  </property>
+
+  <property name="RealName" type="s" access="read">
+    <doc:doc>
+      <doc:description>
+        <doc:para>
+          The users real name.
+        </doc:para>
+      </doc:description>
+    </doc:doc>
+  </property>
+
+  <property name="AccountType" type="i" access="read">
+    <doc:doc>
+      <doc:description>
+        <doc:para>
+          The users account type, encoded as an integer:
+          <doc:list>
+            <doc:item>
+              <doc:term>0</doc:term>
+              <doc:definition>Standard user</doc:definition>
+            </doc:item>
+            <doc:item>
+              <doc:term>1</doc:term>
+              <doc:definition>Administrator</doc:definition>
+            </doc:item>
+          </doc:list>
+        </doc:para>
+      </doc:description>
+    </doc:doc>
+  </property>
+
+  <property name="HomeDirectory" type="s" access="read">
+    <doc:doc>
+      <doc:description>
+        <doc:para>
+          The users home directory.
+        </doc:para>
+      </doc:description>
+    </doc:doc>
+  </property>
+
+  <property name="Shell" type="s" access="read">
+    <doc:doc>
+      <doc:description>
+        <doc:para>
+          The users shell.
+        </doc:para>
+      </doc:description>
+    </doc:doc>
+  </property>
+
+  <property name="Email" type="s" access="read">
+    <doc:doc>
+      <doc:description>
+        <doc:para>
+          The email address.
+        </doc:para>
+      </doc:description>
+    </doc:doc>
+  </property>
+
+  <property name="Language" type="s" access="read">
+    <doc:doc>
+      <doc:description>
+        <doc:para>
+          The users language, as a locale specification like "de_DE.UTF-8".
+        </doc:para>
+      </doc:description>
+    </doc:doc>
+  </property>
+
+  <property name="XSession" type="s" access="read">
+    <doc:doc>
+      <doc:description>
+        <doc:para>
+          The users x session.
+        </doc:para>
+      </doc:description>
+    </doc:doc>
+  </property>
+
+  <property name="Location" type="s" access="read">
+    <doc:doc>
+      <doc:description>
+        <doc:para>
+          The users location.
+        </doc:para>
+      </doc:description>
+    </doc:doc>
+  </property>
+
+  <property name="LoginFrequency" type="t" access="read">
+    <doc:doc>
+      <doc:description>
+        <doc:para>
+          How often the user has logged in.
+        </doc:para>
+      </doc:description>
+    </doc:doc>
+  </property>
+
+  <property name="LoginTime" type="x" access="read">
+    <doc:doc>
+      <doc:description>
+        <doc:para>
+          The last login time.
+        </doc:para>
+      </doc:description>
+    </doc:doc>
+  </property>
+
+  <property name="LoginHistory" type="a(xxa{sv})" access="read">
+    <doc:doc>
+      <doc:description>
+        <doc:para>
+          The login history for this user.
+          Each entry in the array represents a login session. The first two
+          members are the login time and logout time, as timestamps (seconds since the epoch). If the session is still running, the logout time
+          is 0.
+        </doc:para>
+        <doc:para>
+          The a{sv} member is a dictionary containing additional information
+          about the session. Possible members include 'type' (with values like ':0', 'tty0', 'pts/0' etc).
+        </doc:para>
+      </doc:description>
+    </doc:doc>
+  </property>
+
+  <property name="IconFile" type="s" access="read">
+    <doc:doc>
+      <doc:description>
+        <doc:para>
+           The filename of a png file containing the users icon.
+        </doc:para>
+      </doc:description>
+    </doc:doc>
+  </property>
+
+  <property name="Locked" type="b" access="read">
+    <doc:doc>
+      <doc:description>
+        <doc:para>
+           Whether the users account is locked.
+        </doc:para>
+      </doc:description>
+    </doc:doc>
+  </property>
+
+  <property name="PasswordMode" type="i" access="read">
+    <doc:doc>
+      <doc:description>
+        <doc:para>
+          The password mode for the user account, encoded as an integer:
+          <doc:list>
+            <doc:item>
+              <doc:term>0</doc:term>
+              <doc:definition>Regular password</doc:definition>
+            </doc:item>
+            <doc:item>
+              <doc:term>1</doc:term>
+              <doc:definition>Password must be set at next login</doc:definition>
+            </doc:item>
+            <doc:item>
+              <doc:term>2</doc:term>
+              <doc:definition>No password</doc:definition>
+            </doc:item>
+          </doc:list>
+        </doc:para>
+      </doc:description>
+    </doc:doc>
+  </property>
+
+  <property name="PasswordHint" type="s" access="read">
+    <doc:doc>
+      <doc:description>
+        <doc:para>
+           The password hint for the user.
+        </doc:para>
+      </doc:description>
+    </doc:doc>
+  </property>
+
+  <property name="AutomaticLogin" type="b" access="read">
+    <doc:doc>
+      <doc:description>
+        <doc:para>
+           Whether automatic login is enabled for the user.
+        </doc:para>
+      </doc:description>
+    </doc:doc>
+  </property>
+
+  <property name="SystemAccount" type="b" access="read">
+    <doc:doc>
+      <doc:description>
+        <doc:para>
+           Whether this is a 'system' account, like 'root' or 'nobody'.
+           System accounts should normally not appear in lists of
+           users, and ListCachedUsers will not include such accounts.
+        </doc:para>
+      </doc:description>
+    </doc:doc>
+  </property>
+
+  <property name="LocalAccount" type="b" access="read">
+    <doc:doc>
+      <doc:description>
+        <doc:para>
+          Whether the user is a local account or not.
+        </doc:para>
+      </doc:description>
+    </doc:doc>
+  </property>
+
+  <signal name="Changed">
+    <doc:doc>
+      <doc:description>
+        <doc:para>
+           Emitted when the user is changed.
+        </doc:para>
+      </doc:description>
+    </doc:doc>
+  </signal>
+
+  </interface>
+</node>
diff --git a/plugins/account/org.freedesktop.Accounts.c b/plugins/account/org.freedesktop.Accounts.c
new file mode 100644
index 00000000..669c43a8
--- /dev/null
+++ b/plugins/account/org.freedesktop.Accounts.c
@@ -0,0 +1,3016 @@
+/*
+ * Generated by gdbus-codegen 2.54.1. DO NOT EDIT.
+ *
+ * The license of this code is the same as for the source it was derived from.
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include "config.h"
+#endif
+
+#include "org.freedesktop.Accounts.h"
+
+#include <string.h>
+#ifdef G_OS_UNIX
+#  include <gio/gunixfdlist.h>
+#endif
+
+typedef struct
+{
+  GDBusArgInfo parent_struct;
+  gboolean use_gvariant;
+} _ExtendedGDBusArgInfo;
+
+typedef struct
+{
+  GDBusMethodInfo parent_struct;
+  const gchar *signal_name;
+  gboolean pass_fdlist;
+} _ExtendedGDBusMethodInfo;
+
+typedef struct
+{
+  GDBusSignalInfo parent_struct;
+  const gchar *signal_name;
+} _ExtendedGDBusSignalInfo;
+
+typedef struct
+{
+  GDBusPropertyInfo parent_struct;
+  const gchar *hyphen_name;
+  gboolean use_gvariant;
+} _ExtendedGDBusPropertyInfo;
+
+typedef struct
+{
+  GDBusInterfaceInfo parent_struct;
+  const gchar *hyphen_name;
+} _ExtendedGDBusInterfaceInfo;
+
+typedef struct
+{
+  const _ExtendedGDBusPropertyInfo *info;
+  guint prop_id;
+  GValue orig_value; /* the value before the change */
+} ChangedProperty;
+
+static void
+_changed_property_free (ChangedProperty *data)
+{
+  g_value_unset (&data->orig_value);
+  g_free (data);
+}
+
+static gboolean
+_g_strv_equal0 (gchar **a, gchar **b)
+{
+  gboolean ret = FALSE;
+  guint n;
+  if (a == NULL && b == NULL)
+    {
+      ret = TRUE;
+      goto out;
+    }
+  if (a == NULL || b == NULL)
+    goto out;
+  if (g_strv_length (a) != g_strv_length (b))
+    goto out;
+  for (n = 0; a[n] != NULL; n++)
+    if (g_strcmp0 (a[n], b[n]) != 0)
+      goto out;
+  ret = TRUE;
+out:
+  return ret;
+}
+
+static gboolean
+_g_variant_equal0 (GVariant *a, GVariant *b)
+{
+  gboolean ret = FALSE;
+  if (a == NULL && b == NULL)
+    {
+      ret = TRUE;
+      goto out;
+    }
+  if (a == NULL || b == NULL)
+    goto out;
+  ret = g_variant_equal (a, b);
+out:
+  return ret;
+}
+
+G_GNUC_UNUSED static gboolean
+_g_value_equal (const GValue *a, const GValue *b)
+{
+  gboolean ret = FALSE;
+  g_assert (G_VALUE_TYPE (a) == G_VALUE_TYPE (b));
+  switch (G_VALUE_TYPE (a))
+    {
+      case G_TYPE_BOOLEAN:
+        ret = (g_value_get_boolean (a) == g_value_get_boolean (b));
+        break;
+      case G_TYPE_UCHAR:
+        ret = (g_value_get_uchar (a) == g_value_get_uchar (b));
+        break;
+      case G_TYPE_INT:
+        ret = (g_value_get_int (a) == g_value_get_int (b));
+        break;
+      case G_TYPE_UINT:
+        ret = (g_value_get_uint (a) == g_value_get_uint (b));
+        break;
+      case G_TYPE_INT64:
+        ret = (g_value_get_int64 (a) == g_value_get_int64 (b));
+        break;
+      case G_TYPE_UINT64:
+        ret = (g_value_get_uint64 (a) == g_value_get_uint64 (b));
+        break;
+      case G_TYPE_DOUBLE:
+        {
+          /* Avoid -Wfloat-equal warnings by doing a direct bit compare */
+          gdouble da = g_value_get_double (a);
+          gdouble db = g_value_get_double (b);
+          ret = memcmp (&da, &db, sizeof (gdouble)) == 0;
+        }
+        break;
+      case G_TYPE_STRING:
+        ret = (g_strcmp0 (g_value_get_string (a), g_value_get_string (b)) == 0);
+        break;
+      case G_TYPE_VARIANT:
+        ret = _g_variant_equal0 (g_value_get_variant (a), g_value_get_variant (b));
+        break;
+      default:
+        if (G_VALUE_TYPE (a) == G_TYPE_STRV)
+          ret = _g_strv_equal0 (g_value_get_boxed (a), g_value_get_boxed (b));
+        else
+          g_critical ("_g_value_equal() does not handle type %s", g_type_name (G_VALUE_TYPE (a)));
+        break;
+    }
+  return ret;
+}
+
+/* ------------------------------------------------------------------------
+ * Code for interface org.freedesktop.Accounts
+ * ------------------------------------------------------------------------
+ */
+
+/**
+ * SECTION:GsdAccounts
+ * @title: GsdAccounts
+ * @short_description: Generated C code for the org.freedesktop.Accounts D-Bus interface
+ *
+ * This section contains code for working with the <link linkend="gdbus-interface-org-freedesktop-Accounts.top_of_page">org.freedesktop.Accounts</link> D-Bus interface in C.
+ */
+
+/* ---- Introspection data for org.freedesktop.Accounts ---- */
+
+static const _ExtendedGDBusArgInfo _gsd_accounts_method_info_list_cached_users_OUT_ARG_users =
+{
+  {
+    -1,
+    (gchar *) "users",
+    (gchar *) "ao",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo * const _gsd_accounts_method_info_list_cached_users_OUT_ARG_pointers[] =
+{
+  &_gsd_accounts_method_info_list_cached_users_OUT_ARG_users,
+  NULL
+};
+
+static const GDBusAnnotationInfo _gsd_accounts_method_list_cached_users_annotation_info_0 =
+{
+  -1,
+  (gchar *) "org.freedesktop.DBus.GLib.Async",
+  (gchar *) "",
+  NULL
+};
+
+static const GDBusAnnotationInfo * const _gsd_accounts_method_list_cached_users_annotation_info_pointers[] =
+{
+  &_gsd_accounts_method_list_cached_users_annotation_info_0,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _gsd_accounts_method_info_list_cached_users =
+{
+  {
+    -1,
+    (gchar *) "ListCachedUsers",
+    NULL,
+    (GDBusArgInfo **) &_gsd_accounts_method_info_list_cached_users_OUT_ARG_pointers,
+    (GDBusAnnotationInfo **) &_gsd_accounts_method_list_cached_users_annotation_info_pointers
+  },
+  "handle-list-cached-users",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gsd_accounts_method_info_find_user_by_id_IN_ARG_id =
+{
+  {
+    -1,
+    (gchar *) "id",
+    (gchar *) "x",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo * const _gsd_accounts_method_info_find_user_by_id_IN_ARG_pointers[] =
+{
+  &_gsd_accounts_method_info_find_user_by_id_IN_ARG_id,
+  NULL
+};
+
+static const _ExtendedGDBusArgInfo _gsd_accounts_method_info_find_user_by_id_OUT_ARG_user =
+{
+  {
+    -1,
+    (gchar *) "user",
+    (gchar *) "o",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo * const _gsd_accounts_method_info_find_user_by_id_OUT_ARG_pointers[] =
+{
+  &_gsd_accounts_method_info_find_user_by_id_OUT_ARG_user,
+  NULL
+};
+
+static const GDBusAnnotationInfo _gsd_accounts_method_find_user_by_id_annotation_info_0 =
+{
+  -1,
+  (gchar *) "org.freedesktop.DBus.GLib.Async",
+  (gchar *) "",
+  NULL
+};
+
+static const GDBusAnnotationInfo * const _gsd_accounts_method_find_user_by_id_annotation_info_pointers[] =
+{
+  &_gsd_accounts_method_find_user_by_id_annotation_info_0,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _gsd_accounts_method_info_find_user_by_id =
+{
+  {
+    -1,
+    (gchar *) "FindUserById",
+    (GDBusArgInfo **) &_gsd_accounts_method_info_find_user_by_id_IN_ARG_pointers,
+    (GDBusArgInfo **) &_gsd_accounts_method_info_find_user_by_id_OUT_ARG_pointers,
+    (GDBusAnnotationInfo **) &_gsd_accounts_method_find_user_by_id_annotation_info_pointers
+  },
+  "handle-find-user-by-id",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gsd_accounts_method_info_find_user_by_name_IN_ARG_name =
+{
+  {
+    -1,
+    (gchar *) "name",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo * const _gsd_accounts_method_info_find_user_by_name_IN_ARG_pointers[] =
+{
+  &_gsd_accounts_method_info_find_user_by_name_IN_ARG_name,
+  NULL
+};
+
+static const _ExtendedGDBusArgInfo _gsd_accounts_method_info_find_user_by_name_OUT_ARG_user =
+{
+  {
+    -1,
+    (gchar *) "user",
+    (gchar *) "o",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo * const _gsd_accounts_method_info_find_user_by_name_OUT_ARG_pointers[] =
+{
+  &_gsd_accounts_method_info_find_user_by_name_OUT_ARG_user,
+  NULL
+};
+
+static const GDBusAnnotationInfo _gsd_accounts_method_find_user_by_name_annotation_info_0 =
+{
+  -1,
+  (gchar *) "org.freedesktop.DBus.GLib.Async",
+  (gchar *) "",
+  NULL
+};
+
+static const GDBusAnnotationInfo * const _gsd_accounts_method_find_user_by_name_annotation_info_pointers[] =
+{
+  &_gsd_accounts_method_find_user_by_name_annotation_info_0,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _gsd_accounts_method_info_find_user_by_name =
+{
+  {
+    -1,
+    (gchar *) "FindUserByName",
+    (GDBusArgInfo **) &_gsd_accounts_method_info_find_user_by_name_IN_ARG_pointers,
+    (GDBusArgInfo **) &_gsd_accounts_method_info_find_user_by_name_OUT_ARG_pointers,
+    (GDBusAnnotationInfo **) &_gsd_accounts_method_find_user_by_name_annotation_info_pointers
+  },
+  "handle-find-user-by-name",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gsd_accounts_method_info_create_user_IN_ARG_name =
+{
+  {
+    -1,
+    (gchar *) "name",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gsd_accounts_method_info_create_user_IN_ARG_fullname =
+{
+  {
+    -1,
+    (gchar *) "fullname",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gsd_accounts_method_info_create_user_IN_ARG_accountType =
+{
+  {
+    -1,
+    (gchar *) "accountType",
+    (gchar *) "i",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo * const _gsd_accounts_method_info_create_user_IN_ARG_pointers[] =
+{
+  &_gsd_accounts_method_info_create_user_IN_ARG_name,
+  &_gsd_accounts_method_info_create_user_IN_ARG_fullname,
+  &_gsd_accounts_method_info_create_user_IN_ARG_accountType,
+  NULL
+};
+
+static const _ExtendedGDBusArgInfo _gsd_accounts_method_info_create_user_OUT_ARG_user =
+{
+  {
+    -1,
+    (gchar *) "user",
+    (gchar *) "o",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo * const _gsd_accounts_method_info_create_user_OUT_ARG_pointers[] =
+{
+  &_gsd_accounts_method_info_create_user_OUT_ARG_user,
+  NULL
+};
+
+static const GDBusAnnotationInfo _gsd_accounts_method_create_user_annotation_info_0 =
+{
+  -1,
+  (gchar *) "org.freedesktop.DBus.GLib.Async",
+  (gchar *) "",
+  NULL
+};
+
+static const GDBusAnnotationInfo _gsd_accounts_method_create_user_annotation_info_1 =
+{
+  -1,
+  (gchar *) "org.freedesktop.DBus.GLib.Async",
+  (gchar *) "",
+  NULL
+};
+
+static const GDBusAnnotationInfo * const _gsd_accounts_method_create_user_annotation_info_pointers[] =
+{
+  &_gsd_accounts_method_create_user_annotation_info_0,
+  &_gsd_accounts_method_create_user_annotation_info_1,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _gsd_accounts_method_info_create_user =
+{
+  {
+    -1,
+    (gchar *) "CreateUser",
+    (GDBusArgInfo **) &_gsd_accounts_method_info_create_user_IN_ARG_pointers,
+    (GDBusArgInfo **) &_gsd_accounts_method_info_create_user_OUT_ARG_pointers,
+    (GDBusAnnotationInfo **) &_gsd_accounts_method_create_user_annotation_info_pointers
+  },
+  "handle-create-user",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gsd_accounts_method_info_cache_user_IN_ARG_name =
+{
+  {
+    -1,
+    (gchar *) "name",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo * const _gsd_accounts_method_info_cache_user_IN_ARG_pointers[] =
+{
+  &_gsd_accounts_method_info_cache_user_IN_ARG_name,
+  NULL
+};
+
+static const _ExtendedGDBusArgInfo _gsd_accounts_method_info_cache_user_OUT_ARG_user =
+{
+  {
+    -1,
+    (gchar *) "user",
+    (gchar *) "o",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo * const _gsd_accounts_method_info_cache_user_OUT_ARG_pointers[] =
+{
+  &_gsd_accounts_method_info_cache_user_OUT_ARG_user,
+  NULL
+};
+
+static const GDBusAnnotationInfo _gsd_accounts_method_cache_user_annotation_info_0 =
+{
+  -1,
+  (gchar *) "org.freedesktop.DBus.GLib.Async",
+  (gchar *) "",
+  NULL
+};
+
+static const GDBusAnnotationInfo * const _gsd_accounts_method_cache_user_annotation_info_pointers[] =
+{
+  &_gsd_accounts_method_cache_user_annotation_info_0,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _gsd_accounts_method_info_cache_user =
+{
+  {
+    -1,
+    (gchar *) "CacheUser",
+    (GDBusArgInfo **) &_gsd_accounts_method_info_cache_user_IN_ARG_pointers,
+    (GDBusArgInfo **) &_gsd_accounts_method_info_cache_user_OUT_ARG_pointers,
+    (GDBusAnnotationInfo **) &_gsd_accounts_method_cache_user_annotation_info_pointers
+  },
+  "handle-cache-user",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gsd_accounts_method_info_uncache_user_IN_ARG_name =
+{
+  {
+    -1,
+    (gchar *) "name",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo * const _gsd_accounts_method_info_uncache_user_IN_ARG_pointers[] =
+{
+  &_gsd_accounts_method_info_uncache_user_IN_ARG_name,
+  NULL
+};
+
+static const GDBusAnnotationInfo _gsd_accounts_method_uncache_user_annotation_info_0 =
+{
+  -1,
+  (gchar *) "org.freedesktop.DBus.GLib.Async",
+  (gchar *) "",
+  NULL
+};
+
+static const GDBusAnnotationInfo * const _gsd_accounts_method_uncache_user_annotation_info_pointers[] =
+{
+  &_gsd_accounts_method_uncache_user_annotation_info_0,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _gsd_accounts_method_info_uncache_user =
+{
+  {
+    -1,
+    (gchar *) "UncacheUser",
+    (GDBusArgInfo **) &_gsd_accounts_method_info_uncache_user_IN_ARG_pointers,
+    NULL,
+    (GDBusAnnotationInfo **) &_gsd_accounts_method_uncache_user_annotation_info_pointers
+  },
+  "handle-uncache-user",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gsd_accounts_method_info_delete_user_IN_ARG_id =
+{
+  {
+    -1,
+    (gchar *) "id",
+    (gchar *) "x",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gsd_accounts_method_info_delete_user_IN_ARG_removeFiles =
+{
+  {
+    -1,
+    (gchar *) "removeFiles",
+    (gchar *) "b",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo * const _gsd_accounts_method_info_delete_user_IN_ARG_pointers[] =
+{
+  &_gsd_accounts_method_info_delete_user_IN_ARG_id,
+  &_gsd_accounts_method_info_delete_user_IN_ARG_removeFiles,
+  NULL
+};
+
+static const GDBusAnnotationInfo _gsd_accounts_method_delete_user_annotation_info_0 =
+{
+  -1,
+  (gchar *) "org.freedesktop.DBus.GLib.Async",
+  (gchar *) "",
+  NULL
+};
+
+static const GDBusAnnotationInfo * const _gsd_accounts_method_delete_user_annotation_info_pointers[] =
+{
+  &_gsd_accounts_method_delete_user_annotation_info_0,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _gsd_accounts_method_info_delete_user =
+{
+  {
+    -1,
+    (gchar *) "DeleteUser",
+    (GDBusArgInfo **) &_gsd_accounts_method_info_delete_user_IN_ARG_pointers,
+    NULL,
+    (GDBusAnnotationInfo **) &_gsd_accounts_method_delete_user_annotation_info_pointers
+  },
+  "handle-delete-user",
+  FALSE
+};
+
+static const _ExtendedGDBusMethodInfo * const _gsd_accounts_method_info_pointers[] =
+{
+  &_gsd_accounts_method_info_list_cached_users,
+  &_gsd_accounts_method_info_find_user_by_id,
+  &_gsd_accounts_method_info_find_user_by_name,
+  &_gsd_accounts_method_info_create_user,
+  &_gsd_accounts_method_info_cache_user,
+  &_gsd_accounts_method_info_uncache_user,
+  &_gsd_accounts_method_info_delete_user,
+  NULL
+};
+
+static const _ExtendedGDBusArgInfo _gsd_accounts_signal_info_user_added_ARG_user =
+{
+  {
+    -1,
+    (gchar *) "user",
+    (gchar *) "o",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo * const _gsd_accounts_signal_info_user_added_ARG_pointers[] =
+{
+  &_gsd_accounts_signal_info_user_added_ARG_user,
+  NULL
+};
+
+static const _ExtendedGDBusSignalInfo _gsd_accounts_signal_info_user_added =
+{
+  {
+    -1,
+    (gchar *) "UserAdded",
+    (GDBusArgInfo **) &_gsd_accounts_signal_info_user_added_ARG_pointers,
+    NULL
+  },
+  "user-added"
+};
+
+static const _ExtendedGDBusArgInfo _gsd_accounts_signal_info_user_deleted_ARG_user =
+{
+  {
+    -1,
+    (gchar *) "user",
+    (gchar *) "o",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo * const _gsd_accounts_signal_info_user_deleted_ARG_pointers[] =
+{
+  &_gsd_accounts_signal_info_user_deleted_ARG_user,
+  NULL
+};
+
+static const _ExtendedGDBusSignalInfo _gsd_accounts_signal_info_user_deleted =
+{
+  {
+    -1,
+    (gchar *) "UserDeleted",
+    (GDBusArgInfo **) &_gsd_accounts_signal_info_user_deleted_ARG_pointers,
+    NULL
+  },
+  "user-deleted"
+};
+
+static const _ExtendedGDBusSignalInfo * const _gsd_accounts_signal_info_pointers[] =
+{
+  &_gsd_accounts_signal_info_user_added,
+  &_gsd_accounts_signal_info_user_deleted,
+  NULL
+};
+
+static const _ExtendedGDBusPropertyInfo _gsd_accounts_property_info_daemon_version =
+{
+  {
+    -1,
+    (gchar *) "DaemonVersion",
+    (gchar *) "s",
+    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
+    NULL
+  },
+  "daemon-version",
+  FALSE
+};
+
+static const _ExtendedGDBusPropertyInfo _gsd_accounts_property_info_has_no_users =
+{
+  {
+    -1,
+    (gchar *) "HasNoUsers",
+    (gchar *) "b",
+    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
+    NULL
+  },
+  "has-no-users",
+  FALSE
+};
+
+static const _ExtendedGDBusPropertyInfo _gsd_accounts_property_info_has_multiple_users =
+{
+  {
+    -1,
+    (gchar *) "HasMultipleUsers",
+    (gchar *) "b",
+    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
+    NULL
+  },
+  "has-multiple-users",
+  FALSE
+};
+
+static const _ExtendedGDBusPropertyInfo * const _gsd_accounts_property_info_pointers[] =
+{
+  &_gsd_accounts_property_info_daemon_version,
+  &_gsd_accounts_property_info_has_no_users,
+  &_gsd_accounts_property_info_has_multiple_users,
+  NULL
+};
+
+static const _ExtendedGDBusInterfaceInfo _gsd_accounts_interface_info =
+{
+  {
+    -1,
+    (gchar *) "org.freedesktop.Accounts",
+    (GDBusMethodInfo **) &_gsd_accounts_method_info_pointers,
+    (GDBusSignalInfo **) &_gsd_accounts_signal_info_pointers,
+    (GDBusPropertyInfo **) &_gsd_accounts_property_info_pointers,
+    NULL
+  },
+  "accounts",
+};
+
+
+/**
+ * gsd_accounts_interface_info:
+ *
+ * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-Accounts.top_of_page">org.freedesktop.Accounts</link> D-Bus interface.
+ *
+ * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
+ */
+GDBusInterfaceInfo *
+gsd_accounts_interface_info (void)
+{
+  return (GDBusInterfaceInfo *) &_gsd_accounts_interface_info.parent_struct;
+}
+
+/**
+ * gsd_accounts_override_properties:
+ * @klass: The class structure for a #GObject<!-- -->-derived class.
+ * @property_id_begin: The property id to assign to the first overridden property.
+ *
+ * Overrides all #GObject properties in the #GsdAccounts interface for a concrete class.
+ * The properties are overridden in the order they are defined.
+ *
+ * Returns: The last property id.
+ */
+guint
+gsd_accounts_override_properties (GObjectClass *klass, guint property_id_begin)
+{
+  g_object_class_override_property (klass, property_id_begin++, "daemon-version");
+  g_object_class_override_property (klass, property_id_begin++, "has-no-users");
+  g_object_class_override_property (klass, property_id_begin++, "has-multiple-users");
+  return property_id_begin - 1;
+}
+
+
+
+/**
+ * GsdAccounts:
+ *
+ * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-Accounts.top_of_page">org.freedesktop.Accounts</link>.
+ */
+
+/**
+ * GsdAccountsIface:
+ * @parent_iface: The parent interface.
+ * @handle_cache_user: Handler for the #GsdAccounts::handle-cache-user signal.
+ * @handle_create_user: Handler for the #GsdAccounts::handle-create-user signal.
+ * @handle_delete_user: Handler for the #GsdAccounts::handle-delete-user signal.
+ * @handle_find_user_by_id: Handler for the #GsdAccounts::handle-find-user-by-id signal.
+ * @handle_find_user_by_name: Handler for the #GsdAccounts::handle-find-user-by-name signal.
+ * @handle_list_cached_users: Handler for the #GsdAccounts::handle-list-cached-users signal.
+ * @handle_uncache_user: Handler for the #GsdAccounts::handle-uncache-user signal.
+ * @get_daemon_version: Getter for the #GsdAccounts:daemon-version property.
+ * @get_has_multiple_users: Getter for the #GsdAccounts:has-multiple-users property.
+ * @get_has_no_users: Getter for the #GsdAccounts:has-no-users property.
+ * @user_added: Handler for the #GsdAccounts::user-added signal.
+ * @user_deleted: Handler for the #GsdAccounts::user-deleted signal.
+ *
+ * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-Accounts.top_of_page">org.freedesktop.Accounts</link>.
+ */
+
+typedef GsdAccountsIface GsdAccountsInterface;
+G_DEFINE_INTERFACE (GsdAccounts, gsd_accounts, G_TYPE_OBJECT)
+
+static void
+gsd_accounts_default_init (GsdAccountsIface *iface)
+{
+  /* GObject signals for incoming D-Bus method calls: */
+  /**
+   * GsdAccounts::handle-list-cached-users:
+   * @object: A #GsdAccounts.
+   * @invocation: A #GDBusMethodInvocation.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-Accounts.ListCachedUsers">ListCachedUsers()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call gsd_accounts_complete_list_cached_users() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-list-cached-users",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GsdAccountsIface, handle_list_cached_users),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    1,
+    G_TYPE_DBUS_METHOD_INVOCATION);
+
+  /**
+   * GsdAccounts::handle-find-user-by-id:
+   * @object: A #GsdAccounts.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_id: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-Accounts.FindUserById">FindUserById()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call gsd_accounts_complete_find_user_by_id() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-find-user-by-id",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GsdAccountsIface, handle_find_user_by_id),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_INT64);
+
+  /**
+   * GsdAccounts::handle-find-user-by-name:
+   * @object: A #GsdAccounts.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_name: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-Accounts.FindUserByName">FindUserByName()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call gsd_accounts_complete_find_user_by_name() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-find-user-by-name",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GsdAccountsIface, handle_find_user_by_name),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);
+
+  /**
+   * GsdAccounts::handle-create-user:
+   * @object: A #GsdAccounts.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_name: Argument passed by remote caller.
+   * @arg_fullname: Argument passed by remote caller.
+   * @arg_accountType: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-Accounts.CreateUser">CreateUser()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call gsd_accounts_complete_create_user() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-create-user",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GsdAccountsIface, handle_create_user),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    4,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_INT);
+
+  /**
+   * GsdAccounts::handle-cache-user:
+   * @object: A #GsdAccounts.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_name: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-Accounts.CacheUser">CacheUser()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call gsd_accounts_complete_cache_user() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-cache-user",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GsdAccountsIface, handle_cache_user),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);
+
+  /**
+   * GsdAccounts::handle-uncache-user:
+   * @object: A #GsdAccounts.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_name: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-Accounts.UncacheUser">UncacheUser()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call gsd_accounts_complete_uncache_user() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-uncache-user",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GsdAccountsIface, handle_uncache_user),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);
+
+  /**
+   * GsdAccounts::handle-delete-user:
+   * @object: A #GsdAccounts.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_id: Argument passed by remote caller.
+   * @arg_removeFiles: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-Accounts.DeleteUser">DeleteUser()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call gsd_accounts_complete_delete_user() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-delete-user",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GsdAccountsIface, handle_delete_user),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    3,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_INT64, G_TYPE_BOOLEAN);
+
+  /* GObject signals for received D-Bus signals: */
+  /**
+   * GsdAccounts::user-added:
+   * @object: A #GsdAccounts.
+   * @arg_user: Argument.
+   *
+   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-freedesktop-Accounts.UserAdded">"UserAdded"</link> is received.
+   *
+   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
+   */
+  g_signal_new ("user-added",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GsdAccountsIface, user_added),
+    NULL,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_NONE,
+    1, G_TYPE_STRING);
+
+  /**
+   * GsdAccounts::user-deleted:
+   * @object: A #GsdAccounts.
+   * @arg_user: Argument.
+   *
+   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-freedesktop-Accounts.UserDeleted">"UserDeleted"</link> is received.
+   *
+   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
+   */
+  g_signal_new ("user-deleted",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GsdAccountsIface, user_deleted),
+    NULL,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_NONE,
+    1, G_TYPE_STRING);
+
+  /* GObject properties for D-Bus properties: */
+  /**
+   * GsdAccounts:daemon-version:
+   *
+   * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-Accounts.DaemonVersion">"DaemonVersion"</link>.
+   *
+   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
+   */
+  g_object_interface_install_property (iface,
+    g_param_spec_string ("daemon-version", "DaemonVersion", "DaemonVersion", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  /**
+   * GsdAccounts:has-no-users:
+   *
+   * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-Accounts.HasNoUsers">"HasNoUsers"</link>.
+   *
+   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
+   */
+  g_object_interface_install_property (iface,
+    g_param_spec_boolean ("has-no-users", "HasNoUsers", "HasNoUsers", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  /**
+   * GsdAccounts:has-multiple-users:
+   *
+   * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-Accounts.HasMultipleUsers">"HasMultipleUsers"</link>.
+   *
+   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
+   */
+  g_object_interface_install_property (iface,
+    g_param_spec_boolean ("has-multiple-users", "HasMultipleUsers", "HasMultipleUsers", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+}
+
+/**
+ * gsd_accounts_get_daemon_version: (skip)
+ * @object: A #GsdAccounts.
+ *
+ * Gets the value of the <link linkend="gdbus-property-org-freedesktop-Accounts.DaemonVersion">"DaemonVersion"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use gsd_accounts_dup_daemon_version() if on another thread.</warning>
+ *
+ * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
+ */
+const gchar *
+gsd_accounts_get_daemon_version (GsdAccounts *object)
+{
+  return GSD_ACCOUNTS_GET_IFACE (object)->get_daemon_version (object);
+}
+
+/**
+ * gsd_accounts_dup_daemon_version: (skip)
+ * @object: A #GsdAccounts.
+ *
+ * Gets a copy of the <link linkend="gdbus-property-org-freedesktop-Accounts.DaemonVersion">"DaemonVersion"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
+ */
+gchar *
+gsd_accounts_dup_daemon_version (GsdAccounts *object)
+{
+  gchar *value;
+  g_object_get (G_OBJECT (object), "daemon-version", &value, NULL);
+  return value;
+}
+
+/**
+ * gsd_accounts_set_daemon_version: (skip)
+ * @object: A #GsdAccounts.
+ * @value: The value to set.
+ *
+ * Sets the <link linkend="gdbus-property-org-freedesktop-Accounts.DaemonVersion">"DaemonVersion"</link> D-Bus property to @value.
+ *
+ * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
+ */
+void
+gsd_accounts_set_daemon_version (GsdAccounts *object, const gchar *value)
+{
+  g_object_set (G_OBJECT (object), "daemon-version", value, NULL);
+}
+
+/**
+ * gsd_accounts_get_has_no_users: (skip)
+ * @object: A #GsdAccounts.
+ *
+ * Gets the value of the <link linkend="gdbus-property-org-freedesktop-Accounts.HasNoUsers">"HasNoUsers"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * Returns: The property value.
+ */
+gboolean
+gsd_accounts_get_has_no_users (GsdAccounts *object)
+{
+  return GSD_ACCOUNTS_GET_IFACE (object)->get_has_no_users (object);
+}
+
+/**
+ * gsd_accounts_set_has_no_users: (skip)
+ * @object: A #GsdAccounts.
+ * @value: The value to set.
+ *
+ * Sets the <link linkend="gdbus-property-org-freedesktop-Accounts.HasNoUsers">"HasNoUsers"</link> D-Bus property to @value.
+ *
+ * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
+ */
+void
+gsd_accounts_set_has_no_users (GsdAccounts *object, gboolean value)
+{
+  g_object_set (G_OBJECT (object), "has-no-users", value, NULL);
+}
+
+/**
+ * gsd_accounts_get_has_multiple_users: (skip)
+ * @object: A #GsdAccounts.
+ *
+ * Gets the value of the <link linkend="gdbus-property-org-freedesktop-Accounts.HasMultipleUsers">"HasMultipleUsers"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * Returns: The property value.
+ */
+gboolean
+gsd_accounts_get_has_multiple_users (GsdAccounts *object)
+{
+  return GSD_ACCOUNTS_GET_IFACE (object)->get_has_multiple_users (object);
+}
+
+/**
+ * gsd_accounts_set_has_multiple_users: (skip)
+ * @object: A #GsdAccounts.
+ * @value: The value to set.
+ *
+ * Sets the <link linkend="gdbus-property-org-freedesktop-Accounts.HasMultipleUsers">"HasMultipleUsers"</link> D-Bus property to @value.
+ *
+ * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
+ */
+void
+gsd_accounts_set_has_multiple_users (GsdAccounts *object, gboolean value)
+{
+  g_object_set (G_OBJECT (object), "has-multiple-users", value, NULL);
+}
+
+/**
+ * gsd_accounts_emit_user_added:
+ * @object: A #GsdAccounts.
+ * @arg_user: Argument to pass with the signal.
+ *
+ * Emits the <link linkend="gdbus-signal-org-freedesktop-Accounts.UserAdded">"UserAdded"</link> D-Bus signal.
+ */
+void
+gsd_accounts_emit_user_added (
+    GsdAccounts *object,
+    const gchar *arg_user)
+{
+  g_signal_emit_by_name (object, "user-added", arg_user);
+}
+
+/**
+ * gsd_accounts_emit_user_deleted:
+ * @object: A #GsdAccounts.
+ * @arg_user: Argument to pass with the signal.
+ *
+ * Emits the <link linkend="gdbus-signal-org-freedesktop-Accounts.UserDeleted">"UserDeleted"</link> D-Bus signal.
+ */
+void
+gsd_accounts_emit_user_deleted (
+    GsdAccounts *object,
+    const gchar *arg_user)
+{
+  g_signal_emit_by_name (object, "user-deleted", arg_user);
+}
+
+/**
+ * gsd_accounts_call_list_cached_users:
+ * @proxy: A #GsdAccountsProxy.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts.ListCachedUsers">ListCachedUsers()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call gsd_accounts_call_list_cached_users_finish() to get the result of the operation.
+ *
+ * See gsd_accounts_call_list_cached_users_sync() for the synchronous, blocking version of this method.
+ */
+void
+gsd_accounts_call_list_cached_users (
+    GsdAccounts *proxy,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "ListCachedUsers",
+    g_variant_new ("()"),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * gsd_accounts_call_list_cached_users_finish:
+ * @proxy: A #GsdAccountsProxy.
+ * @out_users: (out): Return location for return parameter or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gsd_accounts_call_list_cached_users().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with gsd_accounts_call_list_cached_users().
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_call_list_cached_users_finish (
+    GsdAccounts *proxy,
+    gchar ***out_users,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(^ao)",
+                 out_users);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_call_list_cached_users_sync:
+ * @proxy: A #GsdAccountsProxy.
+ * @out_users: (out): Return location for return parameter or %NULL to ignore.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts.ListCachedUsers">ListCachedUsers()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See gsd_accounts_call_list_cached_users() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_call_list_cached_users_sync (
+    GsdAccounts *proxy,
+    gchar ***out_users,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "ListCachedUsers",
+    g_variant_new ("()"),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(^ao)",
+                 out_users);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_call_find_user_by_id:
+ * @proxy: A #GsdAccountsProxy.
+ * @arg_id: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts.FindUserById">FindUserById()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call gsd_accounts_call_find_user_by_id_finish() to get the result of the operation.
+ *
+ * See gsd_accounts_call_find_user_by_id_sync() for the synchronous, blocking version of this method.
+ */
+void
+gsd_accounts_call_find_user_by_id (
+    GsdAccounts *proxy,
+    gint64 arg_id,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "FindUserById",
+    g_variant_new ("(x)",
+                   arg_id),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * gsd_accounts_call_find_user_by_id_finish:
+ * @proxy: A #GsdAccountsProxy.
+ * @out_user: (out): Return location for return parameter or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gsd_accounts_call_find_user_by_id().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with gsd_accounts_call_find_user_by_id().
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_call_find_user_by_id_finish (
+    GsdAccounts *proxy,
+    gchar **out_user,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(o)",
+                 out_user);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_call_find_user_by_id_sync:
+ * @proxy: A #GsdAccountsProxy.
+ * @arg_id: Argument to pass with the method invocation.
+ * @out_user: (out): Return location for return parameter or %NULL to ignore.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts.FindUserById">FindUserById()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See gsd_accounts_call_find_user_by_id() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_call_find_user_by_id_sync (
+    GsdAccounts *proxy,
+    gint64 arg_id,
+    gchar **out_user,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "FindUserById",
+    g_variant_new ("(x)",
+                   arg_id),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(o)",
+                 out_user);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_call_find_user_by_name:
+ * @proxy: A #GsdAccountsProxy.
+ * @arg_name: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts.FindUserByName">FindUserByName()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call gsd_accounts_call_find_user_by_name_finish() to get the result of the operation.
+ *
+ * See gsd_accounts_call_find_user_by_name_sync() for the synchronous, blocking version of this method.
+ */
+void
+gsd_accounts_call_find_user_by_name (
+    GsdAccounts *proxy,
+    const gchar *arg_name,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "FindUserByName",
+    g_variant_new ("(s)",
+                   arg_name),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * gsd_accounts_call_find_user_by_name_finish:
+ * @proxy: A #GsdAccountsProxy.
+ * @out_user: (out): Return location for return parameter or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gsd_accounts_call_find_user_by_name().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with gsd_accounts_call_find_user_by_name().
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_call_find_user_by_name_finish (
+    GsdAccounts *proxy,
+    gchar **out_user,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(o)",
+                 out_user);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_call_find_user_by_name_sync:
+ * @proxy: A #GsdAccountsProxy.
+ * @arg_name: Argument to pass with the method invocation.
+ * @out_user: (out): Return location for return parameter or %NULL to ignore.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts.FindUserByName">FindUserByName()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See gsd_accounts_call_find_user_by_name() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_call_find_user_by_name_sync (
+    GsdAccounts *proxy,
+    const gchar *arg_name,
+    gchar **out_user,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "FindUserByName",
+    g_variant_new ("(s)",
+                   arg_name),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(o)",
+                 out_user);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_call_create_user:
+ * @proxy: A #GsdAccountsProxy.
+ * @arg_name: Argument to pass with the method invocation.
+ * @arg_fullname: Argument to pass with the method invocation.
+ * @arg_accountType: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts.CreateUser">CreateUser()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call gsd_accounts_call_create_user_finish() to get the result of the operation.
+ *
+ * See gsd_accounts_call_create_user_sync() for the synchronous, blocking version of this method.
+ */
+void
+gsd_accounts_call_create_user (
+    GsdAccounts *proxy,
+    const gchar *arg_name,
+    const gchar *arg_fullname,
+    gint arg_accountType,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "CreateUser",
+    g_variant_new ("(ssi)",
+                   arg_name,
+                   arg_fullname,
+                   arg_accountType),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * gsd_accounts_call_create_user_finish:
+ * @proxy: A #GsdAccountsProxy.
+ * @out_user: (out): Return location for return parameter or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gsd_accounts_call_create_user().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with gsd_accounts_call_create_user().
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_call_create_user_finish (
+    GsdAccounts *proxy,
+    gchar **out_user,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(o)",
+                 out_user);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_call_create_user_sync:
+ * @proxy: A #GsdAccountsProxy.
+ * @arg_name: Argument to pass with the method invocation.
+ * @arg_fullname: Argument to pass with the method invocation.
+ * @arg_accountType: Argument to pass with the method invocation.
+ * @out_user: (out): Return location for return parameter or %NULL to ignore.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts.CreateUser">CreateUser()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See gsd_accounts_call_create_user() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_call_create_user_sync (
+    GsdAccounts *proxy,
+    const gchar *arg_name,
+    const gchar *arg_fullname,
+    gint arg_accountType,
+    gchar **out_user,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "CreateUser",
+    g_variant_new ("(ssi)",
+                   arg_name,
+                   arg_fullname,
+                   arg_accountType),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(o)",
+                 out_user);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_call_cache_user:
+ * @proxy: A #GsdAccountsProxy.
+ * @arg_name: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts.CacheUser">CacheUser()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call gsd_accounts_call_cache_user_finish() to get the result of the operation.
+ *
+ * See gsd_accounts_call_cache_user_sync() for the synchronous, blocking version of this method.
+ */
+void
+gsd_accounts_call_cache_user (
+    GsdAccounts *proxy,
+    const gchar *arg_name,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "CacheUser",
+    g_variant_new ("(s)",
+                   arg_name),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * gsd_accounts_call_cache_user_finish:
+ * @proxy: A #GsdAccountsProxy.
+ * @out_user: (out): Return location for return parameter or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gsd_accounts_call_cache_user().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with gsd_accounts_call_cache_user().
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_call_cache_user_finish (
+    GsdAccounts *proxy,
+    gchar **out_user,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(o)",
+                 out_user);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_call_cache_user_sync:
+ * @proxy: A #GsdAccountsProxy.
+ * @arg_name: Argument to pass with the method invocation.
+ * @out_user: (out): Return location for return parameter or %NULL to ignore.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts.CacheUser">CacheUser()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See gsd_accounts_call_cache_user() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_call_cache_user_sync (
+    GsdAccounts *proxy,
+    const gchar *arg_name,
+    gchar **out_user,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "CacheUser",
+    g_variant_new ("(s)",
+                   arg_name),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(o)",
+                 out_user);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_call_uncache_user:
+ * @proxy: A #GsdAccountsProxy.
+ * @arg_name: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts.UncacheUser">UncacheUser()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call gsd_accounts_call_uncache_user_finish() to get the result of the operation.
+ *
+ * See gsd_accounts_call_uncache_user_sync() for the synchronous, blocking version of this method.
+ */
+void
+gsd_accounts_call_uncache_user (
+    GsdAccounts *proxy,
+    const gchar *arg_name,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "UncacheUser",
+    g_variant_new ("(s)",
+                   arg_name),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * gsd_accounts_call_uncache_user_finish:
+ * @proxy: A #GsdAccountsProxy.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gsd_accounts_call_uncache_user().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with gsd_accounts_call_uncache_user().
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_call_uncache_user_finish (
+    GsdAccounts *proxy,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_call_uncache_user_sync:
+ * @proxy: A #GsdAccountsProxy.
+ * @arg_name: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts.UncacheUser">UncacheUser()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See gsd_accounts_call_uncache_user() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_call_uncache_user_sync (
+    GsdAccounts *proxy,
+    const gchar *arg_name,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "UncacheUser",
+    g_variant_new ("(s)",
+                   arg_name),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_call_delete_user:
+ * @proxy: A #GsdAccountsProxy.
+ * @arg_id: Argument to pass with the method invocation.
+ * @arg_removeFiles: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts.DeleteUser">DeleteUser()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call gsd_accounts_call_delete_user_finish() to get the result of the operation.
+ *
+ * See gsd_accounts_call_delete_user_sync() for the synchronous, blocking version of this method.
+ */
+void
+gsd_accounts_call_delete_user (
+    GsdAccounts *proxy,
+    gint64 arg_id,
+    gboolean arg_removeFiles,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "DeleteUser",
+    g_variant_new ("(xb)",
+                   arg_id,
+                   arg_removeFiles),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * gsd_accounts_call_delete_user_finish:
+ * @proxy: A #GsdAccountsProxy.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gsd_accounts_call_delete_user().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with gsd_accounts_call_delete_user().
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_call_delete_user_finish (
+    GsdAccounts *proxy,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_call_delete_user_sync:
+ * @proxy: A #GsdAccountsProxy.
+ * @arg_id: Argument to pass with the method invocation.
+ * @arg_removeFiles: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-Accounts.DeleteUser">DeleteUser()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See gsd_accounts_call_delete_user() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+gsd_accounts_call_delete_user_sync (
+    GsdAccounts *proxy,
+    gint64 arg_id,
+    gboolean arg_removeFiles,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "DeleteUser",
+    g_variant_new ("(xb)",
+                   arg_id,
+                   arg_removeFiles),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gsd_accounts_complete_list_cached_users:
+ * @object: A #GsdAccounts.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @users: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-Accounts.ListCachedUsers">ListCachedUsers()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+gsd_accounts_complete_list_cached_users (
+    GsdAccounts *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *const *users)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("(^ao)",
+                   users));
+}
+
+/**
+ * gsd_accounts_complete_find_user_by_id:
+ * @object: A #GsdAccounts.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @user: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-Accounts.FindUserById">FindUserById()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+gsd_accounts_complete_find_user_by_id (
+    GsdAccounts *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *user)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("(o)",
+                   user));
+}
+
+/**
+ * gsd_accounts_complete_find_user_by_name:
+ * @object: A #GsdAccounts.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @user: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-Accounts.FindUserByName">FindUserByName()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+gsd_accounts_complete_find_user_by_name (
+    GsdAccounts *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *user)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("(o)",
+                   user));
+}
+
+/**
+ * gsd_accounts_complete_create_user:
+ * @object: A #GsdAccounts.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @user: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-Accounts.CreateUser">CreateUser()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+gsd_accounts_complete_create_user (
+    GsdAccounts *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *user)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("(o)",
+                   user));
+}
+
+/**
+ * gsd_accounts_complete_cache_user:
+ * @object: A #GsdAccounts.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @user: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-Accounts.CacheUser">CacheUser()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+gsd_accounts_complete_cache_user (
+    GsdAccounts *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *user)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("(o)",
+                   user));
+}
+
+/**
+ * gsd_accounts_complete_uncache_user:
+ * @object: A #GsdAccounts.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-Accounts.UncacheUser">UncacheUser()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+gsd_accounts_complete_uncache_user (
+    GsdAccounts *object,
+    GDBusMethodInvocation *invocation)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("()"));
+}
+
+/**
+ * gsd_accounts_complete_delete_user:
+ * @object: A #GsdAccounts.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-Accounts.DeleteUser">DeleteUser()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+gsd_accounts_complete_delete_user (
+    GsdAccounts *object,
+    GDBusMethodInvocation *invocation)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("()"));
+}
+
+/* ------------------------------------------------------------------------ */
+
+/**
+ * GsdAccountsProxy:
+ *
+ * The #GsdAccountsProxy structure contains only private data and should only be accessed using the provided API.
+ */
+
+/**
+ * GsdAccountsProxyClass:
+ * @parent_class: The parent class.
+ *
+ * Class structure for #GsdAccountsProxy.
+ */
+
+struct _GsdAccountsProxyPrivate
+{
+  GData *qdata;
+};
+
+static void gsd_accounts_proxy_iface_init (GsdAccountsIface *iface);
+
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+G_DEFINE_TYPE_WITH_CODE (GsdAccountsProxy, gsd_accounts_proxy, G_TYPE_DBUS_PROXY,
+                         G_ADD_PRIVATE (GsdAccountsProxy)
+                         G_IMPLEMENT_INTERFACE (GSD_TYPE_ACCOUNTS, gsd_accounts_proxy_iface_init))
+
+#else
+G_DEFINE_TYPE_WITH_CODE (GsdAccountsProxy, gsd_accounts_proxy, G_TYPE_DBUS_PROXY,
+                         G_IMPLEMENT_INTERFACE (GSD_TYPE_ACCOUNTS, gsd_accounts_proxy_iface_init))
+
+#endif
+static void
+gsd_accounts_proxy_finalize (GObject *object)
+{
+  GsdAccountsProxy *proxy = GSD_ACCOUNTS_PROXY (object);
+  g_datalist_clear (&proxy->priv->qdata);
+  G_OBJECT_CLASS (gsd_accounts_proxy_parent_class)->finalize (object);
+}
+
+static void
+gsd_accounts_proxy_get_property (GObject      *object,
+  guint         prop_id,
+  GValue       *value,
+  GParamSpec   *pspec G_GNUC_UNUSED)
+{
+  const _ExtendedGDBusPropertyInfo *info;
+  GVariant *variant;
+  g_assert (prop_id != 0 && prop_id - 1 < 3);
+  info = _gsd_accounts_property_info_pointers[prop_id - 1];
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
+  if (info->use_gvariant)
+    {
+      g_value_set_variant (value, variant);
+    }
+  else
+    {
+      if (variant != NULL)
+        g_dbus_gvariant_to_gvalue (variant, value);
+    }
+  if (variant != NULL)
+    g_variant_unref (variant);
+}
+
+static void
+gsd_accounts_proxy_set_property_cb (GDBusProxy *proxy,
+  GAsyncResult *res,
+  gpointer      user_data)
+{
+  const _ExtendedGDBusPropertyInfo *info = user_data;
+  GError *error;
+  GVariant *_ret;
+  error = NULL;
+  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
+  if (!_ret)
+    {
+      g_warning ("Error setting property '%s' on interface org.freedesktop.Accounts: %s (%s, %d)",
+                 info->parent_struct.name,
+                 error->message, g_quark_to_string (error->domain), error->code);
+      g_error_free (error);
+    }
+  else
+    {
+      g_variant_unref (_ret);
+    }
+}
+
+static void
+gsd_accounts_proxy_set_property (GObject      *object,
+  guint         prop_id,
+  const GValue *value,
+  GParamSpec   *pspec G_GNUC_UNUSED)
+{
+  const _ExtendedGDBusPropertyInfo *info;
+  GVariant *variant;
+  g_assert (prop_id != 0 && prop_id - 1 < 3);
+  info = _gsd_accounts_property_info_pointers[prop_id - 1];
+  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
+  g_dbus_proxy_call (G_DBUS_PROXY (object),
+    "org.freedesktop.DBus.Properties.Set",
+    g_variant_new ("(ssv)", "org.freedesktop.Accounts", info->parent_struct.name, variant),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    NULL, (GAsyncReadyCallback) gsd_accounts_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
+  g_variant_unref (variant);
+}
+
+static void
+gsd_accounts_proxy_g_signal (GDBusProxy *proxy,
+  const gchar *sender_name G_GNUC_UNUSED,
+  const gchar *signal_name,
+  GVariant *parameters)
+{
+  _ExtendedGDBusSignalInfo *info;
+  GVariantIter iter;
+  GVariant *child;
+  GValue *paramv;
+  gsize num_params;
+  gsize n;
+  guint signal_id;
+  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_gsd_accounts_interface_info.parent_struct, signal_name);
+  if (info == NULL)
+    return;
+  num_params = g_variant_n_children (parameters);
+  paramv = g_new0 (GValue, num_params + 1);
+  g_value_init (&paramv[0], GSD_TYPE_ACCOUNTS);
+  g_value_set_object (&paramv[0], proxy);
+  g_variant_iter_init (&iter, parameters);
+  n = 1;
+  while ((child = g_variant_iter_next_value (&iter)) != NULL)
+    {
+      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
+      if (arg_info->use_gvariant)
+        {
+          g_value_init (&paramv[n], G_TYPE_VARIANT);
+          g_value_set_variant (&paramv[n], child);
+          n++;
+        }
+      else
+        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
+      g_variant_unref (child);
+    }
+  signal_id = g_signal_lookup (info->signal_name, GSD_TYPE_ACCOUNTS);
+  g_signal_emitv (paramv, signal_id, 0, NULL);
+  for (n = 0; n < num_params + 1; n++)
+    g_value_unset (&paramv[n]);
+  g_free (paramv);
+}
+
+static void
+gsd_accounts_proxy_g_properties_changed (GDBusProxy *_proxy,
+  GVariant *changed_properties,
+  const gchar *const *invalidated_properties)
+{
+  GsdAccountsProxy *proxy = GSD_ACCOUNTS_PROXY (_proxy);
+  guint n;
+  const gchar *key;
+  GVariantIter *iter;
+  _ExtendedGDBusPropertyInfo *info;
+  g_variant_get (changed_properties, "a{sv}", &iter);
+  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
+    {
+      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_gsd_accounts_interface_info.parent_struct, key);
+      g_datalist_remove_data (&proxy->priv->qdata, key);
+      if (info != NULL)
+        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
+    }
+  g_variant_iter_free (iter);
+  for (n = 0; invalidated_properties[n] != NULL; n++)
+    {
+      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_gsd_accounts_interface_info.parent_struct, invalidated_properties[n]);
+      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
+      if (info != NULL)
+        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
+    }
+}
+
+static const gchar *
+gsd_accounts_proxy_get_daemon_version (GsdAccounts *object)
+{
+  GsdAccountsProxy *proxy = GSD_ACCOUNTS_PROXY (object);
+  GVariant *variant;
+  const gchar *value = NULL;
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "DaemonVersion");
+  if (variant != NULL)
+    {
+      value = g_variant_get_string (variant, NULL);
+      g_variant_unref (variant);
+    }
+  return value;
+}
+
+static gboolean
+gsd_accounts_proxy_get_has_no_users (GsdAccounts *object)
+{
+  GsdAccountsProxy *proxy = GSD_ACCOUNTS_PROXY (object);
+  GVariant *variant;
+  gboolean value = 0;
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "HasNoUsers");
+  if (variant != NULL)
+    {
+      value = g_variant_get_boolean (variant);
+      g_variant_unref (variant);
+    }
+  return value;
+}
+
+static gboolean
+gsd_accounts_proxy_get_has_multiple_users (GsdAccounts *object)
+{
+  GsdAccountsProxy *proxy = GSD_ACCOUNTS_PROXY (object);
+  GVariant *variant;
+  gboolean value = 0;
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "HasMultipleUsers");
+  if (variant != NULL)
+    {
+      value = g_variant_get_boolean (variant);
+      g_variant_unref (variant);
+    }
+  return value;
+}
+
+static void
+gsd_accounts_proxy_init (GsdAccountsProxy *proxy)
+{
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+  proxy->priv = gsd_accounts_proxy_get_instance_private (proxy);
+#else
+  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, GSD_TYPE_ACCOUNTS_PROXY, GsdAccountsProxyPrivate);
+#endif
+
+  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), gsd_accounts_interface_info ());
+}
+
+static void
+gsd_accounts_proxy_class_init (GsdAccountsProxyClass *klass)
+{
+  GObjectClass *gobject_class;
+  GDBusProxyClass *proxy_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  gobject_class->finalize     = gsd_accounts_proxy_finalize;
+  gobject_class->get_property = gsd_accounts_proxy_get_property;
+  gobject_class->set_property = gsd_accounts_proxy_set_property;
+
+  proxy_class = G_DBUS_PROXY_CLASS (klass);
+  proxy_class->g_signal = gsd_accounts_proxy_g_signal;
+  proxy_class->g_properties_changed = gsd_accounts_proxy_g_properties_changed;
+
+  gsd_accounts_override_properties (gobject_class, 1);
+
+#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
+  g_type_class_add_private (klass, sizeof (GsdAccountsProxyPrivate));
+#endif
+}
+
+static void
+gsd_accounts_proxy_iface_init (GsdAccountsIface *iface)
+{
+  iface->get_daemon_version = gsd_accounts_proxy_get_daemon_version;
+  iface->get_has_no_users = gsd_accounts_proxy_get_has_no_users;
+  iface->get_has_multiple_users = gsd_accounts_proxy_get_has_multiple_users;
+}
+
+/**
+ * gsd_accounts_proxy_new:
+ * @connection: A #GDBusConnection.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
+ * @object_path: An object path.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-Accounts.top_of_page">org.freedesktop.Accounts</link>. See g_dbus_proxy_new() for more details.
+ *
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call gsd_accounts_proxy_new_finish() to get the result of the operation.
+ *
+ * See gsd_accounts_proxy_new_sync() for the synchronous, blocking version of this constructor.
+ */
+void
+gsd_accounts_proxy_new (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data)
+{
+  g_async_initable_new_async (GSD_TYPE_ACCOUNTS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.freedesktop.Accounts", NULL);
+}
+
+/**
+ * gsd_accounts_proxy_new_finish:
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gsd_accounts_proxy_new().
+ * @error: Return location for error or %NULL
+ *
+ * Finishes an operation started with gsd_accounts_proxy_new().
+ *
+ * Returns: (transfer full) (type GsdAccountsProxy): The constructed proxy object or %NULL if @error is set.
+ */
+GsdAccounts *
+gsd_accounts_proxy_new_finish (
+    GAsyncResult        *res,
+    GError             **error)
+{
+  GObject *ret;
+  GObject *source_object;
+  source_object = g_async_result_get_source_object (res);
+  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
+  g_object_unref (source_object);
+  if (ret != NULL)
+    return GSD_ACCOUNTS (ret);
+  else
+    return NULL;
+}
+
+/**
+ * gsd_accounts_proxy_new_sync:
+ * @connection: A #GDBusConnection.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
+ * @object_path: An object path.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL
+ *
+ * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-Accounts.top_of_page">org.freedesktop.Accounts</link>. See g_dbus_proxy_new_sync() for more details.
+ *
+ * The calling thread is blocked until a reply is received.
+ *
+ * See gsd_accounts_proxy_new() for the asynchronous version of this constructor.
+ *
+ * Returns: (transfer full) (type GsdAccountsProxy): The constructed proxy object or %NULL if @error is set.
+ */
+GsdAccounts *
+gsd_accounts_proxy_new_sync (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error)
+{
+  GInitable *ret;
+  ret = g_initable_new (GSD_TYPE_ACCOUNTS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.freedesktop.Accounts", NULL);
+  if (ret != NULL)
+    return GSD_ACCOUNTS (ret);
+  else
+    return NULL;
+}
+
+
+/**
+ * gsd_accounts_proxy_new_for_bus:
+ * @bus_type: A #GBusType.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: A bus name (well-known or unique).
+ * @object_path: An object path.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
+ * @user_data: User data to pass to @callback.
+ *
+ * Like gsd_accounts_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
+ *
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call gsd_accounts_proxy_new_for_bus_finish() to get the result of the operation.
+ *
+ * See gsd_accounts_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
+ */
+void
+gsd_accounts_proxy_new_for_bus (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data)
+{
+  g_async_initable_new_async (GSD_TYPE_ACCOUNTS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.freedesktop.Accounts", NULL);
+}
+
+/**
+ * gsd_accounts_proxy_new_for_bus_finish:
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gsd_accounts_proxy_new_for_bus().
+ * @error: Return location for error or %NULL
+ *
+ * Finishes an operation started with gsd_accounts_proxy_new_for_bus().
+ *
+ * Returns: (transfer full) (type GsdAccountsProxy): The constructed proxy object or %NULL if @error is set.
+ */
+GsdAccounts *
+gsd_accounts_proxy_new_for_bus_finish (
+    GAsyncResult        *res,
+    GError             **error)
+{
+  GObject *ret;
+  GObject *source_object;
+  source_object = g_async_result_get_source_object (res);
+  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
+  g_object_unref (source_object);
+  if (ret != NULL)
+    return GSD_ACCOUNTS (ret);
+  else
+    return NULL;
+}
+
+/**
+ * gsd_accounts_proxy_new_for_bus_sync:
+ * @bus_type: A #GBusType.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: A bus name (well-known or unique).
+ * @object_path: An object path.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL
+ *
+ * Like gsd_accounts_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
+ *
+ * The calling thread is blocked until a reply is received.
+ *
+ * See gsd_accounts_proxy_new_for_bus() for the asynchronous version of this constructor.
+ *
+ * Returns: (transfer full) (type GsdAccountsProxy): The constructed proxy object or %NULL if @error is set.
+ */
+GsdAccounts *
+gsd_accounts_proxy_new_for_bus_sync (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error)
+{
+  GInitable *ret;
+  ret = g_initable_new (GSD_TYPE_ACCOUNTS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.freedesktop.Accounts", NULL);
+  if (ret != NULL)
+    return GSD_ACCOUNTS (ret);
+  else
+    return NULL;
+}
+
+
+/* ------------------------------------------------------------------------ */
+
+/**
+ * GsdAccountsSkeleton:
+ *
+ * The #GsdAccountsSkeleton structure contains only private data and should only be accessed using the provided API.
+ */
+
+/**
+ * GsdAccountsSkeletonClass:
+ * @parent_class: The parent class.
+ *
+ * Class structure for #GsdAccountsSkeleton.
+ */
+
+struct _GsdAccountsSkeletonPrivate
+{
+  GValue *properties;
+  GList *changed_properties;
+  GSource *changed_properties_idle_source;
+  GMainContext *context;
+  GMutex lock;
+};
+
+static void
+_gsd_accounts_skeleton_handle_method_call (
+  GDBusConnection *connection G_GNUC_UNUSED,
+  const gchar *sender G_GNUC_UNUSED,
+  const gchar *object_path G_GNUC_UNUSED,
+  const gchar *interface_name,
+  const gchar *method_name,
+  GVariant *parameters,
+  GDBusMethodInvocation *invocation,
+  gpointer user_data)
+{
+  GsdAccountsSkeleton *skeleton = GSD_ACCOUNTS_SKELETON (user_data);
+  _ExtendedGDBusMethodInfo *info;
+  GVariantIter iter;
+  GVariant *child;
+  GValue *paramv;
+  gsize num_params;
+  guint num_extra;
+  gsize n;
+  guint signal_id;
+  GValue return_value = G_VALUE_INIT;
+  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
+  g_assert (info != NULL);
+  num_params = g_variant_n_children (parameters);
+  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
+  n = 0;
+  g_value_init (&paramv[n], GSD_TYPE_ACCOUNTS);
+  g_value_set_object (&paramv[n++], skeleton);
+  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
+  g_value_set_object (&paramv[n++], invocation);
+  if (info->pass_fdlist)
+    {
+#ifdef G_OS_UNIX
+      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
+      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
+#else
+      g_assert_not_reached ();
+#endif
+    }
+  g_variant_iter_init (&iter, parameters);
+  while ((child = g_variant_iter_next_value (&iter)) != NULL)
+    {
+      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
+      if (arg_info->use_gvariant)
+        {
+          g_value_init (&paramv[n], G_TYPE_VARIANT);
+          g_value_set_variant (&paramv[n], child);
+          n++;
+        }
+      else
+        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
+      g_variant_unref (child);
+    }
+  signal_id = g_signal_lookup (info->signal_name, GSD_TYPE_ACCOUNTS);
+  g_value_init (&return_value, G_TYPE_BOOLEAN);
+  g_signal_emitv (paramv, signal_id, 0, &return_value);
+  if (!g_value_get_boolean (&return_value))
+    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
+  g_value_unset (&return_value);
+  for (n = 0; n < num_params + num_extra; n++)
+    g_value_unset (&paramv[n]);
+  g_free (paramv);
+}
+
+static GVariant *
+_gsd_accounts_skeleton_handle_get_property (
+  GDBusConnection *connection G_GNUC_UNUSED,
+  const gchar *sender G_GNUC_UNUSED,
+  const gchar *object_path G_GNUC_UNUSED,
+  const gchar *interface_name G_GNUC_UNUSED,
+  const gchar *property_name,
+  GError **error,
+  gpointer user_data)
+{
+  GsdAccountsSkeleton *skeleton = GSD_ACCOUNTS_SKELETON (user_data);
+  GValue value = G_VALUE_INIT;
+  GParamSpec *pspec;
+  _ExtendedGDBusPropertyInfo *info;
+  GVariant *ret;
+  ret = NULL;
+  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_gsd_accounts_interface_info.parent_struct, property_name);
+  g_assert (info != NULL);
+  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
+  if (pspec == NULL)
+    {
+      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
+    }
+  else
+    {
+      g_value_init (&value, pspec->value_type);
+      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
+      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
+      g_value_unset (&value);
+    }
+  return ret;
+}
+
+static gboolean
+_gsd_accounts_skeleton_handle_set_property (
+  GDBusConnection *connection G_GNUC_UNUSED,
+  const gchar *sender G_GNUC_UNUSED,
+  const gchar *object_path G_GNUC_UNUSED,
+  const gchar *interface_name G_GNUC_UNUSED,
+  const gchar *property_name,
+  GVariant *variant,
+  GError **error,
+  gpointer user_data)
+{
+  GsdAccountsSkeleton *skeleton = GSD_ACCOUNTS_SKELETON (user_data);
+  GValue value = G_VALUE_INIT;
+  GParamSpec *pspec;
+  _ExtendedGDBusPropertyInfo *info;
+  gboolean ret;
+  ret = FALSE;
+  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_gsd_accounts_interface_info.parent_struct, property_name);
+  g_assert (info != NULL);
+  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
+  if (pspec == NULL)
+    {
+      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
+    }
+  else
+    {
+      if (info->use_gvariant)
+        g_value_set_variant (&value, variant);
+      else
+        g_dbus_gvariant_to_gvalue (variant, &value);
+      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
+      g_value_unset (&value);
+      ret = TRUE;
+    }
+  return ret;
+}
+
+static const GDBusInterfaceVTable _gsd_accounts_skeleton_vtable =
+{
+  _gsd_accounts_skeleton_handle_method_call,
+  _gsd_accounts_skeleton_handle_get_property,
+  _gsd_accounts_skeleton_handle_set_property,
+  {NULL}
+};
+
+static GDBusInterfaceInfo *
+gsd_accounts_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
+{
+  return gsd_accounts_interface_info ();
+}
+
+static GDBusInterfaceVTable *
+gsd_accounts_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
+{
+  return (GDBusInterfaceVTable *) &_gsd_accounts_skeleton_vtable;
+}
+
+static GVariant *
+gsd_accounts_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
+{
+  GsdAccountsSkeleton *skeleton = GSD_ACCOUNTS_SKELETON (_skeleton);
+
+  GVariantBuilder builder;
+  guint n;
+  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
+  if (_gsd_accounts_interface_info.parent_struct.properties == NULL)
+    goto out;
+  for (n = 0; _gsd_accounts_interface_info.parent_struct.properties[n] != NULL; n++)
+    {
+      GDBusPropertyInfo *info = _gsd_accounts_interface_info.parent_struct.properties[n];
+      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
+        {
+          GVariant *value;
+          value = _gsd_accounts_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.freedesktop.Accounts", info->name, NULL, skeleton);
+          if (value != NULL)
+            {
+              g_variant_take_ref (value);
+              g_variant_builder_add (&builder, "{sv}", info->name, value);
+              g_variant_unref (value);
+            }
+        }
+    }
+out:
+  return g_variant_builder_end (&builder);
+}
+
+static gboolean _gsd_accounts_emit_changed (gpointer user_data);
+
+static void
+gsd_accounts_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
+{
+  GsdAccountsSkeleton *skeleton = GSD_ACCOUNTS_SKELETON (_skeleton);
+  gboolean emit_changed = FALSE;
+
+  g_mutex_lock (&skeleton->priv->lock);
+  if (skeleton->priv->changed_properties_idle_source != NULL)
+    {
+      g_source_destroy (skeleton->priv->changed_properties_idle_source);
+      skeleton->priv->changed_properties_idle_source = NULL;
+      emit_changed = TRUE;
+    }
+  g_mutex_unlock (&skeleton->priv->lock);
+
+  if (emit_changed)
+    _gsd_accounts_emit_changed (skeleton);
+}
+
+static void
+_gsd_accounts_on_signal_user_added (
+    GsdAccounts *object,
+    const gchar *arg_user)
+{
+  GsdAccountsSkeleton *skeleton = GSD_ACCOUNTS_SKELETON (object);
+
+  GList      *connections, *l;
+  GVariant   *signal_variant;
+  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
+
+  signal_variant = g_variant_ref_sink (g_variant_new ("(o)",
+                   arg_user));
+  for (l = connections; l != NULL; l = l->next)
+    {
+      GDBusConnection *connection = l->data;
+      g_dbus_connection_emit_signal (connection,
+        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.freedesktop.Accounts", "UserAdded",
+        signal_variant, NULL);
+    }
+  g_variant_unref (signal_variant);
+  g_list_free_full (connections, g_object_unref);
+}
+
+static void
+_gsd_accounts_on_signal_user_deleted (
+    GsdAccounts *object,
+    const gchar *arg_user)
+{
+  GsdAccountsSkeleton *skeleton = GSD_ACCOUNTS_SKELETON (object);
+
+  GList      *connections, *l;
+  GVariant   *signal_variant;
+  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
+
+  signal_variant = g_variant_ref_sink (g_variant_new ("(o)",
+                   arg_user));
+  for (l = connections; l != NULL; l = l->next)
+    {
+      GDBusConnection *connection = l->data;
+      g_dbus_connection_emit_signal (connection,
+        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.freedesktop.Accounts", "UserDeleted",
+        signal_variant, NULL);
+    }
+  g_variant_unref (signal_variant);
+  g_list_free_full (connections, g_object_unref);
+}
+
+static void gsd_accounts_skeleton_iface_init (GsdAccountsIface *iface);
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+G_DEFINE_TYPE_WITH_CODE (GsdAccountsSkeleton, gsd_accounts_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
+                         G_ADD_PRIVATE (GsdAccountsSkeleton)
+                         G_IMPLEMENT_INTERFACE (GSD_TYPE_ACCOUNTS, gsd_accounts_skeleton_iface_init))
+
+#else
+G_DEFINE_TYPE_WITH_CODE (GsdAccountsSkeleton, gsd_accounts_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
+                         G_IMPLEMENT_INTERFACE (GSD_TYPE_ACCOUNTS, gsd_accounts_skeleton_iface_init))
+
+#endif
+static void
+gsd_accounts_skeleton_finalize (GObject *object)
+{
+  GsdAccountsSkeleton *skeleton = GSD_ACCOUNTS_SKELETON (object);
+  guint n;
+  for (n = 0; n < 3; n++)
+    g_value_unset (&skeleton->priv->properties[n]);
+  g_free (skeleton->priv->properties);
+  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
+  if (skeleton->priv->changed_properties_idle_source != NULL)
+    g_source_destroy (skeleton->priv->changed_properties_idle_source);
+  g_main_context_unref (skeleton->priv->context);
+  g_mutex_clear (&skeleton->priv->lock);
+  G_OBJECT_CLASS (gsd_accounts_skeleton_parent_class)->finalize (object);
+}
+
+static void
+gsd_accounts_skeleton_get_property (GObject      *object,
+  guint         prop_id,
+  GValue       *value,
+  GParamSpec   *pspec G_GNUC_UNUSED)
+{
+  GsdAccountsSkeleton *skeleton = GSD_ACCOUNTS_SKELETON (object);
+  g_assert (prop_id != 0 && prop_id - 1 < 3);
+  g_mutex_lock (&skeleton->priv->lock);
+  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
+  g_mutex_unlock (&skeleton->priv->lock);
+}
+
+static gboolean
+_gsd_accounts_emit_changed (gpointer user_data)
+{
+  GsdAccountsSkeleton *skeleton = GSD_ACCOUNTS_SKELETON (user_data);
+  GList *l;
+  GVariantBuilder builder;
+  GVariantBuilder invalidated_builder;
+  guint num_changes;
+
+  g_mutex_lock (&skeleton->priv->lock);
+  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
+  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
+  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
+    {
+      ChangedProperty *cp = l->data;
+      GVariant *variant;
+      const GValue *cur_value;
+
+      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
+      if (!_g_value_equal (cur_value, &cp->orig_value))
+        {
+          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
+          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
+          g_variant_unref (variant);
+          num_changes++;
+        }
+    }
+  if (num_changes > 0)
+    {
+      GList *connections, *ll;
+      GVariant *signal_variant;
+      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "org.freedesktop.Accounts",
+                                           &builder, &invalidated_builder));
+      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
+      for (ll = connections; ll != NULL; ll = ll->next)
+        {
+          GDBusConnection *connection = ll->data;
+
+          g_dbus_connection_emit_signal (connection,
+                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
+                                         "org.freedesktop.DBus.Properties",
+                                         "PropertiesChanged",
+                                         signal_variant,
+                                         NULL);
+        }
+      g_variant_unref (signal_variant);
+      g_list_free_full (connections, g_object_unref);
+    }
+  else
+    {
+      g_variant_builder_clear (&builder);
+      g_variant_builder_clear (&invalidated_builder);
+    }
+  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
+  skeleton->priv->changed_properties = NULL;
+  skeleton->priv->changed_properties_idle_source = NULL;
+  g_mutex_unlock (&skeleton->priv->lock);
+  return FALSE;
+}
+
+static void
+_gsd_accounts_schedule_emit_changed (GsdAccountsSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
+{
+  ChangedProperty *cp;
+  GList *l;
+  cp = NULL;
+  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
+    {
+      ChangedProperty *i_cp = l->data;
+      if (i_cp->info == info)
+        {
+          cp = i_cp;
+          break;
+        }
+    }
+  if (cp == NULL)
+    {
+      cp = g_new0 (ChangedProperty, 1);
+      cp->prop_id = prop_id;
+      cp->info = info;
+      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
+      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
+      g_value_copy (orig_value, &cp->orig_value);
+    }
+}
+
+static void
+gsd_accounts_skeleton_notify (GObject      *object,
+  GParamSpec *pspec G_GNUC_UNUSED)
+{
+  GsdAccountsSkeleton *skeleton = GSD_ACCOUNTS_SKELETON (object);
+  g_mutex_lock (&skeleton->priv->lock);
+  if (skeleton->priv->changed_properties != NULL &&
+      skeleton->priv->changed_properties_idle_source == NULL)
+    {
+      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
+      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
+      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _gsd_accounts_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
+      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _gsd_accounts_emit_changed");
+      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
+      g_source_unref (skeleton->priv->changed_properties_idle_source);
+    }
+  g_mutex_unlock (&skeleton->priv->lock);
+}
+
+static void
+gsd_accounts_skeleton_set_property (GObject      *object,
+  guint         prop_id,
+  const GValue *value,
+  GParamSpec   *pspec)
+{
+  GsdAccountsSkeleton *skeleton = GSD_ACCOUNTS_SKELETON (object);
+  g_assert (prop_id != 0 && prop_id - 1 < 3);
+  g_mutex_lock (&skeleton->priv->lock);
+  g_object_freeze_notify (object);
+  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
+    {
+      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
+        _gsd_accounts_schedule_emit_changed (skeleton, _gsd_accounts_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties[prop_id - 1]);
+      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
+      g_object_notify_by_pspec (object, pspec);
+    }
+  g_mutex_unlock (&skeleton->priv->lock);
+  g_object_thaw_notify (object);
+}
+
+static void
+gsd_accounts_skeleton_init (GsdAccountsSkeleton *skeleton)
+{
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+  skeleton->priv = gsd_accounts_skeleton_get_instance_private (skeleton);
+#else
+  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, GSD_TYPE_ACCOUNTS_SKELETON, GsdAccountsSkeletonPrivate);
+#endif
+
+  g_mutex_init (&skeleton->priv->lock);
+  skeleton->priv->context = g_main_context_ref_thread_default ();
+  skeleton->priv->properties = g_new0 (GValue, 3);
+  g_value_init (&skeleton->priv->properties[0], G_TYPE_STRING);
+  g_value_init (&skeleton->priv->properties[1], G_TYPE_BOOLEAN);
+  g_value_init (&skeleton->priv->properties[2], G_TYPE_BOOLEAN);
+}
+
+static const gchar *
+gsd_accounts_skeleton_get_daemon_version (GsdAccounts *object)
+{
+  GsdAccountsSkeleton *skeleton = GSD_ACCOUNTS_SKELETON (object);
+  const gchar *value;
+  g_mutex_lock (&skeleton->priv->lock);
+  value = g_value_get_string (&(skeleton->priv->properties[0]));
+  g_mutex_unlock (&skeleton->priv->lock);
+  return value;
+}
+
+static gboolean
+gsd_accounts_skeleton_get_has_no_users (GsdAccounts *object)
+{
+  GsdAccountsSkeleton *skeleton = GSD_ACCOUNTS_SKELETON (object);
+  gboolean value;
+  g_mutex_lock (&skeleton->priv->lock);
+  value = g_value_get_boolean (&(skeleton->priv->properties[1]));
+  g_mutex_unlock (&skeleton->priv->lock);
+  return value;
+}
+
+static gboolean
+gsd_accounts_skeleton_get_has_multiple_users (GsdAccounts *object)
+{
+  GsdAccountsSkeleton *skeleton = GSD_ACCOUNTS_SKELETON (object);
+  gboolean value;
+  g_mutex_lock (&skeleton->priv->lock);
+  value = g_value_get_boolean (&(skeleton->priv->properties[2]));
+  g_mutex_unlock (&skeleton->priv->lock);
+  return value;
+}
+
+static void
+gsd_accounts_skeleton_class_init (GsdAccountsSkeletonClass *klass)
+{
+  GObjectClass *gobject_class;
+  GDBusInterfaceSkeletonClass *skeleton_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  gobject_class->finalize = gsd_accounts_skeleton_finalize;
+  gobject_class->get_property = gsd_accounts_skeleton_get_property;
+  gobject_class->set_property = gsd_accounts_skeleton_set_property;
+  gobject_class->notify       = gsd_accounts_skeleton_notify;
+
+
+  gsd_accounts_override_properties (gobject_class, 1);
+
+  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
+  skeleton_class->get_info = gsd_accounts_skeleton_dbus_interface_get_info;
+  skeleton_class->get_properties = gsd_accounts_skeleton_dbus_interface_get_properties;
+  skeleton_class->flush = gsd_accounts_skeleton_dbus_interface_flush;
+  skeleton_class->get_vtable = gsd_accounts_skeleton_dbus_interface_get_vtable;
+
+#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
+  g_type_class_add_private (klass, sizeof (GsdAccountsSkeletonPrivate));
+#endif
+}
+
+static void
+gsd_accounts_skeleton_iface_init (GsdAccountsIface *iface)
+{
+  iface->user_added = _gsd_accounts_on_signal_user_added;
+  iface->user_deleted = _gsd_accounts_on_signal_user_deleted;
+  iface->get_daemon_version = gsd_accounts_skeleton_get_daemon_version;
+  iface->get_has_no_users = gsd_accounts_skeleton_get_has_no_users;
+  iface->get_has_multiple_users = gsd_accounts_skeleton_get_has_multiple_users;
+}
+
+/**
+ * gsd_accounts_skeleton_new:
+ *
+ * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-Accounts.top_of_page">org.freedesktop.Accounts</link>.
+ *
+ * Returns: (transfer full) (type GsdAccountsSkeleton): The skeleton object.
+ */
+GsdAccounts *
+gsd_accounts_skeleton_new (void)
+{
+  return GSD_ACCOUNTS (g_object_new (GSD_TYPE_ACCOUNTS_SKELETON, NULL));
+}
diff --git a/plugins/account/org.freedesktop.Accounts.h b/plugins/account/org.freedesktop.Accounts.h
new file mode 100644
index 00000000..b8d0625e
--- /dev/null
+++ b/plugins/account/org.freedesktop.Accounts.h
@@ -0,0 +1,400 @@
+/*
+ * Generated by gdbus-codegen 2.54.1. DO NOT EDIT.
+ *
+ * The license of this code is the same as for the source it was derived from.
+ */
+
+#ifndef __ORG_FREEDESKTOP_ACCOUNTS_H__
+#define __ORG_FREEDESKTOP_ACCOUNTS_H__
+
+#include <gio/gio.h>
+
+G_BEGIN_DECLS
+
+
+/* ------------------------------------------------------------------------ */
+/* Declarations for org.freedesktop.Accounts */
+
+#define GSD_TYPE_ACCOUNTS (gsd_accounts_get_type ())
+#define GSD_ACCOUNTS(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), GSD_TYPE_ACCOUNTS, GsdAccounts))
+#define GSD_IS_ACCOUNTS(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), GSD_TYPE_ACCOUNTS))
+#define GSD_ACCOUNTS_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), GSD_TYPE_ACCOUNTS, GsdAccountsIface))
+
+struct _GsdAccounts;
+typedef struct _GsdAccounts GsdAccounts;
+typedef struct _GsdAccountsIface GsdAccountsIface;
+
+struct _GsdAccountsIface
+{
+  GTypeInterface parent_iface;
+
+
+
+  gboolean (*handle_cache_user) (
+    GsdAccounts *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *arg_name);
+
+  gboolean (*handle_create_user) (
+    GsdAccounts *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *arg_name,
+    const gchar *arg_fullname,
+    gint arg_accountType);
+
+  gboolean (*handle_delete_user) (
+    GsdAccounts *object,
+    GDBusMethodInvocation *invocation,
+    gint64 arg_id,
+    gboolean arg_removeFiles);
+
+  gboolean (*handle_find_user_by_id) (
+    GsdAccounts *object,
+    GDBusMethodInvocation *invocation,
+    gint64 arg_id);
+
+  gboolean (*handle_find_user_by_name) (
+    GsdAccounts *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *arg_name);
+
+  gboolean (*handle_list_cached_users) (
+    GsdAccounts *object,
+    GDBusMethodInvocation *invocation);
+
+  gboolean (*handle_uncache_user) (
+    GsdAccounts *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *arg_name);
+
+  const gchar * (*get_daemon_version) (GsdAccounts *object);
+
+  gboolean  (*get_has_multiple_users) (GsdAccounts *object);
+
+  gboolean  (*get_has_no_users) (GsdAccounts *object);
+
+  void (*user_added) (
+    GsdAccounts *object,
+    const gchar *arg_user);
+
+  void (*user_deleted) (
+    GsdAccounts *object,
+    const gchar *arg_user);
+
+};
+
+GType gsd_accounts_get_type (void) G_GNUC_CONST;
+
+GDBusInterfaceInfo *gsd_accounts_interface_info (void);
+guint gsd_accounts_override_properties (GObjectClass *klass, guint property_id_begin);
+
+
+/* D-Bus method call completion functions: */
+void gsd_accounts_complete_list_cached_users (
+    GsdAccounts *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *const *users);
+
+void gsd_accounts_complete_find_user_by_id (
+    GsdAccounts *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *user);
+
+void gsd_accounts_complete_find_user_by_name (
+    GsdAccounts *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *user);
+
+void gsd_accounts_complete_create_user (
+    GsdAccounts *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *user);
+
+void gsd_accounts_complete_cache_user (
+    GsdAccounts *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *user);
+
+void gsd_accounts_complete_uncache_user (
+    GsdAccounts *object,
+    GDBusMethodInvocation *invocation);
+
+void gsd_accounts_complete_delete_user (
+    GsdAccounts *object,
+    GDBusMethodInvocation *invocation);
+
+
+
+/* D-Bus signal emissions functions: */
+void gsd_accounts_emit_user_added (
+    GsdAccounts *object,
+    const gchar *arg_user);
+
+void gsd_accounts_emit_user_deleted (
+    GsdAccounts *object,
+    const gchar *arg_user);
+
+
+
+/* D-Bus method calls: */
+void gsd_accounts_call_list_cached_users (
+    GsdAccounts *proxy,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean gsd_accounts_call_list_cached_users_finish (
+    GsdAccounts *proxy,
+    gchar ***out_users,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean gsd_accounts_call_list_cached_users_sync (
+    GsdAccounts *proxy,
+    gchar ***out_users,
+    GCancellable *cancellable,
+    GError **error);
+
+void gsd_accounts_call_find_user_by_id (
+    GsdAccounts *proxy,
+    gint64 arg_id,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean gsd_accounts_call_find_user_by_id_finish (
+    GsdAccounts *proxy,
+    gchar **out_user,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean gsd_accounts_call_find_user_by_id_sync (
+    GsdAccounts *proxy,
+    gint64 arg_id,
+    gchar **out_user,
+    GCancellable *cancellable,
+    GError **error);
+
+void gsd_accounts_call_find_user_by_name (
+    GsdAccounts *proxy,
+    const gchar *arg_name,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean gsd_accounts_call_find_user_by_name_finish (
+    GsdAccounts *proxy,
+    gchar **out_user,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean gsd_accounts_call_find_user_by_name_sync (
+    GsdAccounts *proxy,
+    const gchar *arg_name,
+    gchar **out_user,
+    GCancellable *cancellable,
+    GError **error);
+
+void gsd_accounts_call_create_user (
+    GsdAccounts *proxy,
+    const gchar *arg_name,
+    const gchar *arg_fullname,
+    gint arg_accountType,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean gsd_accounts_call_create_user_finish (
+    GsdAccounts *proxy,
+    gchar **out_user,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean gsd_accounts_call_create_user_sync (
+    GsdAccounts *proxy,
+    const gchar *arg_name,
+    const gchar *arg_fullname,
+    gint arg_accountType,
+    gchar **out_user,
+    GCancellable *cancellable,
+    GError **error);
+
+void gsd_accounts_call_cache_user (
+    GsdAccounts *proxy,
+    const gchar *arg_name,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean gsd_accounts_call_cache_user_finish (
+    GsdAccounts *proxy,
+    gchar **out_user,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean gsd_accounts_call_cache_user_sync (
+    GsdAccounts *proxy,
+    const gchar *arg_name,
+    gchar **out_user,
+    GCancellable *cancellable,
+    GError **error);
+
+void gsd_accounts_call_uncache_user (
+    GsdAccounts *proxy,
+    const gchar *arg_name,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean gsd_accounts_call_uncache_user_finish (
+    GsdAccounts *proxy,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean gsd_accounts_call_uncache_user_sync (
+    GsdAccounts *proxy,
+    const gchar *arg_name,
+    GCancellable *cancellable,
+    GError **error);
+
+void gsd_accounts_call_delete_user (
+    GsdAccounts *proxy,
+    gint64 arg_id,
+    gboolean arg_removeFiles,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean gsd_accounts_call_delete_user_finish (
+    GsdAccounts *proxy,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean gsd_accounts_call_delete_user_sync (
+    GsdAccounts *proxy,
+    gint64 arg_id,
+    gboolean arg_removeFiles,
+    GCancellable *cancellable,
+    GError **error);
+
+
+
+/* D-Bus property accessors: */
+const gchar *gsd_accounts_get_daemon_version (GsdAccounts *object);
+gchar *gsd_accounts_dup_daemon_version (GsdAccounts *object);
+void gsd_accounts_set_daemon_version (GsdAccounts *object, const gchar *value);
+
+gboolean gsd_accounts_get_has_no_users (GsdAccounts *object);
+void gsd_accounts_set_has_no_users (GsdAccounts *object, gboolean value);
+
+gboolean gsd_accounts_get_has_multiple_users (GsdAccounts *object);
+void gsd_accounts_set_has_multiple_users (GsdAccounts *object, gboolean value);
+
+
+/* ---- */
+
+#define GSD_TYPE_ACCOUNTS_PROXY (gsd_accounts_proxy_get_type ())
+#define GSD_ACCOUNTS_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), GSD_TYPE_ACCOUNTS_PROXY, GsdAccountsProxy))
+#define GSD_ACCOUNTS_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), GSD_TYPE_ACCOUNTS_PROXY, GsdAccountsProxyClass))
+#define GSD_ACCOUNTS_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GSD_TYPE_ACCOUNTS_PROXY, GsdAccountsProxyClass))
+#define GSD_IS_ACCOUNTS_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), GSD_TYPE_ACCOUNTS_PROXY))
+#define GSD_IS_ACCOUNTS_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), GSD_TYPE_ACCOUNTS_PROXY))
+
+typedef struct _GsdAccountsProxy GsdAccountsProxy;
+typedef struct _GsdAccountsProxyClass GsdAccountsProxyClass;
+typedef struct _GsdAccountsProxyPrivate GsdAccountsProxyPrivate;
+
+struct _GsdAccountsProxy
+{
+  /*< private >*/
+  GDBusProxy parent_instance;
+  GsdAccountsProxyPrivate *priv;
+};
+
+struct _GsdAccountsProxyClass
+{
+  GDBusProxyClass parent_class;
+};
+
+GType gsd_accounts_proxy_get_type (void) G_GNUC_CONST;
+
+#if GLIB_CHECK_VERSION(2, 44, 0)
+G_DEFINE_AUTOPTR_CLEANUP_FUNC (GsdAccountsProxy, g_object_unref)
+#endif
+
+void gsd_accounts_proxy_new (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data);
+GsdAccounts *gsd_accounts_proxy_new_finish (
+    GAsyncResult        *res,
+    GError             **error);
+GsdAccounts *gsd_accounts_proxy_new_sync (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error);
+
+void gsd_accounts_proxy_new_for_bus (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data);
+GsdAccounts *gsd_accounts_proxy_new_for_bus_finish (
+    GAsyncResult        *res,
+    GError             **error);
+GsdAccounts *gsd_accounts_proxy_new_for_bus_sync (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error);
+
+
+/* ---- */
+
+#define GSD_TYPE_ACCOUNTS_SKELETON (gsd_accounts_skeleton_get_type ())
+#define GSD_ACCOUNTS_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), GSD_TYPE_ACCOUNTS_SKELETON, GsdAccountsSkeleton))
+#define GSD_ACCOUNTS_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), GSD_TYPE_ACCOUNTS_SKELETON, GsdAccountsSkeletonClass))
+#define GSD_ACCOUNTS_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GSD_TYPE_ACCOUNTS_SKELETON, GsdAccountsSkeletonClass))
+#define GSD_IS_ACCOUNTS_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), GSD_TYPE_ACCOUNTS_SKELETON))
+#define GSD_IS_ACCOUNTS_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), GSD_TYPE_ACCOUNTS_SKELETON))
+
+typedef struct _GsdAccountsSkeleton GsdAccountsSkeleton;
+typedef struct _GsdAccountsSkeletonClass GsdAccountsSkeletonClass;
+typedef struct _GsdAccountsSkeletonPrivate GsdAccountsSkeletonPrivate;
+
+struct _GsdAccountsSkeleton
+{
+  /*< private >*/
+  GDBusInterfaceSkeleton parent_instance;
+  GsdAccountsSkeletonPrivate *priv;
+};
+
+struct _GsdAccountsSkeletonClass
+{
+  GDBusInterfaceSkeletonClass parent_class;
+};
+
+GType gsd_accounts_skeleton_get_type (void) G_GNUC_CONST;
+
+#if GLIB_CHECK_VERSION(2, 44, 0)
+G_DEFINE_AUTOPTR_CLEANUP_FUNC (GsdAccountsSkeleton, g_object_unref)
+#endif
+
+GsdAccounts *gsd_accounts_skeleton_new (void);
+
+
+G_END_DECLS
+
+#endif /* __ORG_FREEDESKTOP_ACCOUNTS_H__ */
diff --git a/plugins/account/org.freedesktop.Accounts.xml b/plugins/account/org.freedesktop.Accounts.xml
new file mode 100644
index 00000000..ed7db50c
--- /dev/null
+++ b/plugins/account/org.freedesktop.Accounts.xml
@@ -0,0 +1,248 @@
+<!DOCTYPE node PUBLIC
+"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN"
+"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd" >
+<node name="/" xmlns:doc="http://www.freedesktop.org/dbus/1.0/doc.dtd">
+  <interface name="org.freedesktop.Accounts">
+
+    <!-- ************************************************************ -->
+
+    <method name="ListCachedUsers">
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <arg name="users" direction="out" type="ao">
+        <doc:doc><doc:summary>Object paths of cached users</doc:summary></doc:doc>
+      </arg>
+
+      <doc:doc>
+        <doc:description>
+          <doc:para>
+            Lists users which have logged into the system locally before.
+            This is not meant to return an exhaustive list of all users.
+            It is possible for <doc:ref type="method" to="Accounts.FindUserByName">FindUserByName()</doc:ref>
+            to return a user that's not on the list.
+          </doc:para>
+        </doc:description>
+      </doc:doc>
+    </method>
+
+    <method name="FindUserById">
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <arg name="id" direction="in" type="x">
+        <doc:doc><doc:summary>The uid to look up</doc:summary></doc:doc>
+      </arg>
+      <arg name="user" direction="out" type="o">
+        <doc:doc><doc:summary>Object path of user</doc:summary></doc:doc>
+      </arg>
+
+      <doc:doc>
+        <doc:description>
+          <doc:para>
+            Finds a user by uid.
+          </doc:para>
+        </doc:description>
+        <doc:errors>
+          <doc:error name="org.freedesktop.Accounts.Error.Failed">if no user with the given uid exists</doc:error>
+        </doc:errors>
+      </doc:doc>
+    </method>
+
+    <method name="FindUserByName">
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <arg name="name" direction="in" type="s">
+        <doc:doc><doc:summary>The username to look up</doc:summary></doc:doc>
+      </arg>
+      <arg name="user" direction="out" type="o">
+        <doc:doc><doc:summary>Object path of user</doc:summary></doc:doc>
+      </arg>
+
+      <doc:doc>
+        <doc:description>
+          <doc:para>
+            Finds a user by its username.
+          </doc:para>
+        </doc:description>
+        <doc:errors>
+          <doc:error name="org.freedesktop.Accounts.Error.Failed">if no user with the given username exists</doc:error>
+        </doc:errors>
+      </doc:doc>
+    </method>
+
+    <method name="CreateUser">
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <arg name="name" direction="in" type="s">
+        <doc:doc><doc:summary>The username for the new user</doc:summary></doc:doc>
+      </arg>
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <arg name="fullname" direction="in" type="s">
+        <doc:doc><doc:summary>The real name for the new user</doc:summary></doc:doc>
+      </arg>
+      <arg name="user" direction="out" type="o">
+        <doc:doc><doc:summary>Object path of the new user</doc:summary></doc:doc>
+      </arg>
+      <arg name="accountType" direction="in" type="i">
+        <doc:doc>
+          <doc:summary>The account type, encoded as an integer</doc:summary>
+        </doc:doc>
+      </arg>
+      <doc:doc>
+        <doc:description>
+          <doc:para>
+            Creates a new user account.
+          </doc:para>
+          <doc:para>
+          The accountType argument can take the following values:
+          </doc:para>
+            <doc:list>
+              <doc:item>
+                <doc:term>0</doc:term>
+                <doc:definition>Standard user</doc:definition>
+              </doc:item>
+              <doc:item>
+                <doc:term>1</doc:term>
+                <doc:definition>Administrator</doc:definition>
+              </doc:item>
+            </doc:list>
+        </doc:description>
+        <doc:permission>
+          The caller needs the org.freedesktop.accounts.user-administration PolicyKit authorization.
+        </doc:permission>
+        <doc:errors>
+          <doc:error name="org.freedesktop.Accounts.Error.PermissionDenied">if the caller lacks the appropriate PolicyKit authorization</doc:error>
+          <doc:error name="org.freedesktop.Accounts.Error.Failed">if the operation failed</doc:error>
+        </doc:errors>
+      </doc:doc>
+    </method>
+
+    <method name="CacheUser">
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <arg name="name" direction="in" type="s">
+        <doc:doc><doc:summary>The username for the user</doc:summary></doc:doc>
+      </arg>
+      <arg name="user" direction="out" type="o">
+        <doc:doc><doc:summary>Object path of user</doc:summary></doc:doc>
+      </arg>
+
+      <doc:doc>
+        <doc:description>
+          <doc:para>
+            Caches a user account, so that it shows up in ListCachedUsers() output.
+            The user name may be a remote user, but the system must be able to lookup
+            the user name and resolve the user information.
+          </doc:para>
+        </doc:description>
+        <doc:permission>
+          The caller needs the org.freedesktop.accounts.user-administration PolicyKit authorization.
+        </doc:permission>
+        <doc:errors>
+          <doc:error name="org.freedesktop.Accounts.Error.PermissionDenied">if the caller lacks the appropriate PolicyKit authorization</doc:error>
+          <doc:error name="org.freedesktop.Accounts.Error.UserDoesNotExist">if the user name cannot be resolved</doc:error>
+        </doc:errors>
+      </doc:doc>
+    </method>
+
+    <method name="UncacheUser">
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <arg name="name" direction="in" type="s">
+        <doc:doc><doc:summary>The username for the user</doc:summary></doc:doc>
+      </arg>
+
+      <doc:doc>
+        <doc:description>
+          <doc:para>
+            Releases all metadata about a user account, including icon, language and session. If the user account is
+            from a remote server and the user has never logged in before, then that account will no longer show up
+            in ListCachedUsers() output.
+          </doc:para>
+        </doc:description>
+        <doc:permission>
+          The caller needs the org.freedesktop.accounts.user-administration PolicyKit authorization.
+        </doc:permission>
+        <doc:errors>
+          <doc:error name="org.freedesktop.Accounts.Error.PermissionDenied">if the caller lacks the appropriate PolicyKit authorization</doc:error>
+          <doc:error name="org.freedesktop.Accounts.Error.UserDoesNotExist">if the user name cannot be resolved</doc:error>
+        </doc:errors>
+      </doc:doc>
+    </method>
+
+    <method name="DeleteUser">
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <arg name="id" direction="in" type="x">
+        <doc:doc><doc:summary>The uid to delete</doc:summary></doc:doc>
+      </arg>
+      <arg name="removeFiles" direction="in" type="b">
+        <doc:doc><doc:summary>Whether to remove the users files</doc:summary></doc:doc>
+      </arg>
+
+      <doc:doc>
+        <doc:description>
+          <doc:para>
+            Deletes a user account.
+          </doc:para>
+        </doc:description>
+        <doc:permission>
+          The caller needs the org.freedesktop.accounts.user-administration PolicyKit authorization.
+        </doc:permission>
+        <doc:errors>
+          <doc:error name="org.freedesktop.Accounts.Error.PermissionDenied">if the caller lacks the appropriate PolicyKit authorization</doc:error>
+          <doc:error name="org.freedesktop.Accounts.Error.Failed">if the operation failed</doc:error>
+        </doc:errors>
+      </doc:doc>
+    </method>
+
+    <signal name="UserAdded">
+      <arg name="user" type="o">
+        <doc:doc><doc:summary>Object path of the user that was added.</doc:summary></doc:doc>
+      </arg>
+      <doc:doc>
+        <doc:description>
+          <doc:para>
+            Emitted when a user is added.
+          </doc:para>
+        </doc:description>
+      </doc:doc>
+    </signal>
+
+    <signal name="UserDeleted">
+      <arg name="user" type="o">
+        <doc:doc><doc:summary>Object path of the user that was deleted.</doc:summary></doc:doc>
+      </arg>
+      <doc:doc>
+        <doc:description>
+          <doc:para>
+            Emitted when a user is deleted.
+          </doc:para>
+        </doc:description>
+      </doc:doc>
+    </signal>
+
+   <property name="DaemonVersion" type="s" access="read">
+     <doc:doc>
+       <doc:description>
+         <doc:para>
+           The version of the running daemon.
+         </doc:para>
+       </doc:description>
+     </doc:doc>
+   </property>
+
+   <property name="HasNoUsers" type="b" access="read">
+     <doc:doc>
+       <doc:description>
+         <doc:para>
+           Whether or not the system has no users
+         </doc:para>
+       </doc:description>
+     </doc:doc>
+   </property>
+
+   <property name="HasMultipleUsers" type="b" access="read">
+     <doc:doc>
+       <doc:description>
+         <doc:para>
+           Whether or not the system has multiple users
+         </doc:para>
+       </doc:description>
+     </doc:doc>
+   </property>
+
+  </interface>
+</node>
diff --git a/plugins/account/org.gnome.SettingsDaemon.Account.desktop b/plugins/account/org.gnome.SettingsDaemon.Account.desktop
new file mode 100644
index 00000000..388fbd54
--- /dev/null
+++ b/plugins/account/org.gnome.SettingsDaemon.Account.desktop
@@ -0,0 +1,9 @@
+[Desktop Entry]
+Type=Application
+Name=GNOME Settings Daemon's housekeeping plugin
+Exec=/usr/libexec/gsd-account
+OnlyShowIn=GNOME;
+NoDisplay=true
+X-GNOME-Autostart-Phase=Initialization
+X-GNOME-Autostart-Notify=true
+X-GNOME-AutoRestart=true
diff --git a/plugins/account/org.gnome.SettingsDaemon.Account.desktop.in b/plugins/account/org.gnome.SettingsDaemon.Account.desktop.in
new file mode 100644
index 00000000..1a8ded7d
--- /dev/null
+++ b/plugins/account/org.gnome.SettingsDaemon.Account.desktop.in
@@ -0,0 +1,9 @@
+[Desktop Entry]
+Type=Application
+Name=GNOME Settings Daemon's housekeeping plugin
+Exec=@libexecdir@/gsd-account
+OnlyShowIn=GNOME;
+NoDisplay=true
+X-GNOME-Autostart-Phase=Initialization
+X-GNOME-Autostart-Notify=true
+X-GNOME-AutoRestart=true
diff --git a/plugins/meson.build b/plugins/meson.build
index 3db69da7..3c4d42ac 100644
--- a/plugins/meson.build
+++ b/plugins/meson.build
@@ -1,32 +1,33 @@
 enabled_plugins = [
   ['a11y-settings', 'A11ySettings'],
+  ['account', 'Account'],
   ['clipboard', 'Clipboard'],
   ['color', 'Color'],
   ['datetime', 'Datetime'],
   ['dummy', ''],
   ['power', 'Power'],
   ['housekeeping', 'Housekeeping'],
   ['keyboard', 'Keyboard'],
   ['media-keys', 'MediaKeys'],
   ['mouse', 'Mouse'],
   ['screensaver-proxy', 'ScreensaverProxy'],
   ['sharing', 'Sharing'],
   ['sound', 'Sound'],
   ['xsettings', 'XSettings']
 ]
 
 if enable_smartcard
   enabled_plugins += [['smartcard', 'Smartcard']]
 endif
 
 if enable_wacom
   enabled_plugins += [['wacom', 'Wacom']]
 endif
 
 if enable_cups
   enabled_plugins += [['print-notifications', 'PrintNotifications']]
 endif
 
 if enable_rfkill
   enabled_plugins += [['rfkill', 'Rfkill']]
 endif
-- 
2.21.0

